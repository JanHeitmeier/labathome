{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/chart.js/dist/chart.js","src/ADCExperimentController.ts","src/AirspeedExperimentController.ts","src/App.ts","src/DevelopCFCController.ts","src/DialogController.ts","src/FFTExperimentController.ts","src/HeaterExperimentController.ts","src/ScreenController.ts","src/flowchart/Flowchart.ts","src/flowchart/FlowchartCompiler.ts","src/flowchart/FlowchartConnector.ts","src/flowchart/FlowchartLink.ts","src/flowchart/FlowchartOperator.ts","src/flowchart/FlowchartOperatorImpl.ts","src/flowchart/SerializeContext.ts","src/flowchart/SimulationManager.ts","src/flowchart/Songs.ts","src/flowchart/TopologicalSorfDFS.ts","src/utils.ts"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACt4ZA,mCAA4B;AAC5B,uCAAgC;AAChC,yDA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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*!\n * Chart.js v3.6.2\n * https://www.chartjs.org\n * (c) 2021 Chart.js Contributors\n * Released under the MIT License\n */\n(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());\n}(this, (function () { 'use strict';\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\nconst requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\nfunction throttled(fn, thisArg, updateFn) {\n  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\n  let ticking = false;\n  let args = [];\n  return function(...rest) {\n    args = updateArgs(rest);\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, args);\n      });\n    }\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function(...args) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\nconst _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\nclass Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n  _update(date = Date.now()) {\n    let remaining = 0;\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n      for (; i >= 0; --i) {\n        item = items[i];\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n      remaining += items.length;\n    });\n    this._lastDate = date;\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\nvar animator = new Animator();\n\n/*!\n * @kurkle/color v0.1.9\n * https://github.com/kurkle/color#readme\n * (c) 2020 Jukka Kurkela\n * Released under the MIT License\n */\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = '0123456789ABCDEF';\nconst h1 = (b) => hex[b & 0xF];\nconst h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));\nfunction isShort(v) {\n\treturn eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\n}\nfunction hexParse(str) {\n\tvar len = str.length;\n\tvar ret;\n\tif (str[0] === '#') {\n\t\tif (len === 4 || len === 5) {\n\t\t\tret = {\n\t\t\t\tr: 255 & map$1[str[1]] * 17,\n\t\t\t\tg: 255 & map$1[str[2]] * 17,\n\t\t\t\tb: 255 & map$1[str[3]] * 17,\n\t\t\t\ta: len === 5 ? map$1[str[4]] * 17 : 255\n\t\t\t};\n\t\t} else if (len === 7 || len === 9) {\n\t\t\tret = {\n\t\t\t\tr: map$1[str[1]] << 4 | map$1[str[2]],\n\t\t\t\tg: map$1[str[3]] << 4 | map$1[str[4]],\n\t\t\t\tb: map$1[str[5]] << 4 | map$1[str[6]],\n\t\t\t\ta: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n\t\t\t};\n\t\t}\n\t}\n\treturn ret;\n}\nfunction hexString(v) {\n\tvar f = isShort(v) ? h1 : h2;\n\treturn v\n\t\t? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')\n\t\t: v;\n}\nfunction round(v) {\n\treturn v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n\treturn lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n\treturn lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n\treturn lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n\treturn lim(round(v * 100), 0, 100);\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n\tconst m = RGB_RE.exec(str);\n\tlet a = 255;\n\tlet r, g, b;\n\tif (!m) {\n\t\treturn;\n\t}\n\tif (m[7] !== r) {\n\t\tconst v = +m[7];\n\t\ta = 255 & (m[8] ? p2b(v) : v * 255);\n\t}\n\tr = +m[1];\n\tg = +m[3];\n\tb = +m[5];\n\tr = 255 & (m[2] ? p2b(r) : r);\n\tg = 255 & (m[4] ? p2b(g) : g);\n\tb = 255 & (m[6] ? p2b(b) : b);\n\treturn {\n\t\tr: r,\n\t\tg: g,\n\t\tb: b,\n\t\ta: a\n\t};\n}\nfunction rgbString(v) {\n\treturn v && (\n\t\tv.a < 255\n\t\t\t? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n\t\t\t: `rgb(${v.r}, ${v.g}, ${v.b})`\n\t);\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n\tconst a = s * Math.min(l, 1 - l);\n\tconst f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n\treturn [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n\tconst f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n\treturn [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n\tconst rgb = hsl2rgbn(h, 1, 0.5);\n\tlet i;\n\tif (w + b > 1) {\n\t\ti = 1 / (w + b);\n\t\tw *= i;\n\t\tb *= i;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\trgb[i] *= 1 - w - b;\n\t\trgb[i] += w;\n\t}\n\treturn rgb;\n}\nfunction rgb2hsl(v) {\n\tconst range = 255;\n\tconst r = v.r / range;\n\tconst g = v.g / range;\n\tconst b = v.b / range;\n\tconst max = Math.max(r, g, b);\n\tconst min = Math.min(r, g, b);\n\tconst l = (max + min) / 2;\n\tlet h, s, d;\n\tif (max !== min) {\n\t\td = max - min;\n\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\t\th = max === r\n\t\t\t? ((g - b) / d) + (g < b ? 6 : 0)\n\t\t\t: max === g\n\t\t\t\t? (b - r) / d + 2\n\t\t\t\t: (r - g) / d + 4;\n\t\th = h * 60 + 0.5;\n\t}\n\treturn [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n\treturn (\n\t\tArray.isArray(a)\n\t\t\t? f(a[0], a[1], a[2])\n\t\t\t: f(a, b, c)\n\t).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n\treturn calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n\treturn calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n\treturn calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n\treturn (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n\tconst m = HUE_RE.exec(str);\n\tlet a = 255;\n\tlet v;\n\tif (!m) {\n\t\treturn;\n\t}\n\tif (m[5] !== v) {\n\t\ta = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n\t}\n\tconst h = hue(+m[2]);\n\tconst p1 = +m[3] / 100;\n\tconst p2 = +m[4] / 100;\n\tif (m[1] === 'hwb') {\n\t\tv = hwb2rgb(h, p1, p2);\n\t} else if (m[1] === 'hsv') {\n\t\tv = hsv2rgb(h, p1, p2);\n\t} else {\n\t\tv = hsl2rgb(h, p1, p2);\n\t}\n\treturn {\n\t\tr: v[0],\n\t\tg: v[1],\n\t\tb: v[2],\n\t\ta: a\n\t};\n}\nfunction rotate(v, deg) {\n\tvar h = rgb2hsl(v);\n\th[0] = hue(h[0] + deg);\n\th = hsl2rgb(h);\n\tv.r = h[0];\n\tv.g = h[1];\n\tv.b = h[2];\n}\nfunction hslString(v) {\n\tif (!v) {\n\t\treturn;\n\t}\n\tconst a = rgb2hsl(v);\n\tconst h = a[0];\n\tconst s = n2p(a[1]);\n\tconst l = n2p(a[2]);\n\treturn v.a < 255\n\t\t? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n\t\t: `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map$1$1 = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n\tconst unpacked = {};\n\tconst keys = Object.keys(names);\n\tconst tkeys = Object.keys(map$1$1);\n\tlet i, j, k, ok, nk;\n\tfor (i = 0; i < keys.length; i++) {\n\t\tok = nk = keys[i];\n\t\tfor (j = 0; j < tkeys.length; j++) {\n\t\t\tk = tkeys[j];\n\t\t\tnk = nk.replace(k, map$1$1[k]);\n\t\t}\n\t\tk = parseInt(names[ok], 16);\n\t\tunpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n\t}\n\treturn unpacked;\n}\nlet names$1;\nfunction nameParse(str) {\n\tif (!names$1) {\n\t\tnames$1 = unpack();\n\t\tnames$1.transparent = [0, 0, 0, 0];\n\t}\n\tconst a = names$1[str.toLowerCase()];\n\treturn a && {\n\t\tr: a[0],\n\t\tg: a[1],\n\t\tb: a[2],\n\t\ta: a.length === 4 ? a[3] : 255\n\t};\n}\nfunction modHSL(v, i, ratio) {\n\tif (v) {\n\t\tlet tmp = rgb2hsl(v);\n\t\ttmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n\t\ttmp = hsl2rgb(tmp);\n\t\tv.r = tmp[0];\n\t\tv.g = tmp[1];\n\t\tv.b = tmp[2];\n\t}\n}\nfunction clone$1(v, proto) {\n\treturn v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n\tvar v = {r: 0, g: 0, b: 0, a: 255};\n\tif (Array.isArray(input)) {\n\t\tif (input.length >= 3) {\n\t\t\tv = {r: input[0], g: input[1], b: input[2], a: 255};\n\t\t\tif (input.length > 3) {\n\t\t\t\tv.a = n2b(input[3]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tv = clone$1(input, {r: 0, g: 0, b: 0, a: 1});\n\t\tv.a = n2b(v.a);\n\t}\n\treturn v;\n}\nfunction functionParse(str) {\n\tif (str.charAt(0) === 'r') {\n\t\treturn rgbParse(str);\n\t}\n\treturn hueParse(str);\n}\nclass Color {\n\tconstructor(input) {\n\t\tif (input instanceof Color) {\n\t\t\treturn input;\n\t\t}\n\t\tconst type = typeof input;\n\t\tlet v;\n\t\tif (type === 'object') {\n\t\t\tv = fromObject(input);\n\t\t} else if (type === 'string') {\n\t\t\tv = hexParse(input) || nameParse(input) || functionParse(input);\n\t\t}\n\t\tthis._rgb = v;\n\t\tthis._valid = !!v;\n\t}\n\tget valid() {\n\t\treturn this._valid;\n\t}\n\tget rgb() {\n\t\tvar v = clone$1(this._rgb);\n\t\tif (v) {\n\t\t\tv.a = b2n(v.a);\n\t\t}\n\t\treturn v;\n\t}\n\tset rgb(obj) {\n\t\tthis._rgb = fromObject(obj);\n\t}\n\trgbString() {\n\t\treturn this._valid ? rgbString(this._rgb) : this._rgb;\n\t}\n\thexString() {\n\t\treturn this._valid ? hexString(this._rgb) : this._rgb;\n\t}\n\thslString() {\n\t\treturn this._valid ? hslString(this._rgb) : this._rgb;\n\t}\n\tmix(color, weight) {\n\t\tconst me = this;\n\t\tif (color) {\n\t\t\tconst c1 = me.rgb;\n\t\t\tconst c2 = color.rgb;\n\t\t\tlet w2;\n\t\t\tconst p = weight === w2 ? 0.5 : weight;\n\t\t\tconst w = 2 * p - 1;\n\t\t\tconst a = c1.a - c2.a;\n\t\t\tconst w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\t\tw2 = 1 - w1;\n\t\t\tc1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n\t\t\tc1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n\t\t\tc1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n\t\t\tc1.a = p * c1.a + (1 - p) * c2.a;\n\t\t\tme.rgb = c1;\n\t\t}\n\t\treturn me;\n\t}\n\tclone() {\n\t\treturn new Color(this.rgb);\n\t}\n\talpha(a) {\n\t\tthis._rgb.a = n2b(a);\n\t\treturn this;\n\t}\n\tclearer(ratio) {\n\t\tconst rgb = this._rgb;\n\t\trgb.a *= 1 - ratio;\n\t\treturn this;\n\t}\n\tgreyscale() {\n\t\tconst rgb = this._rgb;\n\t\tconst val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n\t\trgb.r = rgb.g = rgb.b = val;\n\t\treturn this;\n\t}\n\topaquer(ratio) {\n\t\tconst rgb = this._rgb;\n\t\trgb.a *= 1 + ratio;\n\t\treturn this;\n\t}\n\tnegate() {\n\t\tconst v = this._rgb;\n\t\tv.r = 255 - v.r;\n\t\tv.g = 255 - v.g;\n\t\tv.b = 255 - v.b;\n\t\treturn this;\n\t}\n\tlighten(ratio) {\n\t\tmodHSL(this._rgb, 2, ratio);\n\t\treturn this;\n\t}\n\tdarken(ratio) {\n\t\tmodHSL(this._rgb, 2, -ratio);\n\t\treturn this;\n\t}\n\tsaturate(ratio) {\n\t\tmodHSL(this._rgb, 1, ratio);\n\t\treturn this;\n\t}\n\tdesaturate(ratio) {\n\t\tmodHSL(this._rgb, 1, -ratio);\n\t\treturn this;\n\t}\n\trotate(deg) {\n\t\trotate(this._rgb, deg);\n\t\treturn this;\n\t}\n}\nfunction index_esm(input) {\n\treturn new Color(input);\n}\n\nconst isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nfunction noop() {}\nconst uid = (function() {\n  let id = 0;\n  return function() {\n    return id++;\n  };\n}());\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : value / dimension;\nconst toDimension = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction clone(source) {\n  if (isArray(source)) {\n    return source.map(clone);\n  }\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  const merger = options.merger || _merger;\n  for (let i = 0; i < ilen; ++i) {\n    source = sources[i];\n    if (!isObject(source)) {\n      continue;\n    }\n    const keys = Object.keys(source);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, source, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  return merge(target, source, {merger: _mergerIf});\n}\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\nconst emptyString = '';\nconst dot = '.';\nfunction indexOfDotOrLength(key, start) {\n  const idx = key.indexOf(dot, start);\n  return idx === -1 ? key.length : idx;\n}\nfunction resolveObjectKey(obj, key) {\n  if (key === emptyString) {\n    return obj;\n  }\n  let pos = 0;\n  let idx = indexOfDotOrLength(key, pos);\n  while (obj && idx > pos) {\n    obj = obj[key.substr(pos, idx - pos)];\n    pos = idx + 1;\n    idx = indexOfDotOrLength(key, pos);\n  }\n  return obj;\n}\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value) => typeof value !== 'undefined';\nconst isFunction = (value) => typeof value === 'function';\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, ''), scope);\n}\nclass Defaults {\n  constructor(_descriptors) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.describe(_descriptors);\n  }\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n}\nvar defaults = new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n});\n\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < (-0.5 * PI)) {\n    angle += TAU;\n  }\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  let type, xOffset, yOffset, size, cornerRadius;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n  default:\n    ctx.arc(x, y, radius, 0, TAU);\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      ctx.rect(x - size, y - size, 2 * size, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n  ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction addRoundedRectPath(ctx, rect) {\n  const {x, y, w, h, radius} = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\n\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {lo, hi};\n}\nconst _lookupByKey = (table, key, value) =>\n  _lookup(table, value, index => table[index][key] < value);\nconst _rlookupByKey = (table, key, value) =>\n  _lookup(table, value, index => table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n  const set = new Set();\n  let i, ilen;\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n  if (set.size === ilen) {\n    return items;\n  }\n  return Array.from(set);\n}\n\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n  return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf('%') !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nconst getComputedStyle = (element) => window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(evt, canvas) {\n  const e = evt.native || evt;\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {offsetX, offsetY} = source;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\nfunction getRelativePosition$1(evt, chart) {\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(evt, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nconst round1 = v => Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n  return {\n    width,\n    height\n  };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  const canvas = chart.canvas;\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\nconst supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n  }\n  return passiveSupported;\n}());\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\nfunction getRelativePosition(e, chart) {\n  if ('native' in e) {\n    return {\n      x: e.x,\n      y: e.y\n    };\n  }\n  return getRelativePosition$1(e, chart);\n}\nfunction evaluateAllVisibleItems(chart, handler) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  let index, data, element;\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    ({index, data} = metasets[i]);\n    for (let j = 0, jlen = data.length; j < jlen; ++j) {\n      element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  return {lo: 0, hi: data.length - 1};\n}\nfunction optimizedEvaluateItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition) {\n  const items = [];\n  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition) {\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  let items = [];\n  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {\n      return;\n    }\n    const center = element.getCenterPoint(useFinalPosition);\n    if (!_isPointInArea(center, chart.chartArea, chart._minPadding) && !element.inRange(position.x, position.y, useFinalPosition)) {\n      return;\n    }\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getAxisItems(chart, e, options, useFinalPosition) {\n  const position = getRelativePosition(e, chart);\n  const items = [];\n  const axis = options.axis;\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      intersectsItem = true;\n    }\n  });\n  if (options.intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\nvar Interaction = {\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'x';\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition)\n        : getNearestItems(chart, position, axis, false, useFinalPosition);\n      const elements = [];\n      if (!items.length) {\n        return [];\n      }\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n      return elements;\n    },\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition) :\n        getNearestItems(chart, position, axis, false, useFinalPosition);\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n      return items;\n    },\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      return getIntersectItems(chart, position, axis, useFinalPosition);\n    },\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);\n    },\n    x(chart, e, options, useFinalPosition) {\n      return getAxisItems(chart, e, {axis: 'x', intersect: options.intersect}, useFinalPosition);\n    },\n    y(chart, e, options, useFinalPosition) {\n      return getAxisItems(chart, e, {axis: 'y', intersect: options.intersect}, useFinalPosition);\n    }\n  }\n};\n\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n  case 'px':\n    return value;\n  case '%':\n    value /= 100;\n    break;\n  }\n  return size * value;\n}\nconst numberOrZero$1 = v => +v || 0;\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n  for (const prop of keys) {\n    ret[prop] = numberOrZero$1(read(prop));\n  }\n  return ret;\n}\nfunction toTRBL(value) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = '';\n  }\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n  if (!isObject(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n  chartArea.x = x;\n  chartArea.y = y;\n}\ndefaults.set('layout', {\n  autoPadding: true,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n    chart.boxes.push(item);\n  },\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n    get(target, prop) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value;\n      delete target._keys;\n      return true;\n    }\n  });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n    get(target, prop, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n  });\n}\nfunction _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n  const value = resolve();\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop];\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  value = value(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, scope);\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      return null;\n    }\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop);\n  if (key === null) {\n    return false;\n  }\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n  return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (defined(value)) {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\nfunction splineCurveMonotone(points, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n      : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\nconst atEdge = (t) => t === 0 || t === 1;\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack(t) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n  easeInOutBounce: t => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n};\n\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n    : mode === 'after' ? t < 1 ? p1.y : p2.y\n    : t > 0 ? p2.y : p1.y\n  };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\nconst getLeftToRightAdapter = function() {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) {\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) {\n      return x;\n    },\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  let {start, end, loop} = segment;\n  let i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {start, end};\n}\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n  if (!count) {\n    return [];\n  }\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\nvar helpers = /*#__PURE__*/Object.freeze({\n__proto__: null,\neasingEffects: effects,\ncolor: color,\ngetHoverColor: getHoverColor,\nnoop: noop,\nuid: uid,\nisNullOrUndef: isNullOrUndef,\nisArray: isArray,\nisObject: isObject,\nisFinite: isNumberFinite,\nfiniteOrDefault: finiteOrDefault,\nvalueOrDefault: valueOrDefault,\ntoPercentage: toPercentage,\ntoDimension: toDimension,\ncallback: callback,\neach: each,\n_elementsEqual: _elementsEqual,\nclone: clone,\n_merger: _merger,\nmerge: merge,\nmergeIf: mergeIf,\n_mergerIf: _mergerIf,\n_deprecated: _deprecated,\nresolveObjectKey: resolveObjectKey,\n_capitalize: _capitalize,\ndefined: defined,\nisFunction: isFunction,\nsetsEqual: setsEqual,\ntoFontString: toFontString,\n_measureText: _measureText,\n_longestText: _longestText,\n_alignPixel: _alignPixel,\nclearCanvas: clearCanvas,\ndrawPoint: drawPoint,\n_isPointInArea: _isPointInArea,\nclipArea: clipArea,\nunclipArea: unclipArea,\n_steppedLineTo: _steppedLineTo,\n_bezierCurveTo: _bezierCurveTo,\nrenderText: renderText,\naddRoundedRectPath: addRoundedRectPath,\n_lookup: _lookup,\n_lookupByKey: _lookupByKey,\n_rlookupByKey: _rlookupByKey,\n_filterBetween: _filterBetween,\nlistenArrayEvents: listenArrayEvents,\nunlistenArrayEvents: unlistenArrayEvents,\n_arrayUnique: _arrayUnique,\n_createResolver: _createResolver,\n_attachContext: _attachContext,\n_descriptors: _descriptors,\nsplineCurve: splineCurve,\nsplineCurveMonotone: splineCurveMonotone,\n_updateBezierControlPoints: _updateBezierControlPoints,\n_isDomSupported: _isDomSupported,\n_getParentNode: _getParentNode,\ngetStyle: getStyle,\ngetRelativePosition: getRelativePosition$1,\ngetMaximumSize: getMaximumSize,\nretinaScale: retinaScale,\nsupportsEventListenerOptions: supportsEventListenerOptions,\nreadUsedSize: readUsedSize,\nfontString: fontString,\nrequestAnimFrame: requestAnimFrame,\nthrottled: throttled,\ndebounce: debounce,\n_toLeftRightCenter: _toLeftRightCenter,\n_alignStartEnd: _alignStartEnd,\n_textX: _textX,\n_pointInLine: _pointInLine,\n_steppedInterpolation: _steppedInterpolation,\n_bezierInterpolation: _bezierInterpolation,\nformatNumber: formatNumber,\ntoLineHeight: toLineHeight,\n_readValueToProps: _readValueToProps,\ntoTRBL: toTRBL,\ntoTRBLCorners: toTRBLCorners,\ntoPadding: toPadding,\ntoFont: toFont,\nresolve: resolve,\n_addGrace: _addGrace,\ncreateContext: createContext,\nPI: PI,\nTAU: TAU,\nPITAU: PITAU,\nINFINITY: INFINITY,\nRAD_PER_DEG: RAD_PER_DEG,\nHALF_PI: HALF_PI,\nQUARTER_PI: QUARTER_PI,\nTWO_THIRDS_PI: TWO_THIRDS_PI,\nlog10: log10,\nsign: sign,\nniceNum: niceNum,\n_factorize: _factorize,\nisNumber: isNumber,\nalmostEquals: almostEquals,\nalmostWhole: almostWhole,\n_setMinAndMaxByKey: _setMinAndMaxByKey,\ntoRadians: toRadians,\ntoDegrees: toDegrees,\n_decimalPlaces: _decimalPlaces,\ngetAngleFromPoint: getAngleFromPoint,\ndistanceBetweenPoints: distanceBetweenPoints,\n_angleDiff: _angleDiff,\n_normalizeAngle: _normalizeAngle,\n_angleBetween: _angleBetween,\n_limitValue: _limitValue,\n_int16Range: _int16Range,\n_isBetween: _isBetween,\ngetRtlAdapter: getRtlAdapter,\noverrideTextDirection: overrideTextDirection,\nrestoreTextDirection: restoreTextDirection,\n_boundSegment: _boundSegment,\n_boundSegments: _boundSegments,\n_computeSegments: _computeSegments\n});\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n  releaseContext(context) {\n    return false;\n  }\n  addEventListener(chart, type, listener) {}\n  removeEventListener(chart, type, listener) {}\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n  isAttached(canvas) {\n    return true;\n  }\n  updateConfig(config) {\n  }\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\nconst isNullOrEmpty = value => value === null || value === '';\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n  return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition$1(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, (args) => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\nclass DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n    return null;\n  }\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n    if (!proxy) {\n      return;\n    }\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n\nfunction _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nvar platforms = /*#__PURE__*/Object.freeze({\n__proto__: null,\n_detectPlatform: _detectPlatform,\nBasePlatform: BasePlatform,\nBasicPlatform: BasicPlatform,\nDomPlatform: DomPlatform\n});\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  color(from, to, factor) {\n    const c0 = color(from || transparent);\n    const c1 = c0.valid && color(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\nclass Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n  active() {\n    return this._active;\n  }\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n    this._active = from !== to && (loop || (elapsed < duration));\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n    this._target[prop] = this._fn(from, to, factor);\n  }\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\ndefaults.set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined,\n});\nconst animationOptions = Object.keys(defaults.animation);\ndefaults.describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n});\ndefaults.set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  },\n});\ndefaults.describe('animations', {\n  _fallback: 'animation',\n});\ndefaults.set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      },\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      },\n    }\n  }\n});\nclass Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n      });\n    }\n    return animations;\n  }\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n    const animations = this._createAnimations(target, values);\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\nfunction toClip(value) {\n  let t, r, b, l;\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n  if (value === null) {\n    return;\n  }\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n  return null;\n}\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n  }\n}\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n  }\n}\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\nclass DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n  }\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n  reset() {\n    this._update('reset');\n  }\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n    if (isObject(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        unlistenArrayEvents(_data, this);\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n  addElements() {\n    const meta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n    this._dataCheck();\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n    this._resyncElements(resetNewElements);\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        break;\n      }\n    }\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isNumberFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n  update(mode) {}\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    let i;\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    const context = () => this.getContext(index, active);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n    return values;\n  }\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n    if (count) {\n      this.parse(0, count);\n    }\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n  updateElements(element, start, count, mode) {}\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\n\nclass Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n  tooltipPosition(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n  getProps(props, final) {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      return this;\n    }\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n    });\n    return ret;\n  }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\n\nconst formatters = {\n  values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {formatters};\n\ndefaults.set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2,\n  }\n});\ndefaults.route('scale.ticks', 'color', '', 'color');\ndefaults.route('scale.grid', 'color', '', 'borderColor');\ndefaults.route('scale.grid', 'borderColor', '', 'borderColor');\ndefaults.route('scale.title', 'color', '', 'color');\ndefaults.describe('scale', {\n  _fallback: false,\n  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\n});\ndefaults.describe('scales', {\n  _fallback: 'scale',\n});\ndefaults.describe('scale.ticks', {\n  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: (name) => name !== 'backdropPadding',\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n  next = start;\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n  if (len < 2) {\n    return false;\n  }\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n  return (lines * font.lineHeight) + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\nfunction titleAlign(align, position, reverse) {\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\nclass Scale extends Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n  init(options) {\n    this.options = options.setContext(this.getContext());\n    this.axis = options.axis;\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n  parse(raw, index) {\n    return raw;\n  }\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isNumberFinite(_userMin),\n      maxDefined: isNumberFinite(_userMax)\n    };\n  }\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    callback(this.options.beforeUpdate, [this]);\n  }\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n    }\n    if (samplingEnabled) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    callback(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    callback(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    callback(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    callback(this.options[name], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n  beforeTickToLabelConversion() {\n    callback(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    callback(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    callback(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = this.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    callback(this.options.afterCalculateLabelRotation, [this]);\n  }\n  beforeFit() {\n    callback(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n    this._handleMargins();\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    callback(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(ticks);\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n    }\n    return labelSizes;\n  }\n  _computeLabelSizes(ticks, length) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n  getLabelForValue(value) {\n    return value;\n  }\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n  getValueForPixel(pixel) {}\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {min, max} = this;\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n  getContext(index) {\n    const ticks = this.ticks || [];\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n  _isVisible() {\n    const display = this.options.display;\n    if (display !== 'auto') {\n      return !!display;\n    }\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(this.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = grid.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(this, i, offset);\n      if (lineValue === undefined) {\n        continue;\n      }\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n    return items;\n  }\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      if (isHorizontal) {\n        x = pixel;\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n      let backdrop;\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        }\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        }\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor,\n        };\n      }\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop,\n      });\n    }\n    return items;\n  }\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n    let align = 'center';\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    }\n    return align;\n  }\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n    return {textAlign, x};\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const chart = this.chart;\n    const position = this.options.position;\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {chart, ctx, options: {grid}} = this;\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n    if (!optionTicks.display) {\n      return;\n    }\n    const ctx = this.ctx;\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    let i, ilen;\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n      let y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, item);\n    }\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n    if (!title.display) {\n      return;\n    }\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: gz + 1,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n\nclass TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n    if (isIChartComponent(proto)) {\n      parentScope = this.register(proto);\n    }\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n    if (id in items) {\n      return scope;\n    }\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n    return scope;\n  }\n  get(id) {\n    return this.items[id];\n  }\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n    if (id in items) {\n      delete items[id];\n    }\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n  defaults.set(scope, itemDefaults);\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...args) {\n    this._each('register', args);\n  }\n  remove(...args) {\n    this._each('unregister', args);\n  }\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        each(arg, item => {\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    callback(component['before' + camelMethod], [], component);\n    registry[method](component);\n    callback(component['after' + camelMethod], [], component);\n  }\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    return this.plugins;\n  }\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n}\nvar registry = new Registry();\n\nclass PluginService {\n  constructor() {\n    this._init = [];\n  }\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n    if (hook === 'destroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptors = this._cache = this._createDescriptors(chart);\n    this._notifyStateChanges(chart);\n    return descriptors;\n  }\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\nfunction allPlugins(config) {\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n    }\n  }\n  return plugins;\n}\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\nfunction createDescriptors(chart, plugins, options, all) {\n  const result = [];\n  const context = chart.getContext();\n  for (let i = 0; i < plugins.length; i++) {\n    const plugin = plugins[i];\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, plugin, opts, context)\n    });\n  }\n  return result;\n}\nfunction pluginOpts(config, plugin, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n  return scales;\n}\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\nclass Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(type) {\n    this._config.type = type;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(data) {\n    this._config.data = initData(data);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(options) {\n    this._config.options = options;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n  chartOptionScopes() {\n    const {options, type} = this;\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {},\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvar version = \"3.6.2\";\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n  return item;\n}\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\nclass Chart {\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas can be reused.'\n      );\n    }\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n    instances[this.id] = this;\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n    return height ? width / height : null;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(data) {\n    this.config.data = data;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this.config.options = options;\n  }\n  _initialize() {\n    this.notifyPlugins('beforeInit');\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins('afterInit');\n    return this;\n  }\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n    this.notifyPlugins('resize', {size: newSize});\n    callback(options.onResize, [this, newSize], this);\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n      scale.init(scaleOptions, options);\n    });\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n    this._removeUnreferencedMetasets();\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n    this._updateMetasets();\n    return newControllers;\n  }\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n  update(mode) {\n    const config = this.config;\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    const newControllers = this.buildOrUpdateControllers();\n    this.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n    if (!animsDisabled) {\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n    this._updateDatasets(mode);\n    this.notifyPlugins('afterUpdate', {mode});\n    this._layers.sort(compare2Level('z', '_idx'));\n    if (this._lastEvent) {\n      this._eventHandler(this._lastEvent, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n    layouts.update(this, this.width, this.height, minPadding);\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n    this.notifyPlugins('afterLayout');\n  }\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n    meta.controller._update(mode);\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this._drawDatasets();\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this.notifyPlugins('afterDraw');\n  }\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = this.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n    meta.controller.draw();\n    if (useClip) {\n      unclipArea(ctx);\n    }\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n    return [];\n  }\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n    return meta;\n  }\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n  destroy() {\n    const {canvas, ctx} = this;\n    this._stop();\n    this.config.clearCache();\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    this.notifyPlugins('destroy');\n    delete instances[this.id];\n  }\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n    each(this.options.events, (type) => _add(type, listener));\n  }\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n    let detached;\n    const attached = () => {\n      _remove('attach', attached);\n      this.attached = true;\n      this.resize();\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n    detached = () => {\n      this.attached = false;\n      _remove('resize', listener);\n      this._stop();\n      this._resize(0, 0);\n      _add('attach', attached);\n    };\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(e, replay) {\n    const args = {event: e, replay, cancelable: true};\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n    const changed = this._handleEvent(e, replay);\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n    if (changed || args.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(e, replay) {\n    const {_active: lastActive = [], options} = this;\n    const hoverOptions = options.hover;\n    const useFinalPosition = replay;\n    let active = [];\n    let changed = false;\n    let lastEvent = null;\n    if (e.type !== 'mouseout') {\n      active = this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n      lastEvent = e.type === 'click' ? this._lastEvent : e;\n    }\n    this._lastEvent = null;\n    if (_isPointInArea(e, this.chartArea, this._minPadding)) {\n      callback(options.onHover, [e, active, this], this);\n      if (e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu') {\n        callback(options.onClick, [e, active, this], this);\n      }\n    }\n    changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n    this._lastEvent = lastEvent;\n    return changed;\n  }\n}\nconst invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n  defaults: {\n    enumerable,\n    value: defaults\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: overrides\n  },\n  registry: {\n    enumerable,\n    value: registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n  formats() {\n    return abstract();\n  }\n  parse(value, format) {\n    return abstract();\n  }\n  format(timestamp, format) {\n    return abstract();\n  }\n  add(timestamp, amount, unit) {\n    return abstract();\n  }\n  diff(a, b, unit) {\n    return abstract();\n  }\n  startOf(timestamp, unit, weekday) {\n    return abstract();\n  }\n  endOf(timestamp, unit) {\n    return abstract();\n  }\n}\nDateAdapter.override = function(members) {\n  Object.assign(DateAdapter.prototype, members);\n};\nvar _adapters = {\n  _date: DateAdapter\n};\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n    if (defined(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n  return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\nclass BarController extends DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n  _getStacks(last, dataIndex) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const metasets = iScale.getMatchingVisibleMetas(this._type);\n    const stacked = iScale.options.stacked;\n    const ilen = metasets.length;\n    const stacks = [];\n    let i, item;\n    for (i = 0; i < ilen; ++i) {\n      item = metasets[i];\n      if (!item.controller.options.grouped) {\n        continue;\n      }\n      if (typeof dataIndex !== 'undefined') {\n        const val = item.controller.getParsed(dataIndex)[\n          item.controller._cachedMeta.vScale.axis\n        ];\n        if (isNullOrUndef(val) || isNaN(val)) {\n          continue;\n        }\n      }\n      if (stacked === false || stacks.indexOf(item.stack) === -1 ||\n\t\t\t\t(stacked === undefined && item.stack === undefined)) {\n        stacks.push(item.stack);\n      }\n      if (item.index === last) {\n        break;\n      }\n    }\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n    return stacks;\n  }\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1;\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n    size = head - base;\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      head = base + size;\n    }\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n}\nBarController.id = 'bar';\nBarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nBarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true,\n    }\n  }\n};\n\nclass BubbleController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n  update(mode) {\n    const points = this._cachedMeta.data;\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n      if (includeOptions) {\n        properties.options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(point, i, properties, mode);\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n    return values;\n  }\n}\nBubbleController.id = 'bubble';\nBubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nBubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\nclass DoughnutController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n  linkScales() {}\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n    meta.total = this.calculateTotal();\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    let startAngle = this._getRotation();\n    let i;\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n      this.updateElement(arc, i, properties, mode);\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n    return total;\n  }\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n    if (!arcs) {\n      return 0;\n    }\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n  getMaxOffset(arcs) {\n    let max = 0;\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n    return ringWeightOffset;\n  }\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nDoughnutController.id = 'doughnut';\nDoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    },\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r',\n};\nDoughnutController.descriptors = {\n  _scriptable: (name) => name !== 'spacing',\n  _indexable: (name) => name !== 'spacing',\n};\nDoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n          if (isArray(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n          return dataLabel;\n        }\n      }\n    }\n  }\n};\n\nclass LineController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    this.updateElements(points, start, count, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\nLineController.id = 'line';\nLineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false,\n};\nLineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n    },\n    _value_: {\n      type: 'linear',\n    },\n  }\n};\nfunction getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        _lookupByKey(_parsed, iScale.axis, min).lo,\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        _lookupByKey(_parsed, iScale.axis, max).hi + 1,\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {start, count};\n}\nfunction scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n\nclass PolarAreaController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const dataset = this.getDataset();\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / this.countVisibleElements();\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;\n      angle = endAngle;\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  countVisibleElements() {\n    const dataset = this.getDataset();\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\nPolarAreaController.id = 'polarArea';\nPolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    },\n  },\n  indexAxis: 'r',\n  startAngle: 0,\n};\nPolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends DoughnutController {\n}\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends DatasetController {\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      this.updateElement(line, undefined, properties, mode);\n    }\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const dataset = this.getDataset();\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  },\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear',\n    }\n  }\n};\n\nclass ScatterController extends LineController {\n}\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPolarAreaController: PolarAreaController,\nPieController: PieController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\nfunction pathArc(ctx, element, offset, spacing, end) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n  if (outerEnd > 0) {\n    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n  }\n  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n  ctx.lineTo(p4.x, p4.y);\n  if (innerEnd > 0) {\n    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n  }\n  ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\n  if (innerStart > 0) {\n    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n  }\n  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n  ctx.lineTo(p8.x, p8.y);\n  if (outerStart > 0) {\n    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n  }\n  ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + TAU);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % TAU;\n      if (circumference % TAU === 0) {\n        endAngle += TAU;\n      }\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle);\n  ctx.fill();\n  return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {x, y, startAngle, pixelMargin, fullCircles} = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n  if (inner) {\n    clipArc(ctx, element, startAngle + TAU);\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle) {\n  const {options} = element;\n  const inner = options.borderAlign === 'inner';\n  if (!options.borderWidth) {\n    return;\n  }\n  if (inner) {\n    ctx.lineWidth = options.borderWidth * 2;\n    ctx.lineJoin = 'round';\n  } else {\n    ctx.lineWidth = options.borderWidth;\n    ctx.lineJoin = 'bevel';\n  }\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n  pathArc(ctx, element, offset, spacing, endAngle);\n  ctx.stroke();\n}\nclass ArcElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n    return (betweenAngles && withinRadius);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference',\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n  draw(ctx) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    ctx.save();\n    let radiusOffset = 0;\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (this.startAngle + this.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n      if (this.circumference >= PI) {\n        radiusOffset = offset;\n      }\n    }\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, this, radiusOffset, spacing);\n    drawBorder(ctx, this, radiusOffset, spacing, endAngle);\n    ctx.restore();\n  }\n}\nArcElement.id = 'arc';\nArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined,\n};\nArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n  return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    prev = point;\n  }\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n  return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n    if (point.skip) {\n      continue;\n    }\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    lastY = y;\n  }\n  drawX();\n}\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n  return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\nclass LineElement extends Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n    if (!segments.length) {\n      return;\n    }\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n    start = start || 0;\n    count = count || (this.points.length - start);\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n    if (points.length && options.borderWidth) {\n      ctx.save();\n      draw(ctx, this, start, count);\n      ctx.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\nLineElement.id = 'line';\nLineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0,\n};\nLineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nLineElement.descriptors = {\n  _scriptable: true,\n  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\nclass PointElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n  draw(ctx, area) {\n    const options = this.options;\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n}\nPointElement.id = 'point';\nPointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nPointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n  return {left, top, right, bottom};\n}\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || isObject(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\nclass BarElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\nBarElement.id = 'bar';\nBarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: 'auto',\n  pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nLineElement: LineElement,\nPointElement: PointElement,\nBarElement: BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n    maxArea = area = -1;\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n  return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {value: data});\n  }\n}\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n  return {start, count};\n}\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n      if (meta.type !== 'line') {\n        return;\n      }\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n      if (chart.options.parsing) {\n        return;\n      }\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n      if (isNullOrUndef(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n      dataset._decimated = decimated;\n    });\n  },\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n  if (fill === false || fill === null) {\n    return false;\n  }\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\nfunction decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n  let target = parseFloat(fill);\n  if (isNumberFinite(target) && Math.floor(target) === target) {\n    if (fill[0] === '-' || fill[0] === '+') {\n      target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n      return false;\n    }\n    return target;\n  }\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  let target = null;\n  let horizontal;\n  if (fill === 'start') {\n    target = scale.bottom;\n  } else if (fill === 'end') {\n    target = scale.top;\n  } else if (isObject(fill)) {\n    target = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    target = scale.getBasePixel();\n  }\n  if (isNumberFinite(target)) {\n    horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? target : null,\n      y: horizontal ? null : target\n    };\n  }\n  return null;\n}\nclass simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const target = [];\n  const start = options.reverse ? scale.max : scale.min;\n  const end = options.reverse ? scale.min : scale.max;\n  let i, center, value;\n  if (fill === 'start') {\n    value = start;\n  } else if (fill === 'end') {\n    value = end;\n  } else if (isObject(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  if (options.grid.circular) {\n    center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n  for (i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\nfunction findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\nfunction pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\nfunction buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\nfunction getTarget(source) {\n  const {chart, fill, line} = source;\n  if (isNumberFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n  if (fill === 'stack') {\n    return buildStackLine(source);\n  }\n  if (fill === 'shape') {\n    return true;\n  }\n  const boundary = computeBoundary(source);\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n  return createBoundaryLine(boundary, line);\n}\nfunction createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n  if (isArray(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = pointsFromSegments(boundary, line);\n  }\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\nfunction resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n  if (!propagate) {\n    return fill;\n  }\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isNumberFinite(fill)) {\n      return fill;\n    }\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n    if (target.visible) {\n      return fill;\n    }\n    visited.push(fill);\n    fill = target.fill;\n  }\n  return false;\n}\nfunction _clip(ctx, target, clipY) {\n  ctx.beginPath();\n  target.path(ctx);\n  ctx.lineTo(target.last().x, clipY);\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\nfunction getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = findSegmentEnd(start, end, points);\n    const bounds = getBounds(property, points[start], points[end], segment.loop);\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n    const targetSegments = _boundSegments(target, bounds);\n    for (const tgt of targetSegments) {\n      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\nfunction _fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n  if (property === 'x' && below !== above) {\n    _clip(ctx, target, area.top);\n    _fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    _clip(ctx, target, area.bottom);\n  }\n  _fill(ctx, {line, target, color: below, scale, property});\n  ctx.restore();\n}\nfunction drawfill(ctx, source, area) {\n  const target = getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\nvar plugin_filler = {\n  id: 'filler',\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n      meta.$filler = source;\n      sources.push(source);\n    }\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n      source.fill = resolveTarget(sources, i, options.propagate);\n    }\n  },\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n      source.line.updateControlPoints(area, source.axis);\n      if (draw) {\n        drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (source) {\n        drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n    drawfill(chart.ctx, source, chart.chartArea);\n  },\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = Math.min(boxWidth, fontSize);\n  }\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n    this.legendItems = legendItems;\n  }\n  fit() {\n    const {options, ctx} = this;\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n    if (this.isHorizontal()) {\n      width = this.maxWidth;\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight;\n      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight});\n    return totalWidth;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n      this._draw();\n      unclipArea(ctx);\n    }\n  }\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {color: fontColor, padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    this.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n      ctx.save();\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxWidth * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        drawPoint(ctx, drawOptions, centerX, centerY);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n        ctx.beginPath();\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    };\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n    overrideTextDirection(this.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(this.width);\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    if (!titleOpts.display) {\n      return;\n    }\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = this.left;\n    let maxWidth = this.width;\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n    const x = _alignStartEnd(position, left, left + maxWidth);\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          return this.legendItems[i];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n    if (e.type === 'mousemove') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        callback(opts.onLeave, [e, previous, this], this);\n      }\n      this._hoveredItem = hoveredItem;\n      if (hoveredItem && !sameItem) {\n        callback(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      callback(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\nfunction isListened(type, opts) {\n  if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\nvar plugin_legend = {\n  id: 'legend',\n  _element: Legend,\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n\nclass Title extends Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    if (!opts.display) {\n      return;\n    }\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\nvar plugin_title = {\n  id: 'title',\n  _element: Title,\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n    return {\n      x,\n      y\n    };\n  }\n};\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n  return base;\n}\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip._chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n  ctx.save();\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {width, height};\n}\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n  return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n  const yAlign = options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._chart = config._chart;\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n    if (cached) {\n      return cached;\n    }\n    const chart = this._chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this._chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this._chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(context, options) {\n    const {callbacks} = options;\n    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\n    const title = callbacks.title.apply(this, [context]);\n    const afterTitle = callbacks.afterTitle.apply(this, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\n    const footer = callbacks.footer.apply(this, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n  _createItems(options) {\n    const active = this._active;\n    const data = this._chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this._chart, active[i]));\n    }\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(this, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n      labelTextColors.push(scoped.labelTextColor.call(this, context));\n    });\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this._chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this._chart);\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n    if (changed && options.external) {\n      options.external.call(this, {chart: this._chart, tooltip: this, replay});\n    }\n  }\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColors = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = labelColors.borderWidth || 1;\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n      const borderRadius = toTRBLCorners(labelColors.borderRadius);\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n      each(bodyItem.after, fillLineOfText);\n    }\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = toFont(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n    ctx.fill();\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n  _updateAnimationTarget(options) {\n    const chart = this._chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n    if (!opacity) {\n      return;\n    }\n    this._updateAnimationTarget(options);\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = toPadding(options.padding);\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      this.drawBackground(pt, ctx, tooltipSize, options);\n      overrideTextDirection(ctx, options.textDirection);\n      pt.y += padding.top;\n      this.drawTitle(pt, ctx, options);\n      this.drawBody(pt, ctx, options);\n      this.drawFooter(pt, ctx, options);\n      restoreTextDirection(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this._chart.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this.update(true);\n    }\n  }\n  handleEvent(e, replay) {\n    const options = this.options;\n    const lastActive = this._active || [];\n    let changed = false;\n    let active = [];\n    if (e.type !== 'mouseout') {\n      active = this._chart.getElementsAtEventForMode(e, options.mode, options, replay);\n      if (options.reverse) {\n        active.reverse();\n      }\n    }\n    const positionChanged = this._positionChanged(active, e);\n    changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n    if (changed) {\n      this._active = active;\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        this.update(true, replay);\n      }\n    }\n    return changed;\n  }\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({_chart: chart, options});\n    }\n  },\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    const args = {\n      tooltip\n    };\n    if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n      return;\n    }\n    if (tooltip) {\n      tooltip.draw(chart.ctx);\n    }\n    chart.notifyPlugins('afterTooltipDraw', args);\n  },\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {\n        args.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: noop,\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n        return '';\n      },\n      afterTitle: noop,\n      beforeBody: noop,\n      beforeLabel: noop,\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n          label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n          label += value;\n        }\n        return label;\n      },\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0,\n        };\n      },\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation,\n        };\n      },\n      afterLabel: noop,\n      afterBody: noop,\n      beforeFooter: noop,\n      footer: noop,\n      afterFooter: noop\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nDecimation: plugin_decimation,\nFiller: plugin_filler,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n    return value;\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nCategoryScale.id = 'category';\nCategoryScale.defaults = {\n  ticks: {\n    callback: CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n  if (!isNullOrUndef(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n      if (niceMin < min) {\n        j++;\n      }\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n  for (; j < numSpaces; ++j) {\n    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n  }\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n  return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n    return +raw;\n  }\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n    if (min === max) {\n      let offset = 1;\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n      setMax(max + offset);\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n    return maxTicks;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n    super.configure();\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n\nclass LinearScale extends LinearScaleBase {\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? min : 0;\n    this.max = isNumberFinite(max) ? max : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\nLinearScale.id = 'linear';\nLinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\n  return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor(log10(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n  let exp = Math.floor(log10(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  do {\n    ticks.push({value: tickVal, major: isMajor(tickVal)});\n    ++significand;\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || (exp === endExp && significand < endSignificand));\n  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\n  ticks.push({value: lastTick, major: isMajor(tickVal)});\n  return ticks;\n}\nclass LogarithmicScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isNumberFinite(value) && value > 0 ? value : null;\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n    this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n      setMin(exp(min, -1));\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const start = this.min;\n    super.configure();\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\nLogarithmicScale.id = 'logarithmic';\nLogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\nfunction fitWithPointLabels(scale) {\n  const furthestLimits = {\n    l: 0,\n    r: scale.width,\n    t: 0,\n    b: scale.height - scale.paddingTop\n  };\n  const furthestAngles = {};\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale.getLabels().length;\n  for (let i = 0; i < valueCount; i++) {\n    const opts = scale.options.pointLabels.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = scale.getIndexAngle(i);\n    const angle = toDegrees(angleRadians);\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    if (hLimits.start < furthestLimits.l) {\n      furthestLimits.l = hLimits.start;\n      furthestAngles.l = angleRadians;\n    }\n    if (hLimits.end > furthestLimits.r) {\n      furthestLimits.r = hLimits.end;\n      furthestAngles.r = angleRadians;\n    }\n    if (vLimits.start < furthestLimits.t) {\n      furthestLimits.t = vLimits.start;\n      furthestAngles.t = angleRadians;\n    }\n    if (vLimits.end > furthestLimits.b) {\n      furthestLimits.b = vLimits.end;\n      furthestAngles.b = angleRadians;\n    }\n  }\n  scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale.getLabels().length;\n  const opts = scale.options;\n  const tickBackdropHeight = getTickBackdropHeight(opts);\n  const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n  for (let i = 0; i < valueCount; i++) {\n    const extra = (i === 0 ? tickBackdropHeight / 2 : 0);\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);\n    const angle = toDegrees(scale.getIndexAngle(i));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n  return items;\n}\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n  return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\n    const {backdropColor} = optsAtIndex;\n    if (!isNullOrUndef(backdropColor)) {\n      const padding = toPadding(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);\n    }\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {color, lineWidth} = gridLineOpts;\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\nfunction numberOrZero(param) {\n  return isNumber(param) ? param : 0;\n}\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\nclass RadialLinearScale extends LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    this.width = this.maxWidth;\n    this.height = this.maxHeight;\n    this.paddingTop = getTickBackdropHeight(this.options) / 2;\n    this.xCenter = Math.floor(this.width / 2);\n    this.yCenter = Math.floor((this.height - this.paddingTop) / 2);\n    this.drawingArea = Math.min(this.height - this.paddingTop, this.width) / 2;\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n    this._pointLabels = this.getLabels().map((value, index) => {\n      const label = callback(this.options.pointLabels.callback, [value, index], this);\n      return label || label === 0 ? label : '';\n    });\n  }\n  fit() {\n    const opts = this.options;\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {\n    let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n    let radiusReductionRight = Math.max(furthestLimits.r - this.width, 0) / Math.sin(furthestAngles.r);\n    let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n    let radiusReductionBottom = -Math.max(furthestLimits.b - (this.height - this.paddingTop), 0) / Math.cos(furthestAngles.b);\n    radiusReductionLeft = numberOrZero(radiusReductionLeft);\n    radiusReductionRight = numberOrZero(radiusReductionRight);\n    radiusReductionTop = numberOrZero(radiusReductionTop);\n    radiusReductionBottom = numberOrZero(radiusReductionBottom);\n    this.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(\n      Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n      Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));\n    this.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n  }\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    const maxRight = this.width - rightMovement - this.drawingArea;\n    const maxLeft = leftMovement + this.drawingArea;\n    const maxTop = topMovement + this.drawingArea;\n    const maxBottom = (this.height - this.paddingTop) - bottomMovement - this.drawingArea;\n    this.xCenter = Math.floor(((maxLeft + maxRight) / 2) + this.left);\n    this.yCenter = Math.floor(((maxTop + maxBottom) / 2) + this.top + this.paddingTop);\n  }\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / this.getLabels().length;\n    const startAngle = this.options.startAngle || 0;\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n  getPointPosition(index, distanceFromCenter) {\n    const angle = this.getIndexAngle(index) - HALF_PI;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this.getLabels().length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid} = opts;\n    const labelCount = this.getLabels().length;\n    let i, offset, position;\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(this.getContext(index - 1));\n          drawRadiusLine(this, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n    if (angleLines.display) {\n      ctx.save();\n      for (i = this.getLabels().length - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n        if (!lineWidth || !color) {\n          continue;\n        }\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n  drawBorder() {}\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    if (!tickOpts.display) {\n      return;\n    }\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n      });\n    });\n    ctx.restore();\n  }\n  drawTitle() {}\n}\nRadialLinearScale.id = 'radialLinear';\nRadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n    callback(label) {\n      return label;\n    },\n    padding: 5\n  }\n};\nRadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nRadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\n\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\nconst UNITS = (Object.keys(INTERVALS));\nfunction sorter(a, b) {\n  return a - b;\n}\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n  if (!isNumberFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n  if (value === null) {\n    return null;\n  }\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n  return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);\n    mergeIf(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n    if (!minDefined || !maxDefined) {\n      _applyBounds(this._getLabelBounds());\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n    const min = this.min;\n    const max = this.max;\n    const ticks = _filterBetween(timestamps, min, max);\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n    if (options.reverse) {\n      ticks.reverse();\n    }\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n  initOffsets(timestamps) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    const formatter = options.ticks.callback;\n    return formatter ? callback(formatter, [label, index, ticks], this) : label;\n  }\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const metas = this.getMatchingVisibleMetas();\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n    return (this._cache.data = this.normalize(timestamps));\n  }\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n  normalize(values) {\n    return _arrayUnique(values.sort(sorter));\n  }\n}\nTimeScale.id = 'time';\nTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n    if (items.length < 2) {\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n    return timestamps;\n  }\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = TimeScale.defaults;\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nChart.register(controllers, scales, elements, plugins);\nChart.helpers = {...helpers};\nChart._adapters = _adapters;\nChart.Animation = Animation;\nChart.Animations = Animations;\nChart.animator = animator;\nChart.controllers = registry.controllers.items;\nChart.DatasetController = DatasetController;\nChart.Element = Element;\nChart.elements = elements;\nChart.Interaction = Interaction;\nChart.layouts = layouts;\nChart.platforms = platforms;\nChart.Scale = Scale;\nChart.Ticks = Ticks;\nObject.assign(Chart, controllers, scales, elements, plugins, platforms);\nChart.Chart = Chart;\nif (typeof window !== 'undefined') {\n  window.Chart = Chart;\n}\n\nreturn Chart;\n\n})));\n","import { $ } from \"./utils\";\r\nimport { Chart} from 'chart.js';\r\nimport { ScreenController } from \"./ScreenController\";\r\nimport { AppManagement } from \"./AppManagement\";\r\nimport { SerializeContext } from \"./flowchart/SerializeContext\";\r\n\r\nexport let DE_de = new Intl.NumberFormat('de-DE');\r\nexport const CHART_EACH_INTERVAL = 2;\r\n\r\nexport class ADCExperimentController extends ScreenController {\r\n    private butRecord: HTMLButtonElement;\r\n    private butStop: HTMLButtonElement;\r\n    private butDelete: HTMLButtonElement;\r\n    private tbody: HTMLTableSectionElement;\r\n    private tfirstRow: HTMLTableRowElement;\r\n    private timer: number | undefined;\r\n    private chart: Chart;\r\n    private counter = 10 ^ 6;\r\n    private seconds = 0;\r\n\r\n    private recording = false;\r\n\r\n    public onFirstStart(): void {\r\n        this.timer = window.setInterval(() => { this.sendAndReceive(); }, 1000);\r\n    }\r\n    public onRestart(): void {\r\n        this.timer = window.setInterval(() => { this.sendAndReceive(); }, 1000);\r\n    }\r\n    public onStop(): void {\r\n        window.clearInterval(this.timer);\r\n        this.butStop.hidden = true;\r\n        this.butRecord.hidden = false;\r\n        this.counter = 10 ^ 6;\r\n    }\r\n    public onCreate() {\r\n        this.resetData();\r\n    }\r\n\r\n    private resetData() {\r\n        this.chart.data!.labels = [];\r\n        this.chart.data!.datasets!.forEach((dataset) => {\r\n            dataset!.data = [];\r\n        });\r\n        this.chart.update();\r\n        this.tbody.innerText = \"\";\r\n        this.seconds = 0;\r\n    }\r\n\r\n    private sendAndReceive() {\r\n\r\n        let xhr = new XMLHttpRequest;\r\n        xhr.onerror = (e) => { console.log(\"Fehler beim XMLHttpRequest!\"); };\r\n        xhr.open(\"GET\", \"/adcexperiment\", true);\r\n        xhr.responseType = \"arraybuffer\";\r\n        xhr.onload = (e) => {\r\n            let Values: number[]=[0,0,0,0];\r\n            let arrayBuffer = xhr.response; // Note: not oReq.responseText\r\n            if (arrayBuffer || arrayBuffer.byteLength == 4 + 4 + 4 + 4) {\r\n                let ctx = new SerializeContext(arrayBuffer);\r\n                Values[0] = ctx.readF32();\r\n                Values[1] = ctx.readF32();\r\n                Values[2] = ctx.readF32();\r\n                Values[3] = ctx.readF32();\r\n            }\r\n            let now = new Date(Date.now());\r\n\r\n            if (this.recording) {\r\n                let tr = $.HtmlAsFirstChild(this.tbody, \"tr\", []);\r\n                for (let i = 0; i < 6; i++) {\r\n                    $.Html(tr, \"td\", [], [], this.tfirstRow.children[i].textContent!);\r\n                }\r\n                if (this.counter >= CHART_EACH_INTERVAL) {\r\n                    if (this.chart.data!.labels!.length > 100) {\r\n                        this.chart.data!.labels?.shift();\r\n                        this.chart.data!.datasets!.forEach((dataset) => {\r\n                            dataset!.data!.shift();\r\n                        });\r\n                    }\r\n                    this.chart.data!.labels!.push(now.toLocaleTimeString(\"de-DE\"));\r\n                    this.chart.data?.datasets![0].data?.push(Values[0]);\r\n                    this.chart.data?.datasets![1].data?.push(Values[1]);\r\n                    this.chart.data?.datasets![2].data?.push(Values[2]);\r\n                    this.chart.data?.datasets![3].data?.push(Values[3]);\r\n                    this.chart.update();\r\n                    this.counter = 0;\r\n                }\r\n                this.counter++;\r\n                this.seconds++;\r\n            }\r\n            this.tfirstRow.children[0].textContent = now.toLocaleTimeString(\"de-DE\");\r\n            this.tfirstRow.children[1].textContent = DE_de.format(this.seconds);\r\n            this.tfirstRow.children[2].textContent = DE_de.format(Values[0]);\r\n            this.tfirstRow.children[3].textContent = DE_de.format(Values[1]);\r\n            this.tfirstRow.children[4].textContent = DE_de.format(Values[2]);\r\n            this.tfirstRow.children[5].textContent = DE_de.format(Values[3]);\r\n        };\r\n        xhr.send();\r\n    }\r\n\r\n    constructor(appManagement:AppManagement, div: HTMLDivElement) {\r\n        super(appManagement, div);\r\n        this.butRecord = <HTMLButtonElement>document.getElementById(\"adcexperiment_butRecord\")!;\r\n        this.butStop = <HTMLButtonElement>document.getElementById(\"adcexperiment_butStop\")!;\r\n        this.butStop.hidden = true;\r\n        this.butDelete = <HTMLButtonElement>document.getElementById(\"adcexperiment_butDelete\")!;\r\n        this.tbody = <HTMLTableSectionElement>document.getElementById(\"adcexperiment_tabBody\")!;\r\n        this.tfirstRow = <HTMLTableRowElement>document.getElementById(\"adcexperiment_tabFirstRow\")!;\r\n\r\n        let ctx = <HTMLCanvasElement>document.getElementById('adcexperiment_chart')!;\r\n        this.chart = new Chart(ctx,{\r\n            type: 'line',\r\n            data: {\r\n                labels: [],\r\n                datasets: [\r\n                    {\r\n                        label: \"Input 0 [V]\",\r\n                        data: [],\r\n                        backgroundColor: \"red\",\r\n                        borderColor: \"red\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Input 1 [V]\",\r\n                        data: [],\r\n                        backgroundColor: \"green\",\r\n                        borderColor: \"green\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Input 2 [V]\",\r\n                        data: [],\r\n                        backgroundColor: \"blue\",\r\n                        borderColor: \"blue\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Input 3 [V]\",\r\n                        data: [],\r\n                        backgroundColor: \"grey\",\r\n                        borderColor: \"grey\",\r\n                        fill: false,\r\n                    },\r\n                ]\r\n            },\r\n            options: {\r\n                responsive: true,\r\n                maintainAspectRatio: false,\r\n                hover: {\r\n                    mode: 'nearest',\r\n                    intersect: true\r\n                },\r\n                scales: {\r\n                    y: {\r\n                        beginAtZero: true\r\n                    } \r\n                }\r\n            }\r\n        });\r\n\r\n        this.butStop.onclick = (e) => {\r\n            this.butStop.hidden = true;\r\n            this.butRecord.hidden = false;\r\n            this.recording = false;\r\n        };\r\n\r\n        this.butRecord.onclick = (e) => {\r\n            this.butRecord.hidden = true;\r\n            this.butStop.hidden = false;\r\n            this.recording = true;\r\n        };\r\n\r\n        this.butDelete.onclick = (e) => {\r\n            this.resetData();\r\n        };\r\n    }\r\n}\r\n","import { $ } from \"./utils\";\r\nimport { Chart} from 'chart.js';\r\nimport { ScreenController } from \"./ScreenController\";\r\nimport { AppManagement } from \"./AppManagement\";\r\nimport { SerializeContext } from \"./flowchart/SerializeContext\";\r\n\r\nconst DE_de = new Intl.NumberFormat('de-DE');\r\nconst CHART_EACH_INTERVAL = 2;\r\n\r\nexport class AirspeedExperimentController extends ScreenController {\r\n    private butRecord: HTMLButtonElement;\r\n    private butStop: HTMLButtonElement;\r\n    private butDelete: HTMLButtonElement;\r\n    private tbody: HTMLTableSectionElement;\r\n    private tfirstRow: HTMLTableRowElement;\r\n    private inputSetpointFan: HTMLInputElement;\r\n    private inputSetpointAirspeed: HTMLInputElement;\r\n    private inputServoCL: HTMLInputElement;\r\n    private inputServoOL: HTMLInputElement;\r\n    private inputKP: HTMLInputElement;\r\n    private inputKI: HTMLInputElement;\r\n    private inputKD: HTMLInputElement;\r\n    private timer: number | undefined;\r\n    private chart: Chart;\r\n    private counter = 10 ^ 6;\r\n    private mode: number = 0;\r\n    private seconds = 0;\r\n\r\n    private recording = false;\r\n\r\n    public onFirstStart(): void {\r\n        this.timer = window.setInterval(() => { this.sendAndReceive(); }, 1000);\r\n    }\r\n    public onRestart(): void {\r\n        this.timer = window.setInterval(() => { this.sendAndReceive(); }, 1000);\r\n    }\r\n    public onStop(): void {\r\n        window.clearInterval(this.timer);\r\n        this.butStop.hidden = true;\r\n        this.butRecord.hidden = false;\r\n        this.counter = 10 ^ 6;\r\n    }\r\n    public onCreate() {\r\n        this.resetData();\r\n\r\n    }\r\n\r\n    private resetData() {\r\n        this.chart.data!.labels = [];\r\n        this.chart.data!.datasets!.forEach((dataset) => {\r\n            dataset!.data = [];\r\n        });\r\n        this.chart.update();\r\n        this.tbody.innerText = \"\";\r\n        this.seconds = 0;\r\n    }\r\n\r\n\r\n    private onModeChange(newMode: number) {\r\n        switch (newMode) {\r\n            case 0:\r\n                document.querySelectorAll('.airspeedexperiment_closedloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"none\";\r\n                });\r\n                document.querySelectorAll('.airspeedexperiment_openloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"none\";\r\n                });\r\n                break;\r\n            case 1:\r\n                document.querySelectorAll('.airspeedexperiment_closedloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"none\";\r\n                });\r\n                document.querySelectorAll('.airspeedexperiment_openloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"inline-block\";\r\n                });\r\n                break;\r\n            case 2:\r\n                document.querySelectorAll('.airspeedexperiment_closedloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"inline-block\";\r\n                });\r\n                document.querySelectorAll('.airspeedexperiment_openloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"none\";\r\n                });\r\n                break;\r\n        }\r\n        this.mode = newMode;\r\n    }\r\n\r\n    private sendAndReceive() {\r\n        let buffer = new ArrayBuffer(256);\r\n        let ctx = new SerializeContext(buffer);\r\n        ctx.writeU32(this.mode);\r\n        if (this.mode == 0) {\r\n            ctx.writeF32(0);\r\n            ctx.writeF32(0);\r\n        } else if (this.mode == 1) {\r\n            ctx.writeF32(this.inputSetpointFan.valueAsNumber);\r\n            ctx.writeF32(this.inputServoOL.valueAsNumber);\r\n        }\r\n        else {\r\n            ctx.writeF32(this.inputSetpointAirspeed.valueAsNumber);\r\n            ctx.writeF32(this.inputServoCL.valueAsNumber);\r\n        }\r\n        ctx.writeF32(this.inputKP.valueAsNumber);\r\n        ctx.writeF32(this.inputKI.valueAsNumber);\r\n        ctx.writeF32(this.inputKD.valueAsNumber);\r\n\r\n        let xhr = new XMLHttpRequest;\r\n        xhr.onerror = (e) => { console.log(\"Fehler beim XMLHttpRequest!\"); };\r\n        xhr.open(\"PUT\", \"/airspeedexperiment\", true);\r\n        xhr.responseType = \"arraybuffer\";\r\n        xhr.onload = (e) => {\r\n            let SetpointAirspeed: number, Fan: number, Servo: number, ActualAirspeed: number;\r\n            let arrayBuffer = xhr.response; // Note: not oReq.responseText\r\n            if (!arrayBuffer || arrayBuffer.byteLength != 4 + 4 + 4 + 4) {\r\n                console.error(\"! arrayBuffer || arrayBuffer.byteLength!=4+4+4+4\");\r\n                SetpointAirspeed = 0;\r\n                Fan = 0;\r\n                Servo = 0;\r\n                ActualAirspeed = 20 + (-5 + 10 * Math.random());\r\n            }\r\n            else {\r\n                let ctx = new SerializeContext(arrayBuffer);\r\n                SetpointAirspeed = ctx.readF32();\r\n                Fan = ctx.readF32();\r\n                Servo = ctx.readF32();\r\n                ActualAirspeed = ctx.readF32();\r\n            }\r\n            let now = new Date(Date.now());\r\n\r\n            if (this.recording) {\r\n                let tr = $.HtmlAsFirstChild(this.tbody, \"tr\", []);\r\n                for (let i = 0; i < 6; i++) {\r\n                    $.Html(tr, \"td\", [], [], this.tfirstRow.children[i].textContent!);\r\n                }\r\n                if (this.counter >= CHART_EACH_INTERVAL) {\r\n                    if (this.chart.data!.labels!.length > 100) {\r\n                        this.chart.data!.labels?.shift();\r\n                        this.chart.data!.datasets!.forEach((dataset) => {\r\n                            dataset!.data!.shift();\r\n                        });\r\n                    }\r\n                    this.chart.data!.labels!.push(now.toLocaleTimeString(\"de-DE\"));\r\n                    this.chart.data?.datasets![0].data?.push(SetpointAirspeed);\r\n                    this.chart.data?.datasets![1].data?.push(ActualAirspeed);\r\n                    this.chart.data?.datasets![2].data?.push(Fan);\r\n                    this.chart.data?.datasets![3].data?.push(Servo);\r\n                    this.chart.update();\r\n                    this.counter = 0;\r\n                }\r\n                this.counter++;\r\n                this.seconds++;\r\n            }\r\n            this.tfirstRow.children[0].textContent = now.toLocaleTimeString(\"de-DE\");\r\n            this.tfirstRow.children[1].textContent = DE_de.format(this.seconds);\r\n            this.tfirstRow.children[2].textContent = DE_de.format(SetpointAirspeed);\r\n            this.tfirstRow.children[3].textContent = DE_de.format(ActualAirspeed);\r\n            this.tfirstRow.children[4].textContent = DE_de.format(Fan);\r\n            this.tfirstRow.children[5].textContent = DE_de.format(Servo);\r\n        };\r\n        xhr.send(ctx.getResult());\r\n    }\r\n\r\n    constructor(appManagement:AppManagement, div: HTMLDivElement) {\r\n        super(appManagement, div);\r\n        this.butRecord = <HTMLButtonElement>document.getElementById(\"airspeedexperiment_butRecord\")!;\r\n        this.butStop = <HTMLButtonElement>document.getElementById(\"airspeedexperiment_butStop\")!;\r\n        this.butStop.hidden = true;\r\n        this.butDelete = <HTMLButtonElement>document.getElementById(\"airspeedexperiment_butDelete\")!;\r\n        this.tbody = <HTMLTableSectionElement>document.getElementById(\"airspeedexperiment_tabBody\")!;\r\n        this.tfirstRow = <HTMLTableRowElement>document.getElementById(\"airspeedexperiment_tabFirstRow\")!;\r\n        this.inputSetpointFan = <HTMLInputElement>document.getElementById(\"airspeedexperiment_inpSetpointFan\");\r\n        this.inputServoOL = <HTMLInputElement>document.getElementById(\"airspeedexperiment_inpFanOL\")!;\r\n        this.inputSetpointAirspeed = <HTMLInputElement>document.getElementById(\"airspeedexperiment_inpSetpointAirspeed\");\r\n        this.inputServoCL = <HTMLInputElement>document.getElementById(\"airspeedexperiment_inpFanCL\")!;\r\n\r\n        this.inputKP = <HTMLInputElement>document.getElementById(\"airspeedexperiment_inpKP\")!;\r\n        this.inputKI = <HTMLInputElement>document.getElementById(\"airspeedexperiment_inpKI\")!;\r\n        this.inputKD = <HTMLInputElement>document.getElementById(\"airspeedexperiment_inpKD\")!;\r\n\r\n        this.onModeChange(0);\r\n\r\n        let ctx = <HTMLCanvasElement>document.getElementById('airspeedexperiment_chart')!;\r\n        this.chart = new Chart(ctx, {\r\n            type: 'line',\r\n            data: {\r\n                labels: [],\r\n                datasets: [\r\n                    {\r\n                        label: \"Setpoint Airspeed [m/s]\",\r\n                        data: [],\r\n                        backgroundColor: \"red\",\r\n                        borderColor: \"red\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Actual Airspeed [m/s]\",\r\n                        data: [],\r\n                        backgroundColor: \"green\",\r\n                        borderColor: \"green\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Fan Power [%]\",\r\n                        data: [],\r\n                        backgroundColor: \"blue\",\r\n                        borderColor: \"blue\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Servo Position [deg]\",\r\n                        data: [],\r\n                        backgroundColor: \"grey\",\r\n                        borderColor: \"grey\",\r\n                        fill: false,\r\n                    },\r\n                ]\r\n            },\r\n            options: {\r\n                responsive: true,\r\n                maintainAspectRatio: false,\r\n                hover: {\r\n                    mode: 'nearest',\r\n                    intersect: true\r\n                },\r\n                scales: {\r\n                    y: {\r\n                        beginAtZero: true\r\n                    } \r\n                }\r\n            }\r\n        });\r\n\r\n\r\n        document.querySelectorAll('input[name=\"airspeedexperiment_mode\"]').forEach((v, k) => {\r\n            let inp = <HTMLInputElement>v;\r\n            inp.onclick = (e) => {\r\n                let num = parseInt(inp.value);\r\n                if (this.mode != num)\r\n                    this.onModeChange(num);\r\n            };\r\n        });\r\n\r\n        let setBubble = (range: HTMLInputElement, bubble: HTMLOutputElement) => {\r\n            let val = range.valueAsNumber;\r\n            let min = range.min ? parseInt(range.min) : 0;\r\n            let max = range.max ? parseInt(range.max) : 100;\r\n            let newVal = ((val - min) * 100) / (max - min);\r\n            bubble.innerHTML = \"\" + val;\r\n\r\n            // Sorta magic numbers based on size of the native UI thumb\r\n            bubble.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;\r\n        };\r\n\r\n        document.querySelectorAll(\".range-wrap.airspeedexperiment\").forEach(wrap => {\r\n            let range = <HTMLInputElement>wrap.querySelector(\"input[type='range']\")!;\r\n            let bubble = <HTMLOutputElement>wrap.querySelector(\"output.bubble\")!;\r\n            range.oninput = (e) => setBubble(range, bubble);\r\n            setBubble(range, bubble);\r\n        });\r\n\r\n\r\n        this.butStop.onclick = (e) => {\r\n            this.butStop.hidden = true;\r\n            this.butRecord.hidden = false;\r\n            this.recording = false;\r\n        };\r\n\r\n        this.butRecord.onclick = (e) => {\r\n            this.butRecord.hidden = true;\r\n            this.butStop.hidden = false;\r\n            this.recording = true;\r\n        };\r\n\r\n        this.butDelete.onclick = (e) => {\r\n            this.resetData();\r\n        };\r\n    }\r\n}\r\n","import { HeaterExperimentController } from \"./HeaterExperimentController\";\r\nimport { ScreenController, ControllerState } from \"./ScreenController\";\r\nimport { DevelopCFCController } from \"./DevelopCFCController\";\r\nimport { DialogController } from \"./DialogController\";\r\nimport { AppManagement } from \"./AppManagement\";\r\nimport { ADCExperimentController } from \"./ADCExperimentController\";\r\nimport { AirspeedExperimentController } from \"./AirspeedExperimentController\";\r\nimport {FFTExperimentController} from \"./FFTExperimentController\";\r\n\r\nclass DashboardController extends ScreenController {\r\n    public onFirstStart(): void { }\r\n    public onRestart(): void { }\r\n    public onStop(): void { }\r\n    public onCreate() { }\r\n    constructor(appManagement:AppManagement, div: HTMLDivElement) {\r\n        super(appManagement, div);\r\n    }\r\n\r\n}\r\n\r\nclass ReportsController extends ScreenController {\r\n    public onFirstStart(): void { }\r\n    public onRestart(): void { }\r\n    public onStop(): void { }\r\n    constructor(appManagement:AppManagement, div: HTMLDivElement) {\r\n        super(appManagement, div);\r\n    }\r\n    public onCreate() {\r\n        return;\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\nclass AppController implements AppManagement {\r\n\r\n    private stateDiv: HTMLDivElement;\r\n    private activeControllerIndex: number;\r\n    private screenControllers: ScreenController[];\r\n    private dialogController:DialogController;\r\n\r\n    public DialogController() { return this.dialogController; };\r\n\r\n\r\n\r\n    constructor() {\r\n        this.stateDiv = <HTMLDivElement>document.getElementById(\"spnConnectionState\")!;\r\n        this.screenControllers = [];\r\n        this.activeControllerIndex = 0;\r\n        this.dialogController=new DialogController(this);\r\n    }\r\n\r\n    private SetApplicationState(state: string) {\r\n        this.stateDiv.innerHTML = state;\r\n\r\n    }\r\n\r\n    private setActiveScreen(newIndex: number) {\r\n        this.screenControllers.forEach((controller, i) => {\r\n            if (i == newIndex) {\r\n                controller.showDIV();\r\n                if (controller.State == ControllerState.CREATED) {\r\n                    controller.onFirstStart();\r\n                    controller.State = ControllerState.STARTED;\r\n                }\r\n                else {\r\n                    controller.onRestart();\r\n                    controller.State = ControllerState.STARTED;\r\n                }\r\n            } else {\r\n                controller.hideDIV();\r\n                if (controller.State == ControllerState.STARTED) {\r\n                    controller.onStop();\r\n                    controller.State = ControllerState.STOPPED;\r\n                }\r\n            }\r\n        });\r\n        this.activeControllerIndex = newIndex;\r\n    }\r\n\r\n    public startup() {\r\n        this.dialogController.init();\r\n        this.screenControllers.push(new DashboardController(this, <HTMLDivElement>document.getElementById(\"screen_dashboard\")));\r\n        this.screenControllers.push(new DevelopCFCController(this, <HTMLDivElement>document.getElementById(\"screen_develop\")));\r\n        this.screenControllers.push(new ReportsController(this, <HTMLDivElement>document.getElementById(\"screen_reports\")));\r\n        this.screenControllers.push(new HeaterExperimentController(this, <HTMLDivElement>document.getElementById(\"screen_heaterexperiment\")));\r\n        this.screenControllers.push(new AirspeedExperimentController(this, <HTMLDivElement>document.getElementById(\"screen_airspeedexperiment\")));\r\n        this.screenControllers.push(new ADCExperimentController(this, <HTMLDivElement>document.getElementById(\"screen_adcexperiment\")));\r\n        this.screenControllers.push(new FFTExperimentController(this, <HTMLDivElement>document.getElementById(\"screen_fftexperiment\")));\r\n        this.screenControllers.forEach((sc) => sc.onCreate());\r\n\r\n        this.setActiveScreen(1);\r\n        let id2index = new Map<string, number>();\r\n        this.screenControllers.forEach((value, index) => { id2index.set(\"show_\" + value.ElementId, index) })\r\n        document.querySelectorAll<HTMLAnchorElement>(\"nav a\").forEach((a: HTMLAnchorElement) => {\r\n            let id = a.id;\r\n            let index = id2index.get(a.id) || 0;\r\n            a.onclick = (e) => this.setActiveScreen(index);\r\n        });\r\n\r\n\r\n\r\n        /*\r\n        this.SetApplicationState(\"WebSocket is not connected\");\r\n        let websocket = new WebSocket('ws://' + location.hostname + '/w');\r\n        websocket.onopen = e => {\r\n            this.SetApplicationState('WebSocket connection opened');\r\n            document.getElementById(\"test\")!.innerHTML = \"WebSocket is connected!\";\r\n        }\r\n        websocket.onmessage = (evt) => {\r\n            var msg = evt.data;\r\n            let value: string;\r\n            switch (msg.charAt(0)) {\r\n                case 'L':\r\n                    console.log(msg);\r\n                    value = msg.replace(/[^0-9\\.]/g, '');\r\n                    switch (value) {\r\n                        case \"0\": document.getElementById(\"led1\")!.style.backgroundColor = \"black\"; break;\r\n                        case \"1\": document.getElementById(\"led1\")!.style.backgroundColor = \"green\"; break;\r\n                        case \"2\": document.getElementById(\"led2\")!.style.backgroundColor = \"black\"; break;\r\n                        case \"3\": document.getElementById(\"led2\")!.style.backgroundColor = \"green\"; break;\r\n                    }\r\n                    console.log(\"Led = \" + value);\r\n                    break;\r\n                default:\r\n                    let p = JSON.parse(evt.data);\r\n                    document.getElementById(\"td_myName\")!.innerText = p.d.myName;\r\n                    document.getElementById(\"td_temperature\")!.innerText = p.d.temperature;\r\n                    document.getElementById(\"td_humidity\")!.innerText = p.d.humidity;\r\n                    document.getElementById(\"td_heap\")!.innerText = p.info.heap;\r\n                    document.getElementById(\"td_time\")!.innerText = p.info.time;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        websocket.onclose = (e) => {\r\n            console.log('Websocket connection closed due to '+e.reason);\r\n            this.SetApplicationState('Websocket connection closed due to '+e.reason);\r\n        }\r\n\r\n        websocket.onerror = (evt) => {\r\n            console.log('Websocket error: ' + evt.returnValue);\r\n            this.SetApplicationState(\"WebSocket error!\" + evt.returnValue);\r\n        }\r\n\r\n        document.querySelectorAll<HTMLButtonElement>(\"#pButtons button\").forEach((b: HTMLButtonElement) => {\r\n            b.onclick = (e: MouseEvent) => {\r\n                websocket.send(\"L\" + b.dataset.rel);\r\n            };\r\n        });\r\n*/\r\n    }\r\n}\r\n\r\nlet app: AppController;\r\ndocument.addEventListener(\"DOMContentLoaded\", (e) => {\r\n    app = new AppController();\r\n    app.startup();\r\n});\r\n\r\n\r\n","import { AppManagement } from \"./AppManagement\";\r\nimport { Flowchart, FlowchartData, FlowchartOptions } from \"./flowchart/Flowchart\";\r\nimport { ScreenController } from \"./ScreenController\";\r\n\r\n\r\nexport class DevelopCFCController extends ScreenController {\r\n    private fc: Flowchart;\r\n    private timer: number | undefined;\r\n    onFirstStart(): void {\r\n        this.timer = window.setInterval(() => { this.fc.triggerDebug(); }, 1000);\r\n        this.fc.onFirstStart();\r\n    }\r\n    public onRestart(): void {\r\n        this.timer = window.setInterval(() => { this.fc.triggerDebug(); }, 1000);\r\n    }\r\n    public onStop(): void {\r\n        window.clearInterval(this.timer);\r\n    }\r\n    public onCreate() { }\r\n    constructor(appManagement:AppManagement, div: HTMLDivElement) {\r\n        super(appManagement, div);\r\n        let data: FlowchartData = {\r\n            operators: [\r\n                {\r\n                    index: 0,\r\n                    caption: \"RedButton\",\r\n                    globalTypeIndex: 30,\r\n                    posX: 10,\r\n                    posY: 10,\r\n                    configurationData: null,\r\n                },\r\n                {\r\n                    index: 1,\r\n                    caption: \"GreenButton\",\r\n                    globalTypeIndex: 33,\r\n                    posX: 10,\r\n                    posY: 150,\r\n                    configurationData: null,\r\n                },\r\n                {\r\n                    index: 2,\r\n                    caption: \"AND\",\r\n                    globalTypeIndex: 1,\r\n                    posX: 250,\r\n                    posY: 10,\r\n                    configurationData: null,\r\n                },\r\n                {\r\n                    index: 3,\r\n                    caption: \"RedLed\",\r\n                    globalTypeIndex: 46,\r\n                    posX: 500,\r\n                    posY: 10,\r\n                    configurationData: null,\r\n                },\r\n            ],\r\n            links: [\r\n                {\r\n                    color: \"black\",\r\n                    fromOperatorIndex: 0,\r\n                    fromOutput: 0,\r\n                    toOperatorIndex: 2,\r\n                    toInput: 0\r\n                },\r\n                {\r\n                    color: \"black\",\r\n                    fromOperatorIndex: 1,\r\n                    fromOutput: 0,\r\n                    toOperatorIndex: 2,\r\n                    toInput: 1\r\n                },\r\n                {\r\n                    color: \"black\",\r\n                    fromOperatorIndex: 2,\r\n                    fromOutput: 0,\r\n                    toOperatorIndex: 3,\r\n                    toInput: 0\r\n                },\r\n            ]\r\n        };\r\n        let options = new FlowchartOptions();\r\n        options.data = data;\r\n        this.fc = new Flowchart(this.appManagement, this.div, options);\r\n    }\r\n\r\n\r\n}\r\n","import { AppManagement } from \"./AppManagement\";\r\nimport {$} from \"./utils\"\r\nexport class DialogController {\r\n    \r\n\r\n    private dialog = <HTMLDialogElement>document.getElementById('dialog')!;\r\n    private dialogHeading = <HTMLHeadingElement>document.getElementById('dialog-heading')!;\r\n    private dialogBody = <HTMLDivElement>document.getElementById('dialog-body')!;\r\n    private dialogFooter = <HTMLElement>document.getElementById('dialog-footer')!;\r\n\r\n    constructor(private appManagement:AppManagement) {\r\n        \r\n    }\r\n    \r\n    public init() {\r\n\r\n        document.getElementById('dialog-close')!.onclick = (e) => {\r\n            //this.dialog.close(\"cancelled\");\r\n        }\r\n        //this.dialog.oncancel = (e) => {\r\n            //this.dialog.close(\"cancelled\");\r\n        //}\r\n\r\n        // close when clicking on backdrop\r\n        this.dialog.onclick = (event) => {\r\n            if (event.target === this.dialog) {\r\n                //this.dialog.close('cancelled');\r\n            }\r\n        }\r\n    }\r\n\r\n    public showEnterFilenameDialog(priority: number, messageText: string, handler: (filename: string) => void) {\r\n        this.prepareDialog();\r\n        this.dialogHeading.innerText=\"Enter Filename\";\r\n        $.Html(this.dialogBody, \"p\", [], [], messageText);\r\n        let fileInput= <HTMLInputElement>$.Html(this.dialogBody, \"input\", [\"pattern\", \"^[A-Za-z0-9]{1,10}$\"], []);\r\n        this.dialogFooter.innerText=\"\";\r\n        $.Html(this.dialogFooter, \"button\", [], [], \"OK\").onclick=(e)=>{\r\n            //this.dialog.close('OK');\r\n            if(handler!=null) handler(fileInput.value);\r\n        };\r\n       // this.dialog.showModal();\r\n    }\r\n\r\n    public showOKDialog(priority: number, messageText:string, handler: ((a:string)=>any)|null) {\r\n        this.prepareDialog();\r\n        this.dialogHeading.innerText=\"Message\";\r\n        this.dialogBody.innerText=messageText;\r\n        this.dialogFooter.innerText=\"\";\r\n        $.Html(this.dialogFooter, \"button\", [\"type\", \"button\"], [], \"OK\").onclick=(e)=>{\r\n            //this.dialog.close('cancelled');\r\n            if(handler!=null) handler(\"OK\");\r\n        };\r\n        //this.dialog.showModal();\r\n    }\r\n\r\n    private prepareDialog()\r\n    {\r\n        this.dialogHeading.innerText=\"\";\r\n        this.dialogBody.innerText=\"\";\r\n        this.dialogFooter.innerText=\"\";\r\n    }\r\n\r\n    public showFilelist(priority: number, files:string[], openhandler: (filename:string)=>any, deletehandler: (filename:string)=>any) {\r\n\r\n        this.prepareDialog();\r\n        this.dialogHeading.innerText=\"Please select a file to load\"\r\n        $.Html(this.dialogFooter, \"button\", [\"type\", \"button\"], [], \"Cancel\").onclick=(e)=>{\r\n            //this.dialog.close(\"cancelled\");\r\n        };\r\n        let table = <HTMLTableElement>$.Html(this.dialogBody, \"table\", [], []);\r\n        let thead = <HTMLTableSectionElement>$.Html(table, \"thead\", [],[]);\r\n        let tr_head = $.Html(thead, \"tr\", [], []);\r\n        $.Html(tr_head, \"th\", [], [], \"File Name\");\r\n        $.Html(tr_head, \"th\", [], [], \"File Operation\");\r\n        let tbody= <HTMLTableSectionElement>$.Html(table, \"tbody\", [],[]);\r\n        for(let filename of files){\r\n            if(!filename.endsWith(\".json\")) continue;\r\n            filename=filename.substring(0, filename.length-5);\r\n            let tr = $.Html(tbody, \"tr\", [], []);\r\n            $.Html(tr, \"td\", [], [], filename);\r\n            let operationTd= $.Html(tr, \"td\", [], []);\r\n            let openButton = $.Html(operationTd, \"button\", [\"type\", \"button\"], []);\r\n            $.SvgIcon(openButton, \"folder-open\");\r\n            openButton.onclick=(e)=>{\r\n                //this.dialog.close(\"opened\");\r\n                openhandler(filename);\r\n                \r\n            };\r\n            let deleteButton=$.Html(operationTd, \"button\", [\"type\", \"button\"], [], );\r\n            $.SvgIcon(deleteButton, \"bin2\");\r\n            deleteButton.onclick=(e)=>{\r\n                //this.dialog.close(\"deleted\");\r\n                deletehandler(filename);\r\n            }\r\n        };\r\n        //this.dialog.showModal();\r\n        \r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n}","import { $ } from \"./utils\";\r\nimport { Chart, ChartDataset} from 'chart.js';\r\nimport { ScreenController } from \"./ScreenController\";\r\nimport { AppManagement } from \"./AppManagement\";\r\nimport { SerializeContext } from \"./flowchart/SerializeContext\";\r\n//!!!Applied some adoptions on lower numbers to avoid strange rounding effects\r\nconst  FREQUENCIES:number[]=[11,21,31,42,53,64,75,97,118,139,161,183,205,227,258,291,323,355,388,431,474,517,560,614,668,721,786,851,915,991,1066,1152,1238,1335,1443,1550,1669,1798,1938,2089,2239,2401,2584,2778,2982,3198,3435,3682,3951,4231,4533,4856,5200,5566,5965,6385,6837,7321,7838,8398,8990,9625,10304,11025];\r\nconst INTERVAL=2000;\r\nconst ZEROS = Array.from(Array(64).keys());\r\n\r\nexport class FFTExperimentController extends ScreenController {\r\n    private butRecord: HTMLButtonElement;\r\n    private butStop: HTMLButtonElement;\r\n    private butSave: HTMLButtonElement;\r\n    private butDelete: HTMLButtonElement;\r\n    private inputFan: HTMLInputElement;\r\n    private tbody: HTMLTableSectionElement;\r\n    private timer: number | undefined;\r\n    private chart: Chart;\r\n    private COLORS = [\r\n        '#4dc9f6',\r\n        '#f67019',\r\n        '#f53794',\r\n        '#537bc4',\r\n        '#acc236',\r\n        '#166a8f',\r\n        '#00a950',\r\n        '#58595b',\r\n        '#8549ba'\r\n      ];\r\n\r\n    private recording = false;\r\n   \r\n\r\n    public onFirstStart(): void {\r\n        this.timer = window.setInterval(() => { this.sendAndReceive(); }, INTERVAL);\r\n    }\r\n    public onRestart(): void {\r\n        this.timer = window.setInterval(() => { this.sendAndReceive(); }, INTERVAL);\r\n    }\r\n    public onStop(): void {\r\n        window.clearInterval(this.timer);\r\n        this.butStop.hidden = true;\r\n        this.butRecord.hidden = false;\r\n    }\r\n    public onCreate() {\r\n        //this.resetData();\r\n    }\r\n\r\n    private resetData() {\r\n        this.chart.data!.labels = [];\r\n        this.chart.data!.datasets!.forEach((dataset) => {\r\n            dataset!.data = [];\r\n        });\r\n        this.chart.update();\r\n        this.tbody.innerText = \"\";\r\n    }\r\n\r\n    private color(index:number) {\r\n        return this.COLORS[index % this.COLORS.length];\r\n    }\r\n      \r\n\r\n    private sendAndReceive() {\r\n        let buffer = new ArrayBuffer(256);\r\n        let ctx = new SerializeContext(buffer);\r\n        ctx.writeF32(this.inputFan.valueAsNumber);\r\n        ctx.writeF32(0);\r\n        ctx.writeF32(0);\r\n        ctx.writeF32(0);\r\n        ctx.writeF32(0);\r\n        ctx.writeF32(0);\r\n        ctx.writeF32(0);\r\n        ctx.writeF32(0);\r\n\r\n        let xhr = new XMLHttpRequest;\r\n        xhr.onerror = (e) => { console.log(\"Fehler beim XMLHttpRequest!\"); };\r\n        xhr.open(\"PUT\", \"/fftexperiment\", true);\r\n        xhr.responseType = \"arraybuffer\";\r\n        \r\n        xhr.onload = (e) => {\r\n            let data:number[] = [];\r\n            let arrayBuffer = xhr.response; // Note: not oReq.responseText\r\n            if (!arrayBuffer || arrayBuffer.byteLength != 256) {\r\n                console.error(\"!arrayBuffer || arrayBuffer.byteLength != 256 -->providing fake data\");\r\n                for(let i =0;i<64;i++){\r\n                    data.push(5 + 5 * Math.random());\r\n                }\r\n\r\n            }\r\n            else {\r\n                let ctx = new SerializeContext(arrayBuffer);\r\n                for(let i =0;i<64;i++){\r\n                    data.push(Math.log10(ctx.readF32()));\r\n                }\r\n            }\r\n            if (this.recording) {\r\n                this.chart.data.datasets[0].data=data;\r\n                this.chart.update();\r\n            }\r\n        };\r\n        xhr.send(ctx.getResult());\r\n    }\r\n\r\n\r\n    constructor(appManagement:AppManagement, div: HTMLDivElement) {\r\n        super(appManagement, div);\r\n        this.butRecord = <HTMLButtonElement>document.getElementById(\"fftexperiment_butRecord\")!;\r\n        this.butStop = <HTMLButtonElement>document.getElementById(\"fftexperiment_butStop\")!;\r\n        this.butSave = <HTMLButtonElement>document.getElementById(\"fftexperiment_butSave\")!;\r\n        this.butDelete = <HTMLButtonElement>document.getElementById(\"fftexperiment_butDelete\")!;\r\n        this.inputFan = <HTMLInputElement>document.getElementById(\"fftexperiment_inpFan\")!;\r\n        this.butStop.hidden = true;\r\n        this.tbody = <HTMLTableSectionElement>document.getElementById(\"adcexperiment_tabBody\")!;\r\n       \r\n\r\n        let ctx = <HTMLCanvasElement>document.getElementById('fftexperiment_chart')!;\r\n        this.chart = new Chart(ctx, {\r\n            type: 'line',\r\n            data: {\r\n                labels: FREQUENCIES,\r\n                datasets: []\r\n            },\r\n            options: {\r\n                responsive: true,\r\n                maintainAspectRatio: false,\r\n                hover: {\r\n                    mode: 'nearest',\r\n                    intersect: true\r\n                },\r\n                scales: {\r\n                    y: {\r\n                        beginAtZero: true,\r\n                        max:10\r\n                    } \r\n                }\r\n            }\r\n        });\r\n        this.chart.update();\r\n        let setBubble = (range: HTMLInputElement, bubble: HTMLOutputElement) => {\r\n            let val = range.valueAsNumber;\r\n            let min = range.min ? parseInt(range.min) : 0;\r\n            let max = range.max ? parseInt(range.max) : 100;\r\n            let newVal = ((val - min) * 100) / (max - min);\r\n            bubble.innerHTML = \"\" + val;\r\n\r\n            // Sorta magic numbers based on size of the native UI thumb\r\n            bubble.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;\r\n        };\r\n\r\n        document.querySelectorAll(\".range-wrap.fftexperiment\").forEach(wrap => {\r\n            let range = <HTMLInputElement>wrap.querySelector(\"input[type='range']\")!;\r\n            let bubble = <HTMLOutputElement>wrap.querySelector(\"output.bubble\")!;\r\n            range.oninput = (e) => setBubble(range, bubble);\r\n            setBubble(range, bubble);\r\n        });\r\n\r\n        this.butStop.onclick = () => {\r\n            this.butStop.hidden = true;\r\n            this.butRecord.hidden = false;\r\n            this.recording = false;\r\n            this.chart.data.datasets.shift();\r\n            this.chart.update();\r\n        };\r\n\r\n        this.butRecord.onclick = () => {\r\n            this.butRecord.hidden = true;\r\n            this.butStop.hidden = false;\r\n            this.chart.data.datasets.unshift({\r\n                label: \"Magnitudes\",\r\n                data: ZEROS,\r\n                borderColor: this.color(0),\r\n                backgroundColor: this.color(0),\r\n            });\r\n            this.recording = true;\r\n            this.chart.update();\r\n        };\r\n        this.butSave.onclick = ()=>{\r\n            let now = new Date(Date.now());\r\n            let newDataset:ChartDataset={\r\n                label: \"Magnitudes saved \"+now.toLocaleTimeString(\"de-DE\"),\r\n                data: this.chart.data.datasets[0].data,\r\n                borderColor: this.color(this.chart.data.datasets.length),\r\n                backgroundColor: this.color(this.chart.data.datasets.length),\r\n            };\r\n            this.chart.data.datasets.splice(1,0,newDataset);\r\n            this.chart.update();\r\n        }\r\n        this.butDelete.onclick=()=>{\r\n            if(this.chart.data.datasets.length<2) return;\r\n            this.chart.data.datasets.pop();\r\n            this.chart.update();\r\n        }\r\n    }\r\n}\r\n","import { $ } from \"./utils\";\r\nimport { Chart} from 'chart.js';\r\nimport { ScreenController } from \"./ScreenController\";\r\nimport { AppManagement } from \"./AppManagement\";\r\nimport { SerializeContext } from \"./flowchart/SerializeContext\";\r\n\r\nexport let DE_de = new Intl.NumberFormat('de-DE');\r\nexport const CHART_EACH_INTERVAL = 2;\r\n\r\nexport class HeaterExperimentController extends ScreenController {\r\n    private butRecord: HTMLButtonElement;\r\n    private butStop: HTMLButtonElement;\r\n    private butDelete: HTMLButtonElement;\r\n    private tbody: HTMLTableSectionElement;\r\n    private tfirstRow: HTMLTableRowElement;\r\n    private inputSetpointHeater: HTMLInputElement;\r\n    private inputSetpointTemperature: HTMLInputElement;\r\n    private inputFanCL: HTMLInputElement;\r\n    private inputFanOL: HTMLInputElement;\r\n    private inputKP: HTMLInputElement;\r\n    private inputTN: HTMLInputElement;\r\n    private inputTV: HTMLInputElement;\r\n    private timer: number | undefined;\r\n    private chart: Chart;\r\n\r\n    private counter = 10 ^ 6;\r\n    private mode: number = 0;\r\n    private seconds = 0;\r\n\r\n    private recording = false;\r\n\r\n    public onFirstStart(): void {\r\n        this.timer = window.setInterval(() => { this.sendAndReceive(); }, 1000);\r\n    }\r\n    public onRestart(): void {\r\n        this.timer = window.setInterval(() => { this.sendAndReceive(); }, 1000);\r\n    }\r\n    public onStop(): void {\r\n        window.clearInterval(this.timer);\r\n        this.butStop.hidden = true;\r\n        this.butRecord.hidden = false;\r\n        this.counter = 10 ^ 6;\r\n    }\r\n    public onCreate() {\r\n        this.resetData();\r\n\r\n    }\r\n\r\n    private resetData() {\r\n        this.chart.data!.labels = [];\r\n        this.chart.data!.datasets!.forEach((dataset) => {\r\n            dataset!.data = [];\r\n        });\r\n        this.chart.update();\r\n        this.tbody.innerText = \"\";\r\n        this.seconds = 0;\r\n    }\r\n\r\n\r\n    private onModeChange(newMode: number) {\r\n        switch (newMode) {\r\n            case 0:\r\n                document.querySelectorAll('.heaterexperiment_closedloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"none\";\r\n                });\r\n                document.querySelectorAll('.heaterexperiment_openloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"none\";\r\n                });\r\n                break;\r\n            case 1:\r\n                document.querySelectorAll('.heaterexperiment_closedloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"none\";\r\n                });\r\n                document.querySelectorAll('.heaterexperiment_openloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"inline-block\";\r\n                });\r\n                break;\r\n            case 2:\r\n                document.querySelectorAll('.heaterexperiment_closedloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"inline-block\";\r\n                });\r\n                document.querySelectorAll('.heaterexperiment_openloopctrl').forEach((v, k) => {\r\n                    (<HTMLElement>v).style.display = \"none\";\r\n                });\r\n                break;\r\n        }\r\n        this.mode = newMode;\r\n    }\r\n\r\n    private sendAndReceive() {\r\n        let buffer = new ArrayBuffer(256);\r\n        let ctx = new SerializeContext(buffer);\r\n        ctx.writeU32(this.mode);\r\n        if (this.mode == 0) {\r\n            ctx.writeF32(0);\r\n            ctx.writeF32(0);\r\n        } else if (this.mode == 1) {\r\n            ctx.writeF32(this.inputSetpointHeater.valueAsNumber);\r\n            ctx.writeF32(this.inputFanOL.valueAsNumber);\r\n        }\r\n        else {\r\n            ctx.writeF32(this.inputSetpointTemperature.valueAsNumber);\r\n            ctx.writeF32(this.inputFanCL.valueAsNumber);\r\n        }\r\n        ctx.writeF32(this.inputKP.valueAsNumber);\r\n        ctx.writeF32(this.inputTN.valueAsNumber);\r\n        ctx.writeF32(this.inputTV.valueAsNumber);\r\n\r\n        let xhr = new XMLHttpRequest;\r\n        xhr.onerror = (e) => { console.log(\"Fehler beim XMLHttpRequest!\"); };\r\n        xhr.open(\"PUT\", \"/heaterexperiment\", true);\r\n        xhr.responseType = \"arraybuffer\";\r\n        xhr.onload = (e) => {\r\n            let SetpointTemperature: number, Heater: number, Fan: number, ActualTemperature: number;\r\n            let arrayBuffer = xhr.response; // Note: not oReq.responseText\r\n            if (!arrayBuffer || arrayBuffer.byteLength != 4 + 4 + 4 + 4) {\r\n                console.error(\"! arrayBuffer || arrayBuffer.byteLength!=4+4+4+4\");\r\n                SetpointTemperature = 0;\r\n                Heater = 0;\r\n                Fan = 0;\r\n                ActualTemperature = 20 + (-5 + 10 * Math.random());\r\n            }\r\n            else {\r\n                let ctx = new SerializeContext(arrayBuffer);\r\n                SetpointTemperature = ctx.readF32();\r\n                Heater = ctx.readF32();\r\n                Fan = ctx.readF32();\r\n                ActualTemperature = ctx.readF32();\r\n            }\r\n            let now = new Date(Date.now());\r\n\r\n            if (this.recording) {\r\n                let tr = $.HtmlAsFirstChild(this.tbody, \"tr\", []);\r\n                for (let i = 0; i < 6; i++) {\r\n                    $.Html(tr, \"td\", [], [], this.tfirstRow.children[i].textContent!);\r\n                }\r\n                if (this.counter >= CHART_EACH_INTERVAL) {\r\n                    if (this.chart.data!.labels!.length > 100) {\r\n                        this.chart.data!.labels?.shift();\r\n                        this.chart.data!.datasets!.forEach((dataset) => {\r\n                            dataset!.data!.shift();\r\n                        });\r\n                    }\r\n                    this.chart.data!.labels!.push(now.toLocaleTimeString(\"de-DE\"));\r\n                    this.chart.data?.datasets![0].data?.push(SetpointTemperature);\r\n                    this.chart.data?.datasets![1].data?.push(ActualTemperature);\r\n                    this.chart.data?.datasets![2].data?.push(Heater);\r\n                    this.chart.data?.datasets![3].data?.push(Fan);\r\n                    //this.setpointTemperatureValues.push(SetpointTemperature)\r\n                    //this.heaterValues.push(Heater);\r\n                    //this.fanValues.push(Fan);\r\n                    //this.actualTemperatureValues.push(ActualTemperature);\r\n                    this.chart.update();\r\n                    //FIXME this.chartData = {labels:this.dateValues, series: [this.setpointTemperatureValues, this.actualTemperatureValues, this.heaterValues, this.fanValues,],};\r\n                    //FIXME this.chart.update(this.chartData);\r\n                    this.counter = 0;\r\n                }\r\n                this.counter++;\r\n                this.seconds++;\r\n            }\r\n\r\n\r\n            this.tfirstRow.children[0].textContent = now.toLocaleTimeString(\"de-DE\");\r\n            this.tfirstRow.children[1].textContent = DE_de.format(this.seconds);\r\n            this.tfirstRow.children[2].textContent = DE_de.format(SetpointTemperature);\r\n            this.tfirstRow.children[3].textContent = DE_de.format(ActualTemperature);\r\n            this.tfirstRow.children[4].textContent = DE_de.format(Heater);\r\n            this.tfirstRow.children[5].textContent = DE_de.format(Fan);\r\n\r\n\r\n\r\n        };\r\n        xhr.send(ctx.getResult());\r\n    }\r\n\r\n    constructor(appManagement:AppManagement, div: HTMLDivElement) {\r\n        super(appManagement, div);\r\n        this.butRecord = <HTMLButtonElement>document.getElementById(\"heaterexperiment_butRecord\")!;\r\n        this.butStop = <HTMLButtonElement>document.getElementById(\"heaterexperiment_butStop\")!;\r\n        this.butStop.hidden = true;\r\n        this.butDelete = <HTMLButtonElement>document.getElementById(\"heaterexperiment_butDelete\")!;\r\n        this.tbody = <HTMLTableSectionElement>document.getElementById(\"heaterexperiment_tabBody\")!;\r\n        this.tfirstRow = <HTMLTableRowElement>document.getElementById(\"heaterexperiment_tabFirstRow\")!;\r\n        this.inputSetpointHeater = <HTMLInputElement>document.getElementById(\"heaterexperiment_inpSetpointHeater\");\r\n        this.inputFanOL = <HTMLInputElement>document.getElementById(\"heaterexperiment_inpFanOL\")!;\r\n        this.inputSetpointTemperature = <HTMLInputElement>document.getElementById(\"heaterexperiment_inpSetpointTemperature\");\r\n        this.inputFanCL = <HTMLInputElement>document.getElementById(\"heaterexperiment_inpFanCL\")!;\r\n\r\n        this.inputKP = <HTMLInputElement>document.getElementById(\"heaterexperiment_inpKP\")!;\r\n        this.inputTN = <HTMLInputElement>document.getElementById(\"heaterexperiment_inpTN\")!;\r\n        this.inputTV = <HTMLInputElement>document.getElementById(\"heaterexperiment_inpTV\")!;\r\n\r\n        this.onModeChange(0);\r\n\r\n        let ctx = <HTMLCanvasElement>document.getElementById('heaterexperiment_chart')!;\r\n        this.chart = new Chart(ctx, {\r\n            type: 'line',\r\n            data: {\r\n                labels: [],\r\n                datasets: [\r\n                    {\r\n                        label: \"Setpoint Temperature [°C]\",\r\n                        data: [],\r\n                        backgroundColor: \"red\",\r\n                        borderColor: \"red\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Actual Temperature [°C]\",\r\n                        data: [],\r\n                        backgroundColor: \"green\",\r\n                        borderColor: \"green\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Heater Power [%]\",\r\n                        data: [],\r\n                        backgroundColor: \"blue\",\r\n                        borderColor: \"blue\",\r\n                        fill: false,\r\n                    },\r\n                    {\r\n                        label: \"Fan Power [%]\",\r\n                        data: [],\r\n                        backgroundColor: \"grey\",\r\n                        borderColor: \"grey\",\r\n                        fill: false,\r\n                    },\r\n                ]\r\n            },\r\n            options: {\r\n                responsive: true,\r\n                maintainAspectRatio: false,\r\n                hover: {\r\n                    mode: 'nearest',\r\n                    intersect: true\r\n                },\r\n                scales: {\r\n                    y: {\r\n                        beginAtZero: true\r\n                    } \r\n                }\r\n            }\r\n        });\r\n\r\n\r\n        document.querySelectorAll('input[name=\"heaterexperiment_mode\"]').forEach((v, k) => {\r\n            let inp = <HTMLInputElement>v;\r\n            inp.onclick = (e) => {\r\n                let num = parseInt(inp.value);\r\n                if (this.mode != num)\r\n                    this.onModeChange(num);\r\n            };\r\n        });\r\n\r\n        let setBubble = (range: HTMLInputElement, bubble: HTMLOutputElement) => {\r\n            let val = range.valueAsNumber;\r\n            let min = range.min ? parseInt(range.min) : 0;\r\n            let max = range.max ? parseInt(range.max) : 100;\r\n            let newVal = ((val - min) * 100) / (max - min);\r\n            bubble.innerHTML = \"\" + val;\r\n\r\n            // Sorta magic numbers based on size of the native UI thumb\r\n            bubble.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;\r\n        };\r\n\r\n        document.querySelectorAll(\".range-wrap.heaterexperiment\").forEach(wrap => {\r\n            let range = <HTMLInputElement>wrap.querySelector(\"input[type='range']\")!;\r\n            let bubble = <HTMLOutputElement>wrap.querySelector(\"output.bubble\")!;\r\n            range.oninput = (e) => setBubble(range, bubble);\r\n            setBubble(range, bubble);\r\n        });\r\n\r\n\r\n        this.butStop.onclick = (e) => {\r\n            this.butStop.hidden = true;\r\n            this.butRecord.hidden = false;\r\n            this.recording = false;\r\n        };\r\n\r\n        this.butRecord.onclick = (e) => {\r\n            this.butRecord.hidden = true;\r\n            this.butStop.hidden = false;\r\n            this.recording = true;\r\n        };\r\n\r\n        this.butDelete.onclick = (e) => {\r\n            this.resetData();\r\n        };\r\n    }\r\n}\r\n","import { AppManagement } from \"./AppManagement\";\r\n\r\nexport enum ControllerState {\r\n    CREATED,\r\n    STARTED,\r\n    STOPPED,\r\n}\r\n\r\nexport abstract class ScreenController {\r\n    private state: ControllerState;\r\n    constructor(protected appManagement:AppManagement, protected div: HTMLDivElement) {\r\n        this.hideDIV();\r\n        this.state = ControllerState.CREATED;\r\n    }\r\n    get ElementId() { return this.div.id; }\r\n    get State() { return this.state; }\r\n    set State(value: ControllerState) { this.state = value; }\r\n    abstract onCreate(): void;\r\n    abstract onFirstStart(): void;\r\n    abstract onRestart(): void;\r\n    abstract onStop(): void;\r\n    public showDIV() {\r\n        this.div.style.display = \"block\";\r\n    }\r\n    public hideDIV() {\r\n        this.div.style.display = \"none\";\r\n    }\r\n}\r\n","import { ConnectorType, FlowchartInputConnector, FlowchartOutputConnector } from \"./FlowchartConnector\";\r\nimport { FlowchartCompiler, HashAndBufAndMaps, SortedOperatorsAndMaps } from \"./FlowchartCompiler\";\r\nimport { FlowchartLink } from \"./FlowchartLink\";\r\nimport { FlowchartOperator, PositionType, TypeInfo } from \"./FlowchartOperator\";\r\nimport * as operatorimpl from \"./FlowchartOperatorImpl\";\r\nimport { NodeWrapper, TopologicalSortDFS } from \"./TopologicalSorfDFS\";\r\nimport { Utils, $, KeyValueTuple } from \"../utils\";\r\nimport { AppManagement } from \"../AppManagement\";\r\nimport { SerializeContext } from \"./SerializeContext\";\r\nimport { SimulationManager } from \"./SimulationManager\";\r\n\r\nexport class FlowchartOptions {\r\n    canUserEditLinks: boolean = true;\r\n    canUserMoveOperators: boolean = true;\r\n    data?: FlowchartData = undefined;\r\n    distanceFromArrow: number = 3;\r\n    defaultOperatorClass: string = 'flowchart-default-operator';\r\n    defaultLinkColor: string = '#3366ff';\r\n    defaultSelectedLinkColor: string = 'black';\r\n    linkWidth: number = 10;\r\n    grid: number = 10;\r\n    multipleLinksOnOutput: boolean = true;\r\n    multipleLinksOnInput: boolean = false;\r\n    linkVerticalDecal: number = 0;\r\n    onOperatorSelect?: (operatorId: string) => boolean;\r\n    onOperatorUnselect?: () => boolean;\r\n    onOperatorMouseOver?: (operatorId: string) => boolean;\r\n    onOperatorMouseOut?: (operatorId: string) => boolean;\r\n    onLinkSelect?: (link: FlowchartLink) => boolean;\r\n    onLinkUnselect?: (link: FlowchartLink) => boolean;\r\n    onOperatorCreate?: (operatorId: string, operatorData: any, fullElement: boolean) => boolean;\r\n    onLinkCreate?: (linkId: string, linkData: any) => boolean;\r\n    onOperatorDelete?: (operatorId: string) => boolean;\r\n    onLinkDelete?: (linkId: string, forced: boolean) => boolean;\r\n    onOperatorMoved?: (operatorId: string, position: number) => void;\r\n    onAfterChange?: (changeType: any) => void;\r\n}\r\n\r\nexport interface FlowchartData {\r\n    operators: OperatorData[];\r\n    links: LinkData[];\r\n}\r\n\r\nexport interface OperatorData {\r\n    globalTypeIndex: number;\r\n    caption: string;\r\n    index: number;\r\n    posX: number;\r\n    posY: number;\r\n    configurationData: KeyValueTuple[] | null;\r\n}\r\n\r\n\r\n\r\nexport interface LinkData {\r\n    color: string;\r\n    fromOperatorIndex: number;\r\n    fromOutput: number;\r\n    toOperatorIndex: number;\r\n    toInput: number;\r\n}\r\n\r\nexport class Flowchart {\r\n    \r\n    private operatorRegistry:operatorimpl.OperatorRegistry;\r\n    private simulationManager?:SimulationManager|null;\r\n    private operators = new Map<number, FlowchartOperator>();\r\n    private links = new Map<number, FlowchartLink>();\r\n    public static readonly DATATYPE2COLOR = new Map([[ConnectorType.BOOLEAN, \"RED\"], [ConnectorType.COLOR, \"GREEN\"], [ConnectorType.FLOAT, \"BLUE\"], [ConnectorType.INTEGER, \"YELLOW\"], [ConnectorType.COLOR, \"PURPLE\"]]);\r\n    //Muss beim Löschen+Erzeugen von Operatoren+Links und bei Speichern von Properties zurückgesetzt werden\r\n    private currentDebugInfo:HashAndBufAndMaps|null=null;\r\n    private lastOutputConnectorClicked: FlowchartOutputConnector | null = null;\r\n    private selectedOperator: FlowchartOperator | null = null;\r\n    private selectedLink: FlowchartLink | null = null;\r\n    get SelectedLink() { return this.selectedLink };\r\n    get Options() { return this.options; }\r\n    \r\n    private positionRatio: number = 1;\r\n    get PositionRatio() { return this.positionRatio; }\r\n\r\n    private flowchartContainerSvgSvg: SVGSVGElement;\r\n    get Element() { return this.flowchartContainerSvgSvg; }\r\n    private linksLayer: SVGGElement;\r\n    get LinkLayer() { return this.linksLayer; }\r\n    private operatorsLayer: SVGGElement;\r\n    get OperatorsLayer() { return this.operatorsLayer; }\r\n    private operatorLibDiv: HTMLDivElement;\r\n    get ToolsLayer() { return this.operatorLibDiv; }\r\n    private tempLayer: SVGGElement;\r\n    private temporaryLink: SVGLineElement;\r\n    private temporaryLinkSnapped = false;\r\n    private propertyGridHtmlDiv: HTMLDivElement;\r\n\r\n    private markerArrow: SVGPathElement;\r\n    private markerCircle: SVGCircleElement;\r\n\r\n    public triggerDebug() {\r\n        if(this.currentDebugInfo==null) return;\r\n\r\n        let xhr = new XMLHttpRequest;\r\n        xhr.onerror = (e) => { console.log(\"Fehler beim XMLHttpRequest!\"); };\r\n        xhr.open(\"GET\", \"/fbd\", true);\r\n        xhr.responseType = \"arraybuffer\";\r\n        xhr.onload = (e) => {\r\n            if(this.currentDebugInfo==null) return;\r\n            \r\n            let arrayBuffer = xhr.response; // Note: not oReq.responseText\r\n            if (!arrayBuffer || arrayBuffer.byteLength <=16) {\r\n                console.info(\"! arrayBuffer || arrayBuffer.byteLength<16\");\r\n                this.currentDebugInfo=null;\r\n                return;\r\n            }\r\n            let ctx = new SerializeContext(arrayBuffer);\r\n            let hash = ctx.readU32();\r\n            if(hash!=this.currentDebugInfo.hash){\r\n                console.info(\"hash!=this.currentDebugInfo.hash\");\r\n                this.currentDebugInfo=null;\r\n                return;\r\n            }\r\n            let binaryCount = ctx.readU32();\r\n            for(let adressOffset=0;adressOffset<binaryCount;adressOffset++)\r\n            {\r\n                let value = ctx.readU32();\r\n                if(adressOffset<2) continue;\r\n                let connectorType=ConnectorType.BOOLEAN\r\n                let map = this.currentDebugInfo.typeIndex2adressOffset2ListOfLinks.get(connectorType)!;\r\n                let linksToChange = map.get(adressOffset);\r\n                if(linksToChange===undefined){\r\n                    console.error(`linksToColorize===undefined for connectorType ${connectorType} addressOffset ${adressOffset} and value ${value}`);\r\n                    continue;\r\n                }\r\n                linksToChange.forEach((e)=>{\r\n                    e.SetColor(value==1?\"red\":\"grey\");\r\n                    e.SetCaption(\"\"+value);\r\n                });\r\n            }\r\n\r\n            let integerCount = ctx.readU32();\r\n            for(let adressOffset=0;adressOffset<integerCount;adressOffset++)\r\n            {\r\n                let value = ctx.readS32();\r\n                if(adressOffset<2) continue;\r\n                let connectorType=ConnectorType.INTEGER\r\n                let map = this.currentDebugInfo.typeIndex2adressOffset2ListOfLinks.get(connectorType)!;\r\n                let linksToChange = map.get(adressOffset);\r\n                if(linksToChange===undefined){\r\n                    console.error(`linksToColorize===undefined for connectorType ${connectorType} addressOffset ${adressOffset} and value ${value}`);\r\n                    continue;\r\n                }\r\n                linksToChange.forEach((e)=>{\r\n                    e.SetCaption(\"\"+value);\r\n                });\r\n            }\r\n\r\n            let floatsCount = ctx.readU32();\r\n            for(let adressOffset=0;adressOffset<floatsCount;adressOffset++)\r\n            {\r\n                let value = ctx.readF32();\r\n                if(adressOffset<2) continue;\r\n                let connectorType=ConnectorType.FLOAT\r\n                let map = this.currentDebugInfo.typeIndex2adressOffset2ListOfLinks.get(connectorType)!;\r\n                let linksToChange = map.get(adressOffset);\r\n                if(linksToChange===undefined){\r\n                    console.error(`linksToColorize===undefined for connectorType ${connectorType} addressOffset ${adressOffset} and value ${value}`);\r\n                    continue;\r\n                }\r\n                linksToChange.forEach((e)=>{\r\n                    e.SetCaption(\"\"+value);\r\n                });\r\n            }\r\n\r\n            let colorsCount = ctx.readU32();\r\n            for(let adressOffset=0;adressOffset<colorsCount;adressOffset++)\r\n            {\r\n                let value = ctx.readU32();\r\n                if(adressOffset<2) continue;\r\n                let connectorType=ConnectorType.COLOR\r\n                let map = this.currentDebugInfo.typeIndex2adressOffset2ListOfLinks.get(connectorType)!;\r\n                let linksToChange = map.get(adressOffset);\r\n                if(linksToChange===undefined){\r\n                    console.error(`linksToColorize===undefined for connectorType ${connectorType} addressOffset ${adressOffset} and value ${value}`);\r\n                    continue;\r\n                }\r\n                linksToChange.forEach((e)=>{\r\n                    e.SetCaption(\"\"+value);\r\n                    e.SetColor($.ColorNumColor2ColorDomString(value));\r\n                });\r\n            }\r\n        }\r\n        xhr.send();\r\n    }\r\n\r\n    public _notifyGlobalMousemoveWithLink(e: MouseEvent) {\r\n        if (this.lastOutputConnectorClicked != null && !this.temporaryLinkSnapped) {\r\n            let end = Utils.EventCoordinatesInSVG(e, this.flowchartContainerSvgSvg, this.positionRatio);\r\n            this.temporaryLink.setAttribute('x2', \"\" + end.x);\r\n            this.temporaryLink.setAttribute('y2', \"\" + end.y);\r\n        }\r\n    }\r\n\r\n    public _notifyGlobalMouseupWithLink(e: MouseEvent) {\r\n        this.unsetTemporaryLink();\r\n    }\r\n\r\n    public _notifyOutputConnectorMousedown(c: FlowchartOutputConnector, e: MouseEvent) {\r\n        this.temporaryLinkSnapped = false;\r\n        let start = c.GetLinkpoint();\r\n        let end = Utils.EventCoordinatesInSVG(e, this.flowchartContainerSvgSvg, this.positionRatio);\r\n        this.temporaryLink.setAttribute('x1', \"\" + start.x);\r\n        this.temporaryLink.setAttribute('y1', \"\" + start.y);\r\n        this.temporaryLink.setAttribute('x2', \"\" + end.x);\r\n        this.temporaryLink.setAttribute('y2', \"\" + end.y);\r\n        this.setTemporaryLink(c);\r\n        document.onmouseup = (e) => {\r\n            document.onmouseup = null;\r\n            document.onmousemove = null;\r\n            this._notifyGlobalMouseupWithLink(e);\r\n        };\r\n        document.onmousemove = (e) => {\r\n            this._notifyGlobalMousemoveWithLink(e);\r\n        };\r\n    }\r\n\r\n    public _notifyInputConnectorMouseup(c: FlowchartInputConnector, e: MouseEvent) {\r\n        if (this.lastOutputConnectorClicked == null) return;\r\n        if (!this.options.multipleLinksOnInput && c.LinksLength > 0) return;\r\n        if (this.lastOutputConnectorClicked.Type == c.Type) {\r\n            this.createLink(null, this.lastOutputConnectorClicked, c);\r\n        }\r\n        this.unsetTemporaryLink();\r\n\r\n    }\r\n\r\n    public _notifyOperatorClicked(o: FlowchartOperator, e: MouseEvent) {\r\n        this.SelectOperator(o);\r\n    }\r\n\r\n    public _notifyLinkClicked(link: FlowchartLink, e: MouseEvent) {\r\n        this.selectLink(link);\r\n    }\r\n\r\n    public _notifyInputConnectorMouseenter(c: FlowchartInputConnector, e: MouseEvent) {\r\n        if (this.lastOutputConnectorClicked == null || this.lastOutputConnectorClicked.Type != c.Type) return;\r\n        if (!this.options.multipleLinksOnInput && c.LinksLength > 0) return;\r\n\r\n        this.temporaryLinkSnapped = true;\r\n        let end = c.GetLinkpoint();\r\n        this.temporaryLink.setAttribute(\"marker-end\", \"url(#marker-circle)\");\r\n        this.temporaryLink.setAttribute('x2', \"\" + end.x);\r\n        this.temporaryLink.setAttribute('y2', \"\" + end.y);\r\n    }\r\n\r\n    public _notifyInputConnectorMouseleave(c: FlowchartInputConnector, e: MouseEvent) {\r\n        this.temporaryLinkSnapped = false;\r\n        this.temporaryLink.setAttribute(\"marker-end\", \"url(#marker-arrow)\");\r\n    }\r\n\r\n    public unselectLink() {\r\n        if (this.selectedLink != null) {\r\n            if (this.options.onLinkUnselect && !this.options.onLinkUnselect(this.selectedLink)) {\r\n                return;\r\n            }\r\n            this.selectedLink.UnsetColor();\r\n            this.selectedLink = null;\r\n        }\r\n    }\r\n\r\n    public selectLink(link: FlowchartLink) {\r\n        this.unselectLink();\r\n        if (this.options.onLinkSelect && !this.options.onLinkSelect(link)) {\r\n            return;\r\n        }\r\n        this.unselectOperator();\r\n        this.selectedLink = link;\r\n        link.SetColor(this.options.defaultSelectedLinkColor);\r\n    }\r\n \r\n\r\n    private deleteSelectedThing(): void {\r\n        if (this.selectedOperator) {\r\n            this.DeleteOperator(this.selectedOperator.GlobalOperatorIndex);\r\n        }\r\n        else if (this.selectedLink) {\r\n            this.DeleteLink(this.selectedLink.GlobalLinkIndex);\r\n        }\r\n    }\r\n\r\n    private fbd2json():string{\r\n        let operators: OperatorData[] = [];\r\n        let links: LinkData[] = [];\r\n        for (const op of this.operators.values()) {\r\n            operators.push({ globalTypeIndex: op.TypeInfo.GlobalTypeIndex, caption: op.Caption, index: op.GlobalOperatorIndex, posX: op.Xpos, posY: op.Ypos, configurationData: op.Config_Copy });\r\n        }\r\n        for (const link of this.links.values()) {\r\n            links.push({\r\n                color: \"blue\",\r\n                fromOperatorIndex: link.From.Parent.GlobalOperatorIndex,\r\n                fromOutput: link.From.LocalConnectorIndex,\r\n                toOperatorIndex: link.To.Parent.GlobalOperatorIndex,\r\n                toInput: link.To.LocalConnectorIndex,\r\n            });\r\n        }\r\n        let data: FlowchartData = { operators: operators, links: links };\r\n        return JSON.stringify(data);\r\n    }\r\n\r\n    \r\n\r\n    private saveJSONToLocalFile() {\r\n        \r\n        let text = this.fbd2json();\r\n        let filename = \"functionBlockDiagram.json\";\r\n        var element = document.createElement('a');\r\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\r\n        element.setAttribute('download', filename);\r\n        element.style.display = 'none';\r\n        document.body.appendChild(element);\r\n        element.click();\r\n        document.body.removeChild(element);\r\n    }\r\n\r\n    private saveBinToLocalFile() {\r\n        \r\n        let text = this.fbd2json();\r\n        let compilerInstance = new FlowchartCompiler(this.operators);\r\n        let binFile =compilerInstance.Compile();  \r\n        let blob = new Blob([new Uint8Array(binFile.buf, 0, binFile.buf.byteLength)], {type: \"octet/stream\"});\r\n        let url = window.URL.createObjectURL(blob);\r\n        let filename = \"functionBlockDiagram.bin\";\r\n        var element = document.createElement('a');\r\n        element.style.display = 'none';\r\n        element.href=url;\r\n        element.download=filename;\r\n        document.body.appendChild(element);\r\n        element.click();\r\n        document.body.removeChild(element);\r\n    }\r\n\r\n    private openFromLocalFile(files: FileList | null) {\r\n        if (files == null || files.length != 1) return;\r\n        const reader = new FileReader();\r\n        reader.onloadend = (e) => {\r\n            let s: string = <string>e.target!.result;\r\n            let data = <FlowchartData>JSON.parse(s);\r\n            this.setData(data);\r\n        }\r\n        reader.readAsText(files[0]);\r\n    }\r\n\r\n    private put2fbd(buf:ArrayBuffer)\r\n    {\r\n        let xhr = new XMLHttpRequest;\r\n        xhr.open(\"PUT\", \"/fbd\", true);\r\n        xhr.onloadend = (e) => {\r\n            if(xhr.status!=200){\r\n                this.appManagement.DialogController().showOKDialog(16, `HTTP Error ${xhr.status}`, null);\r\n                return;\r\n            }\r\n            this.appManagement.DialogController().showOKDialog(16, `Successfully saved`, null);\r\n        }\r\n        xhr.onerror = (e) => { \r\n            this.appManagement.DialogController().showOKDialog(16, `Generic Error`, null);\r\n        }\r\n        xhr.send(buf);\r\n    }\r\n\r\n    private saveJSONToLabathomeFile(){\r\n        \r\n        this.appManagement.DialogController().showEnterFilenameDialog(10, \"Enter filename (without Extension\", (filename:string)=>{\r\n            let xhr_json = new XMLHttpRequest;\r\n            xhr_json.open(\"POST\", \"/fbdstorejson/\"+filename, true);\r\n            xhr_json.onloadend = (e) => {\r\n                if(xhr_json.status!=200){\r\n                    this.appManagement.DialogController().showOKDialog(16, `HTTP Error ${xhr_json.status}`, null);\r\n                    return;\r\n                }\r\n                this.appManagement.DialogController().showOKDialog(16, `Successfully saved`, null);\r\n            }\r\n            xhr_json.onerror = (e) => { this.appManagement.DialogController().showOKDialog(16, `Generic Error`, null);}\r\n            xhr_json.send(this.fbd2json());\r\n        });\r\n\r\n    }\r\n\r\n    private saveJSONandBINToLabathomeDefaultFile(buf:ArrayBuffer)\r\n    {\r\n        let xhr_bin = new XMLHttpRequest();\r\n        xhr_bin.open(\"POST\", \"/fbddefaultbin\", true);\r\n        xhr_bin.onloadend = (e) => {\r\n            if(xhr_bin.status!=200){\r\n                this.appManagement.DialogController().showOKDialog(16, `HTTP Error ${xhr_bin.status}`, null);\r\n                return;\r\n            }\r\n            let xhr_json  = new XMLHttpRequest();\r\n            xhr_json.open(\"POST\", \"/fbddefaultjson\", true);\r\n            xhr_json.onloadend =(e)=>{\r\n                if(xhr_json.status!=200){\r\n                    this.appManagement.DialogController().showOKDialog(16, `HTTP Error ${xhr_json.status}`, null);\r\n                    return;\r\n                }\r\n                this.appManagement.DialogController().showOKDialog(16, `Successfully set a new default FBD`, null);\r\n            }\r\n            xhr_json.onerror = (e) => { this.appManagement.DialogController().showOKDialog(16, `Generic Error`, null);}\r\n            xhr_json.send(this.fbd2json())\r\n        }\r\n        xhr_bin.onerror = (e) => { this.appManagement.DialogController().showOKDialog(16, `Generic Error`, null);}\r\n        xhr_bin.send(buf);\r\n    }\r\n\r\n    private openJSONFromLabathome()\r\n    {\r\n        let filename:string = \"\";\r\n        let xhr = new XMLHttpRequest;\r\n        xhr.open(\"GET\", \"/fbdstorejson/\", true);//GET without filename, but with \"/\" at the end!!!\r\n        xhr.onload = (e) => {\r\n            let s = xhr.responseText;\r\n            let data = <string[]>JSON.parse(s);\r\n            this.appManagement.DialogController().showFilelist(1000, data, \r\n                (filename:string)=>{\r\n                    let xhr = new XMLHttpRequest;\r\n                    xhr.open(\"GET\", \"/fbdstorejson/\"+filename, true); //GET with the filename selected in the dialog\r\n                    xhr.onload = (e) => {\r\n                        let s = xhr.responseText;\r\n                        let data = <FlowchartData>JSON.parse(s);\r\n                        this.setData(data);\r\n                    }\r\n                    xhr.send();\r\n                },\r\n                (filename:string)=>{\r\n                    let xhr = new XMLHttpRequest;\r\n                    xhr.open(\"DELETE\", \"/fbdstorejson/\"+filename, true); //GET with the filename selected in the dialog\r\n                    xhr.onloadend = (e) => {\r\n                        this.appManagement.DialogController().showOKDialog(1, `File ${filename} deleted successfully`, null);\r\n                    }\r\n                    xhr.send();\r\n                }\r\n            );\r\n        }\r\n        xhr.send();\r\n    }\r\n\r\n\r\n    private openDefaultJSONFromLabathome()\r\n    {\r\n        let xhr = new XMLHttpRequest;\r\n        xhr.open(\"GET\", \"/fbddefaultjson\", true);\r\n        xhr.onload = (e) => {\r\n            let s = xhr.responseText;\r\n            let data = <FlowchartData>JSON.parse(s);\r\n            this.setData(data);\r\n        }\r\n        xhr.send();\r\n    }\r\n\r\n    \r\n\r\n    private buildMenu(subcontainer: HTMLDivElement) {\r\n        let fileInput = <HTMLInputElement>$.Html(subcontainer, \"input\", [\"type\", \"file\", \"id\", \"fileInput\", \"accept\", \".json\"]);\r\n        fileInput.style.display = \"none\";\r\n        fileInput.onchange = (e) => {\r\n            this.openFromLocalFile(fileInput.files);\r\n        }\r\n\r\n        let toolbar = $.Html(subcontainer, \"div\", [], [\"develop-toolbar\"]);\r\n        let menuFile = $.Html(toolbar, \"div\", [], [\"dropdown\"]);\r\n        let menuFileDropBtn = <HTMLButtonElement>$.Html(menuFile, \"button\", [], [\"dropbtn\"], \"File ▼\");\r\n        let menuFileDropContent = $.Html(menuFile, \"div\", [], [\"dropdown-content\"]);\r\n        menuFileDropBtn.onclick = (e) => { menuFileDropContent.classList.toggle(\"show\"); };\r\n        $.Html(menuFileDropContent, \"a\", [\"href\", \"#\"], [], \"📂 Open (Local)\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            fileInput.click();\r\n            e.preventDefault();\r\n        }\r\n        $.Html(menuFileDropContent, \"a\", [\"href\", \"#\"], [], \"📂 Open (labathome)\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            this.openJSONFromLabathome()\r\n            e.preventDefault();\r\n        }\r\n        $.Html(menuFileDropContent, \"a\", [\"href\", \"#\"], [], \"📂 Open Default (labathome)\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            this.openDefaultJSONFromLabathome()\r\n            e.preventDefault();\r\n        }\r\n        $.Html(menuFileDropContent, \"a\", [\"href\", \"#\"], [], \"💾 Save (Local)\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            this.saveJSONToLocalFile();\r\n            e.preventDefault();\r\n        }\r\n        \r\n        $.Html(menuFileDropContent, \"a\", [\"href\", \"#\"], [], \"💾 Save (labathome)\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            this.saveJSONToLabathomeFile();\r\n            e.preventDefault();\r\n        }\r\n        $.Html(menuFileDropContent, \"a\", [\"href\", \"#\"], [], \"💾 Save Bin (Local)\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            this.saveBinToLocalFile();\r\n            e.preventDefault();\r\n        }\r\n        //let runbutton = $.Html(toolbar, \"a\", [\"href\", \"#\"], [\"develop-toolbar\"], \"Run\");\r\n\r\n        let menuDebug = $.Html(toolbar, \"div\", [], [\"dropdown\"]);\r\n        let menuDebugDropBtn = <HTMLButtonElement>$.Html(menuDebug, \"button\", [], [\"dropbtn\"], \"Debug ▼\");\r\n\r\n        let menuDebugDropContent = $.Html(menuDebug, \"div\", [], [\"dropdown-content\"]);\r\n        menuDebugDropBtn.onclick = (e) => {\r\n            menuDebugDropContent.classList.toggle(\"show\");\r\n        };\r\n        $.Html(menuDebugDropContent, \"a\", [\"href\", \"#\"], [], \"☭ Run Now\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            let compilerInstance = new FlowchartCompiler(this.operators);\r\n            let guidAndBufAndMap: HashAndBufAndMaps=compilerInstance.Compile();  \r\n            this.currentDebugInfo=guidAndBufAndMap;\r\n            this.put2fbd(guidAndBufAndMap.buf);\r\n            e.preventDefault();\r\n        }\r\n        $.Html(menuDebugDropContent, \"a\", [\"href\", \"#\"], [], \"👣 Set as Startup-App\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            let compilerInstance = new FlowchartCompiler(this.operators);\r\n            let guidAndBufAndMap: HashAndBufAndMaps=compilerInstance.Compile();  \r\n            this.saveJSONandBINToLabathomeDefaultFile(guidAndBufAndMap.buf);\r\n            e.preventDefault();\r\n        }\r\n        let menuSimulation = $.Html(toolbar, \"div\", [], [\"dropdown\"]);\r\n        let menuSimulationDropBtn = <HTMLButtonElement>$.Html(menuSimulation, \"button\", [], [\"dropbtn\"], \"Simulation ▼\");\r\n\r\n        let menuSimulationDropContent = $.Html(menuSimulation, \"div\", [], [\"dropdown-content\"]);\r\n        menuSimulationDropBtn.onclick = (e) => {\r\n            menuSimulationDropContent.classList.toggle(\"show\");\r\n        };\r\n        $.Html(menuSimulationDropContent, \"a\", [\"href\", \"#\"], [], \"➤ Start Simulation\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            let compilerInstance = new FlowchartCompiler(this.operators);\r\n            this.simulationManager=new SimulationManager(compilerInstance.CompileForSimulation());\r\n            this.simulationManager.Start(false);\r\n            e.preventDefault();\r\n        }\r\n        $.Html(menuSimulationDropContent, \"a\", [\"href\", \"#\"], [], \"× Stop Simulation\").onclick = (e) => {\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n            this.simulationManager?.Stop();\r\n            e.preventDefault();\r\n        }\r\n        //let menuDebugLink2 = $.Html(menuDebugDropContent, \"a\", [\"href\", \"#\"], [], \"◉ Stop\");\r\n        //let menuDebugLink3 = $.Html(menuDebugDropContent, \"a\", [\"href\", \"#\"], [], \"◯ Erase\");\r\n    }\r\n\r\n    constructor(private appManagement:AppManagement, private container: HTMLDivElement, private options: FlowchartOptions) {\r\n        if (!this.container) throw new Error(\"container is null\");\r\n        this.operatorRegistry=operatorimpl.OperatorRegistry.Build();\r\n        let subcontainer = <HTMLDivElement>$.Html(this.container, \"div\", [], [\"develop-ui\"]);\r\n        subcontainer.onclick = (e) => {\r\n            if ((<HTMLElement>e.target).classList.contains(\"dropbtn\")) return;\r\n            Array.prototype.forEach.call(document.getElementsByClassName(\"dropdown-content\"), (elem: HTMLDivElement) => { elem.classList.remove(\"show\"); });\r\n        }\r\n\r\n        this.buildMenu(subcontainer);\r\n\r\n\r\n        let workspace = <HTMLDivElement>$.Html(subcontainer, \"div\", [\"tabindex\", \"0\"], [\"develop-workspace\"]);//tabindex, damit keypress-Events abgefangen werden können\r\n        this.propertyGridHtmlDiv = <HTMLDivElement>$.Html(subcontainer, \"div\", [], [\"develop-properties\"]);\r\n\r\n\r\n\r\n        this.flowchartContainerSvgSvg = <SVGSVGElement>$.Svg(workspace, \"svg\", [\"width\", \"100%\", \"height\", \"100%\"], [\"flowchart-container\"]);\r\n\r\n\r\n        this.linksLayer = <SVGGElement>$.Svg(this.flowchartContainerSvgSvg, \"g\", [], [\"flowchart-links-layer\"]);\r\n        this.operatorsLayer = <SVGGElement>$.Svg(this.flowchartContainerSvgSvg, \"g\", [], [\"flowchart-operators-layer\", \"unselectable\"]);\r\n        this.tempLayer = <SVGSVGElement>$.Svg(this.flowchartContainerSvgSvg, \"g\", [], [\"flowchart-temporary-link-layer\"]);\r\n        this.tempLayer.style.visibility = \"hidden\";//visible\r\n        let defs = $.Svg(this.tempLayer, \"defs\", []);\r\n        let markerArrow = $.Svg(defs, \"marker\", [\"id\", \"marker-arrow\", \"markerWidth\", \"4\", \"markerHeight\", \"4\", \"refX\", \"1\", \"refY\", \"2\", \"orient\", \"0\"]);\r\n        this.markerArrow = <SVGPathElement>$.Svg(markerArrow, \"path\", [\"d\", \"M0,0 L0,4 L2,2 z\", \"fill\", \"red\", \"stroke\", \"black\", \"stroke-width\", \"0.5\"]);\r\n        let markerCircle = $.Svg(defs, \"marker\", [\"id\", \"marker-circle\", \"markerWidth\", \"4\", \"markerHeight\", \"4\", \"refX\", \"2\", \"refY\", \"2\", \"orient\", \"0\"]);\r\n        this.markerCircle = <SVGCircleElement>$.Svg(markerCircle, \"circle\", [\"cx\", \"2\", \"cy\", \"2\", \"r\", \"2\", \"fill\", \"red\", \"stroke-width\", \"1px\", \"stroke\", \"black\"]);\r\n        this.temporaryLink = <SVGLineElement>$.Svg(this.tempLayer, \"line\", [\"x1\", \"0\", \"y1\", \"0\", \"x2\", \"0\", \"y2\", \"0\", \"stroke-dasharray\", \"6,6\", \"stroke-width\", \"4\", \"stroke\", \"black\", \"fill\", \"none\", \"marker-end\", \"url(#marker-arrow)\"]);\r\n\r\n        let operatorLibActivator = <SVGRectElement>$.Svg(this.flowchartContainerSvgSvg, \"rect\", [\"width\", \"40\", \"height\", \"100%\", \"fill\", \"white\", \"fill-opacity\", \"0\"]);\r\n\r\n        this.operatorLibDiv = <HTMLDivElement>$.Html(workspace, \"div\", [], [\"flowchart-operatorlibdiv\", \"unselectable\"]);\r\n        this.operatorLibDiv.style.display = \"none\";\r\n\r\n\r\n        //let toolsRect= <SVGRectElement>$.Svg(this.operatorLibDiv, \"rect\", [\"width\",\"140\", \"height\", \"100%\", \"rx\", \"10\", \"ry\", \"10\"], [\"tools-container\"]);\r\n\r\n        //The onmousemove event occurs every time the mouse pointer is moved over the div element.\r\n        //The mouseenter event only occurs when the mouse pointer enters the div element.\r\n        //The onmouseover event occurs when the mouse pointer enters the div element, and its child elements (p and span).\r\n\r\n        //The mouseout event triggers when the mouse pointer leaves any child elements as well the selected element.\r\n        //The mouseleave event is only triggered when the mouse pointer leaves the selected element.\r\n        operatorLibActivator.onmouseenter = (e) => {\r\n            this.operatorLibDiv.style.display = \"inline\";\r\n        }\r\n        this.operatorLibDiv.onmouseleave = (e) => {\r\n            this.operatorLibDiv.style.display = \"none\";\r\n        }\r\n\r\n        this.flowchartContainerSvgSvg.onclick = (e) => {\r\n            if (e.target == this.Element)//if the click is in a \"free\" area, then the target is the uppermost layer; the linkLayer!\r\n            {\r\n                this.unselectOperator();\r\n                this.unselectLink();\r\n            }\r\n        }\r\n\r\n        workspace.onkeyup = (e) => {\r\n            if (e.key == \"Delete\") {\r\n                console.log(\"Flowchart workspace.onkeyup with e.target=\" + e.target + \" und Delete-Key\");\r\n                this.deleteSelectedThing();\r\n            }\r\n            else {\r\n                console.log(\"Flowchart workspace.onkeyup with e.target=\" + e.target + \" und key \" + e.key);\r\n            }\r\n        }\r\n\r\n        this.operatorRegistry.populateOperatorLib(this.operatorLibDiv,(e:MouseEvent, ti:TypeInfo)=>{\r\n            let caption = ti.OperatorName;\r\n            let o = this.createOperatorInternal(ti.GlobalTypeIndex, caption, null);\r\n            let coords = Utils.EventCoordinatesInSVG(e, this.Element);\r\n            o.MoveTo(coords.x - 10, coords.y - 10);\r\n            o.RegisterDragging(e);\r\n            this.operators.set(o.GlobalOperatorIndex, o);\r\n        } );\r\n    }\r\n\r\n\r\n    public onFirstStart() {\r\n        if (typeof this.options.data !== undefined && this.options.data != null) {\r\n            this.setData(this.options.data);\r\n        }\r\n    }\r\n\r\n\r\n    private createOperatorInternal(globalTypeIndex: number, caption: string, configurationData: KeyValueTuple[] | null): FlowchartOperator {\r\n        \r\n        if(!this.operatorRegistry.IsIndexKnown(globalTypeIndex))\r\n        {\r\n            throw new Error(`Unknown globalTypeIndex ${globalTypeIndex}`);\r\n        }\r\n        if (this.options.onOperatorCreate && !this.options.onOperatorCreate(caption, null, false)) {\r\n            throw new Error(`Creation of operator of globalTypeIndex ${globalTypeIndex} prevented by onOperatorCreate plugin`);\r\n        }\r\n        let op = this.operatorRegistry.CreateByIndex(globalTypeIndex, this, caption, configurationData)!;\r\n       \r\n        this.currentDebugInfo=null;\r\n        return op;\r\n    }\r\n\r\n    public setData(data: FlowchartData) {\r\n\r\n        this.links.forEach((e) => e.RemoveFromDOM());\r\n        this.links.clear();\r\n        this.operators.forEach((e) => e.RemoveFromDOM());\r\n        this.operators.clear();\r\n        let indexInData2operator = new Map<number, FlowchartOperator>();\r\n\r\n        for (const d of data.operators) {\r\n            let o = this.createOperatorInternal(d.globalTypeIndex, d.caption, d.configurationData);\r\n            o.MoveTo(d.posX, d.posY);\r\n            this.operators.set(o.GlobalOperatorIndex, o);\r\n            indexInData2operator.set(d.index, o);\r\n        }\r\n        for (const d of data.links) {\r\n            let fromOp = indexInData2operator.get(d.fromOperatorIndex);\r\n            let toOp = indexInData2operator.get(d.toOperatorIndex);\r\n            if (fromOp === undefined || toOp === undefined) continue;\r\n            let fromConn = fromOp.GetOutputConnectorByIndex(d.fromOutput);\r\n            let toConn = toOp.GetInputConnectorByIndex(d.toInput);\r\n            if (fromConn == null || toConn == null) continue;\r\n            this.createLink(d, fromConn, toConn);\r\n        }\r\n    }\r\n\r\n    public DeleteLink(globalLinkIndex: number) {\r\n        this.currentDebugInfo=null;\r\n        let l = this.links.get(globalLinkIndex);\r\n        if (l === undefined) {\r\n            throw Error(\"Link to delete is undefined\")\r\n        }\r\n        if (this.selectedLink == l) {\r\n            this.unselectLink();\r\n        }\r\n        l.RemoveFromDOM();\r\n        this.links.delete(globalLinkIndex);\r\n        l.To.RemoveLink(l);\r\n        l.From.RemoveLink(l);\r\n    }\r\n\r\n    public DeleteOperator(globalOperatorIndex: number) {\r\n        this.currentDebugInfo=null;\r\n        let o = this.operators.get(globalOperatorIndex);\r\n        if (o === undefined) {\r\n            throw Error(\"Operator to delete is undefined\")\r\n        }\r\n        if (this.selectedOperator == o) {\r\n            this.unselectOperator();\r\n        }\r\n        o.RemoveFromDOM();\r\n        this.operators.delete(o.GlobalOperatorIndex);\r\n        for (const outputKV of o.OutputsKVIt) {\r\n            for (const linkKV of outputKV[1].LinksKVIt) {\r\n                this.DeleteLink(linkKV[1].GlobalLinkIndex);\r\n            }\r\n        }\r\n        for (const inputKV of o.InputsKVIt) {\r\n            for (const linkKV of inputKV[1].LinksKVIt) {\r\n                this.DeleteLink(linkKV[1].GlobalLinkIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    public createLink(data: LinkData | null, from: FlowchartOutputConnector, to: FlowchartInputConnector): FlowchartLink | null {\r\n        if (this.options.onLinkCreate && !this.options.onLinkCreate(from.Caption, data)) return null;\r\n        if (!this.options.multipleLinksOnOutput && from.LinksLength > 0) return null;\r\n        if (!this.options.multipleLinksOnInput && to.LinksLength > 0) return null;\r\n        this.currentDebugInfo=null;\r\n        let l: FlowchartLink = new FlowchartLink(this, \"\", this.Options.defaultLinkColor, from, to);\r\n        from.AddLink(l);\r\n        to.AddLink(l);\r\n        this.links.set(l.GlobalLinkIndex, l);\r\n        return l;\r\n    }\r\n\r\n    private unsetTemporaryLink() {\r\n        this.lastOutputConnectorClicked = null;\r\n        this.tempLayer.style.visibility = \"hidden\";\r\n    }\r\n\r\n    private setTemporaryLink(c: FlowchartOutputConnector) {\r\n        this.lastOutputConnectorClicked = c;\r\n        let color = Flowchart.DATATYPE2COLOR.get(c.Type)\r\n        if (!color) color = \"BLACK\";\r\n        this.markerArrow.style.fill = color;\r\n        this.markerCircle.style.fill = color;\r\n        this.tempLayer.style.visibility = \"visible\";\r\n    }\r\n\r\n    private unselectOperator() {\r\n        if (this.options.onOperatorUnselect && !this.options.onOperatorUnselect()) return;\r\n        this.propertyGridHtmlDiv.innerText = \"\"; //clear\r\n        if (this.selectedOperator == null) return;\r\n        this.selectedOperator.ShowAsSelected(false);\r\n        this.selectedOperator = null;\r\n    }\r\n\r\n    public SelectOperator(operator: FlowchartOperator): void {\r\n        if (this.options.onOperatorSelect && !this.options.onOperatorSelect(operator.Caption)) return;\r\n        this.unselectLink();\r\n        if (this.selectedOperator != null) this.selectedOperator.ShowAsSelected(false);\r\n        operator.ShowAsSelected(true);\r\n        this.selectedOperator = operator;\r\n        this.propertyGridHtmlDiv.innerText = \"\"; //clear\r\n        $.Html(this.propertyGridHtmlDiv, \"p\", [], [\"develop-propertygrid-head\"], `Properties for ${this.selectedOperator.Caption}`);\r\n        let table = <HTMLTableElement>$.Html(this.propertyGridHtmlDiv, \"table\", [], [\"develop-propertygrid-table\"]);\r\n        let thead = <HTMLTableSectionElement>$.Html(table, \"thead\", [],[]);\r\n        let tr_head = $.Html(thead, \"tr\", [], [\"develop-propertygrid-tr\"]);\r\n        $.Html(tr_head, \"th\", [], [\"develop-propertygrid-th\"], \"Key\");\r\n        $.Html(tr_head, \"th\", [], [\"develop-propertygrid-th\"], \"Value\");\r\n        let tbody= <HTMLTableSectionElement>$.Html(table, \"tbody\", [],[]);\r\n        if (this.selectedOperator!.PopulateProperyGrid(tbody)) {\r\n            $.Html(this.propertyGridHtmlDiv, \"button\", [], [\"develop-propertygrid-button\"], `Save`).onclick=(e)=>{\r\n                this.currentDebugInfo=null;\r\n                operator.SavePropertyGrid(tbody);\r\n            };\r\n        }\r\n        else {\r\n            this.propertyGridHtmlDiv.innerText = \"\"; //clear\r\n            $.Html(this.propertyGridHtmlDiv, \"p\", [], [\"develop-propertygrid-head\"], `No Properties for ${this.selectedOperator.Caption}`);\r\n        }\r\n    }\r\n\r\n    // Found here : http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors\r\n    public static _shadeColor(color: string, percent: number) {\r\n        var f = parseInt(color.slice(1), 16), t = percent < 0 ? 0 : 255, p = percent < 0 ? percent * -1 : percent, R = f >> 16, G = f >> 8 & 0x00FF, B = f & 0x0000FF;\r\n        return \"#\" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);\r\n    }\r\n}\r\n","import {FlowchartOperator, PositionType } from \"./FlowchartOperator\";\r\nimport {ConnectorType } from \"./FlowchartConnector\";\r\nimport { NodeWrapper, TopologicalSortDFS } from \"./TopologicalSorfDFS\";\r\nimport { SerializeContext } from \"./SerializeContext\";\r\nimport { FlowchartLink } from \"./FlowchartLink\";\r\n\r\nexport interface SerializeContextAndAdressMap {\r\n    typeIndex2globalConnectorIndex2adressOffset: Map<number, Map<number, number>>;\r\n    ctx: SerializeContext;\r\n}\r\n\r\nexport interface HashAndBufAndMaps{\r\n    hash:number;\r\n    buf: ArrayBuffer;\r\n    typeIndex2globalConnectorIndex2adressOffset:Map<number, Map<number, number>>,\r\n    typeIndex2adressOffset2ListOfLinks:Map<number, Map<number, Array<FlowchartLink>>>,\r\n    typeIndex2maxOffset:Map<number, number>,\r\n}\r\n\r\nexport interface HashAndBuf{\r\n    hash:number;\r\n    buf: ArrayBuffer;\r\n}\r\n\r\nexport interface SortedOperatorsAndMaps{\r\n    sortedOperators:FlowchartOperator[];\r\n    typeIndex2globalConnectorIndex2adressOffset:Map<number, Map<number, number>>,\r\n    typeIndex2adressOffset2ListOfLinks:Map<number, Map<number, Array<FlowchartLink>>>,\r\n    typeIndex2maxOffset:Map<number, number>,\r\n}\r\n\r\nexport interface Maps{\r\n    typeIndex2globalConnectorIndex2adressOffset:Map<number, Map<number, number>>,\r\n    typeIndex2adressOffset2ListOfLinks:Map<number, Map<number, Array<FlowchartLink>>>,\r\n    typeIndex2maxOffset:Map<number, number>,\r\n}\r\n\r\nexport class FlowchartCompiler {\r\n    \r\n    public constructor(private index2operator:Map<number,FlowchartOperator>)\r\n    {\r\n       \r\n    }\r\n\r\n    private sortOperators():FlowchartOperator[]{\r\n        let index2wrappedOperator = new Map<number, NodeWrapper<FlowchartOperator>>();\r\n        this.index2operator.forEach((v, k, m) => {\r\n            index2wrappedOperator.set(v.GlobalOperatorIndex, new NodeWrapper<FlowchartOperator>(v));\r\n        });\r\n        let wrappedOutputOperators: NodeWrapper<FlowchartOperator>[] = [];\r\n        for (let i of index2wrappedOperator.values()) {\r\n            //Stelle für jede \"gewrapte Node\" fest, welche Operatoren von Ihr abhängig sind\r\n            let dependents = new Set<NodeWrapper<FlowchartOperator>>();\r\n            for (const inputkv of i.Payload.InputsKVIt) {\r\n                for (const linkkv of inputkv[1].LinksKVIt) {\r\n                    let dependentOperator = linkkv[1].From.Parent;\r\n                    let dependentWrappedNode = index2wrappedOperator.get(dependentOperator.GlobalOperatorIndex);\r\n                    if (!dependentWrappedNode)\r\n                        throw new Error(\"Implementation Error: dependentWrappedNode is undefined\");\r\n                    dependents.add(dependentWrappedNode);\r\n                }\r\n            }\r\n            dependents.forEach(e => i.DependendNodes.push(e));\r\n            //füge alle mit Typ \"Output\" einer Liste hinzu\r\n            if (i.Payload.TypeInfo.Position == PositionType.Output) wrappedOutputOperators.push(i);\r\n        }\r\n\r\n        let algorithm = new TopologicalSortDFS<FlowchartOperator>();\r\n        let sortedList = algorithm.sort(wrappedOutputOperators);\r\n        return sortedList.map((e) => e.Payload)\r\n    }\r\n\r\n    public CompileForSimulation():SortedOperatorsAndMaps{\r\n        let sortedOperators = this.sortOperators();\r\n        for (const key in sortedOperators) {\r\n            let value = sortedOperators[key];\r\n            value.SetDebugInfoText(\"Sequence \" + key);\r\n        }\r\n        let maps=this.createLookupMaps(sortedOperators);\r\n        return {\r\n            sortedOperators:sortedOperators,\r\n            typeIndex2globalConnectorIndex2adressOffset:maps.typeIndex2globalConnectorIndex2adressOffset,\r\n            typeIndex2adressOffset2ListOfLinks:maps.typeIndex2adressOffset2ListOfLinks,\r\n            typeIndex2maxOffset:maps.typeIndex2maxOffset,\r\n        };\r\n    }\r\n\r\n    public Compile(): HashAndBufAndMaps {\r\n        let sortedOperators = this.sortOperators();\r\n        for (const key in sortedOperators) {\r\n            let value = sortedOperators[key];\r\n            value.SetDebugInfoText(\"Sequence \" + key);\r\n        }\r\n        let maps=this.createLookupMaps(sortedOperators);\r\n        let hashAndBuf= this.serialize(sortedOperators, maps);\r\n\r\n        let dv = new DataView(hashAndBuf.buf);\r\n        let code: String = \"const uint8_t code[] = {\"\r\n        for (let i = 0; i < dv.byteLength; i++) {\r\n            code += \"0x\" + dv.getUint8(i).toString(16) + \", \";\r\n        }\r\n        code += \"};\";\r\n        console.log(code);\r\n\r\n        return {\r\n            hash:hashAndBuf.hash,\r\n            buf: hashAndBuf.buf,\r\n            typeIndex2globalConnectorIndex2adressOffset:maps.typeIndex2globalConnectorIndex2adressOffset,\r\n            typeIndex2adressOffset2ListOfLinks:maps.typeIndex2adressOffset2ListOfLinks,\r\n            typeIndex2maxOffset:maps.typeIndex2maxOffset,\r\n        };\r\n    }\r\n\r\n    private createLookupMaps(operators:FlowchartOperator[]):Maps{\r\n        //Speichert separat für jeden Datentyp (Bool, int, float, color,...), welcher GlobalConnectorIndex auf welchen bei 2 beginnend fortlaufenden Adress-Offset gemapped wird\r\n        //wir beginnen bei 2, weil unbeschaltete Outputs auf 0 schreiben und unbeschaltete Inputs von 1 lesen.\r\n        let typeIndex2globalConnectorIndex2adressOffset = new Map<number, Map<number, number>>(); //globalConnectorIndex_Outputs 2 variableAdress\r\n        let typeIndex2maxOffset = new Map<number, number>();\r\n        let typeIndex2adressOffset2ListOfLinks = new Map<number, Map<number, Array<FlowchartLink>>>();\r\n        for (let type in ConnectorType) {\r\n            if (!isNaN(Number(type))) {\r\n                typeIndex2globalConnectorIndex2adressOffset.set(Number(type), new Map<number, number>());\r\n                typeIndex2maxOffset.set(Number(type), 2);\r\n                typeIndex2adressOffset2ListOfLinks.set(Number(type), new Map<number,Array<FlowchartLink>>());\r\n            }\r\n        }\r\n        for (const operator of operators) {\r\n            for (const outputKV of operator.OutputsKVIt) {\r\n                if (outputKV[1].LinksLength == 0) {\r\n                    //unconnected output -->writes to memory adress zero of the respective data type\r\n                    typeIndex2globalConnectorIndex2adressOffset.get(outputKV[1].Type)!.set(outputKV[1].GlobalConnectorIndex, 0);\r\n                }\r\n                else {\r\n                    //connected output --> create new memory address and set it\r\n                    let index = typeIndex2maxOffset.get(outputKV[1].Type)!;\r\n                    typeIndex2globalConnectorIndex2adressOffset.get(outputKV[1].Type)!.set(outputKV[1].GlobalConnectorIndex, index);\r\n                    \r\n                    //add all outgoing links to typeIndex2adressOffset2ListOfLinks\r\n                    typeIndex2adressOffset2ListOfLinks.get(outputKV[1].Type)!.set(index, outputKV[1].GetLinksCopy());\r\n                    index++;\r\n                    typeIndex2maxOffset.set(outputKV[1].Type, index);\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            typeIndex2globalConnectorIndex2adressOffset:typeIndex2globalConnectorIndex2adressOffset,\r\n            typeIndex2adressOffset2ListOfLinks:typeIndex2adressOffset2ListOfLinks,\r\n            typeIndex2maxOffset:typeIndex2maxOffset,\r\n        };\r\n    }\r\n\r\n\r\n    private serialize(operators: FlowchartOperator[], maps:Maps):HashAndBuf {\r\n\r\n\r\n        /*\r\n        Lege nun die Operatoren in der durch das Array vorgegebenen Struktur in ein Array ab\r\n        */\r\n        let buffer = new ArrayBuffer(Math.pow(2, 16));\r\n        let serctx = new SerializeContext(buffer, 0);\r\n        let ctx: SerializeContextAndAdressMap = { \r\n            typeIndex2globalConnectorIndex2adressOffset: maps.typeIndex2globalConnectorIndex2adressOffset, \r\n            ctx:serctx\r\n        };\r\n        //Version of Data Structure\r\n        serctx.writeU32(0xAFFECAFE);\r\n        //Placeholder for hash\r\n        serctx.writeU32(0);\r\n\r\n\r\n        for (let type in ConnectorType) {\r\n            if (!isNaN(Number(type))) {\r\n                serctx.writeU32(maps.typeIndex2maxOffset.get(Number(type))!);\r\n            }\r\n        }\r\n    \r\n        //operatorsCount\r\n        serctx.writeU32(operators.length);\r\n        for (const operator of operators) {\r\n            operator.SerializeToBinary(ctx);\r\n        }\r\n\r\n        let hash= serctx.funhash(8, (2^32)-1);\r\n        serctx.overwriteU32(hash, 4);\r\n\r\n        return {\r\n            hash:hash, \r\n            buf:ctx.ctx.getResult(), \r\n        };\r\n    }\r\n}","import { FlowchartOperator } from \"./FlowchartOperator\";\r\nimport { Flowchart } from \"./Flowchart\";\r\nimport { FlowchartLink } from \"./FlowchartLink\";\r\nimport {$, Location2D} from \"../utils\"\r\n\r\nconst TRANSLATEY = 20;\r\n\r\nexport enum ConnectorType{\r\n    BOOLEAN=0,\r\n    INTEGER=1,\r\n    FLOAT=2,\r\n    COLOR=3,\r\n}\r\n\r\nexport abstract class FlowchartConnector {\r\n    private static INDEX: number = 0;\r\n    private globalConnectorIndex: number;\r\n    get GlobalConnectorIndex() { return this.globalConnectorIndex; }\r\n    get LocalConnectorIndex(){return this.localIndex;}\r\n\r\n    protected element: SVGGElement;\r\n    get Element() { return this.element; }\r\n\r\n    protected snapper:SVGCircleElement;\r\n    protected connector:SVGElement;\r\n    protected connectorGroup:SVGGElement;\r\n\r\n    protected  links = new Map<number, FlowchartLink>();\r\n    public HasLink = (globalLinkIndex: number) => this.links.has(globalLinkIndex);\r\n    public AddLink = (link: FlowchartLink) => this.links.set(link.GlobalLinkIndex, link);\r\n    public RemoveLink = (link: FlowchartLink) => this.links.delete(link.GlobalLinkIndex);\r\n    get LinksLength() { return this.links.size};\r\n    public GetLinksCopy(): FlowchartLink[] {\r\n        return Array.from(this.links.values());\r\n    }\r\n\r\n    get LinksKVIt(){return this.links.entries()}\r\n    protected abstract GetLinkpointXOffset(width:number): number;\r\n    protected abstract getIOSpecifics():{inputOrOutput:string, parent:SVGGElement, translateY:number, dx:number};\r\n\r\n    public RefreshLinkPositions() {\r\n        this.links.forEach(l=>{\r\n            l.RefreshPosition();\r\n        });\r\n        \r\n    }\r\n\r\n    constructor(private parent: FlowchartOperator, private caption: string, private localIndex:number, private type:ConnectorType) {\r\n\r\n        this.globalConnectorIndex = FlowchartConnector.INDEX++;\r\n        let spec = this.getIOSpecifics();\r\n        let translateY = TRANSLATEY*spec.parent.childElementCount;\r\n        this.element = <SVGGElement>$.Svg(spec.parent, \"g\", [\"transform\", `translate(0 ${translateY})`], [`operator-${spec.inputOrOutput}`]);\r\n        this.element.setAttribute(\"data-connector-datatype\", ConnectorType[type]);\r\n\r\n        let text =  <SVGTextElement>$.Svg(this.element, \"text\", [\"dx\",\"\"+spec.dx, \"dy\", \"4\"], [`operator-${spec.inputOrOutput}-caption`]);\r\n        text.textContent=caption;\r\n        this.connectorGroup = <SVGGElement>$.Svg(this.element, \"g\", []);\r\n        this.connector = <SVGCircleElement>$.Svg(this.connectorGroup, \"circle\", [\"r\",\"4\"], [`operator-${spec.inputOrOutput}-connector`, ConnectorType[type]]);\r\n        this.snapper= <SVGCircleElement>$.Svg(this.connectorGroup, \"circle\", [\"r\",\"10\"], [`operator-${spec.inputOrOutput}-snapper`]);\r\n        \r\n        this.element.onmouseover = (e) => {\r\n            for (const link of this.links.values()) {\r\n                if (link && link != this.parent.Parent.SelectedLink) {\r\n                    link.SetColor(Flowchart._shadeColor(this.parent.Parent.Options.defaultLinkColor, -0.4));\r\n                }\r\n            }\r\n        }\r\n\r\n        this.element.onmouseout = (e) => {\r\n            for (const link of this.links.values()) {\r\n                if (link && link != this.parent.Parent.SelectedLink) {\r\n                    link.UnsetColor();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    get Parent() { return this.parent; }\r\n    get Caption() { return this.caption; }\r\n    get Type() { return this.type; }\r\n\r\n\r\n    public GetLinkpoint(): Location2D {\r\n        let flowchart = this.Parent.Parent;\r\n        let posrat = flowchart.PositionRatio;\r\n        let flowchartRect = flowchart.Element.getBoundingClientRect();\r\n        let connectorRect = this.connector.getBoundingClientRect();\r\n        var x = (connectorRect.left - flowchartRect.left) / posrat + connectorRect.width/2;\r\n        var y = (connectorRect.top - flowchartRect.top) / posrat + connectorRect.height/2;\r\n        return { x: x, y: y };\r\n    }\r\n}\r\n\r\nexport class FlowchartInputConnector extends FlowchartConnector {\r\n    constructor (parent: FlowchartOperator, caption: string, localIndex:number, type:ConnectorType) {\r\n        super(parent, caption, localIndex, type);\r\n        \r\n        this.connectorGroup.onmouseup = (e) => {\r\n           parent.Parent._notifyInputConnectorMouseup(this, e);\r\n        }\r\n        this.connectorGroup.onmouseenter=(e)=>\r\n        {\r\n            parent.Parent._notifyInputConnectorMouseenter(this, e);\r\n        }\r\n        this.connectorGroup.onmouseleave=(e)=>\r\n        {\r\n            parent.Parent._notifyInputConnectorMouseleave(this, e);\r\n        }\r\n    }\r\n    protected GetLinkpointXOffset(width:number): number{return 0;}  \r\n    protected  getIOSpecifics(){return {inputOrOutput:\"input\", parent:this.Parent.InputSvgG, translateY:0, dx:8};}\r\n    public GetGlobalConnectorIndexOfSignalSource():number {\r\n        for(let link of this.links.values()){\r\n            return link.From.GlobalConnectorIndex;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\nexport class FlowchartOutputConnector extends FlowchartConnector {\r\n    constructor (parent: FlowchartOperator, caption: string, localIndex:number, type:ConnectorType) {\r\n        super(parent, caption, localIndex, type)\r\n        this.element.onmousedown = (e) => {\r\n            parent.Parent._notifyOutputConnectorMousedown(this, e);\r\n        }\r\n    }\r\n    protected GetLinkpointXOffset(width:number): number{return width;}\r\n    protected  getIOSpecifics(){return {inputOrOutput:\"output\", parent:this.Parent.OutputSvgG, translateY:140, dx:-8};}\r\n}\r\n","import { FlowchartInputConnector, FlowchartOutputConnector } from \"./FlowchartConnector\";\r\nimport { Flowchart } from \"./Flowchart\";\r\nimport {$} from \"../utils\"\r\nexport class FlowchartLink {\r\n    private static MAX_INDEX: number = 0;\r\n    private index: number;\r\n    private element: SVGPathElement;\r\n    private captionElement:SVGTextElement;\r\n    private captionPath: SVGTextPathElement;\r\n    constructor(private parent: Flowchart, private caption: string, private color: string, private from: FlowchartOutputConnector, private to: FlowchartInputConnector) {\r\n        this.index = FlowchartLink.MAX_INDEX++;\r\n        this.element = <SVGPathElement>$.Svg(parent.LinkLayer, \"path\", [\"stroke-width\", \"\" + this.parent.Options.linkWidth, \"fill\", \"none\", \"id\", \"LINK\" + this.index]);\r\n        this.RefreshPosition();\r\n        this.UnsetColor();\r\n        this.parent.LinkLayer.appendChild(this.element);\r\n        this.captionElement =<SVGTextElement>$.Svg(parent.LinkLayer, \"text\",[]);\r\n        this.captionPath = <SVGTextPathElement>$.Svg(this.captionElement, \"textPath\",[\"startOffset\", \"50%\",\"text-anchor\", \"middle\"]);\r\n        this.captionPath.setAttributeNS($.XLINKNS, \"href\", '#' + \"LINK\" + this.index);\r\n        this.captionPath.innerHTML = caption;\r\n        this.element.onclick = (e) => {\r\n            this.parent._notifyLinkClicked(this, e);\r\n        }\r\n    }\r\n    get GlobalLinkIndex() { return this.index; }\r\n    get From() { return this.from; }\r\n    get To() { return this.to; }\r\n    set Color(color: string) { this.color = color; }\r\n\r\n    public RemoveFromDOM() {\r\n        this.element.remove();\r\n        this.captionElement.remove();\r\n    }\r\n\r\n\r\n    public SetColor(color: string) {\r\n        this.element.setAttribute('stroke', color);\r\n        //this.element.setAttribute('fill', color);\r\n        //TODO: colorize the small triangle in the connector\r\n        //linkData.internal.els.fromSmallConnector.css('border-left-color', color);\r\n        //linkData.internal.els.toSmallConnector.css('border-left-color', color);\r\n    }\r\n\r\n    public SetCaption(caption:string){\r\n        this.captionPath.innerHTML=caption;\r\n    }\r\n\r\n    public UnsetColor() {\r\n        this.SetColor(this.parent.Options.defaultLinkColor);\r\n    }\r\n\r\n    public RefreshPosition() {\r\n        let fromPosition = this.from.GetLinkpoint();\r\n        let toPosition = this.to.GetLinkpoint();\r\n        let fromX = fromPosition.x;\r\n        let fromY = fromPosition.y + this.parent.Options.linkVerticalDecal;\r\n        let toX = toPosition.x;\r\n        let toY = toPosition.y + this.parent.Options.linkVerticalDecal;\r\n        let distanceFromArrow = this.parent.Options.distanceFromArrow;\r\n        let bezierFromX = (fromX + distanceFromArrow);\r\n        let bezierToX = toX + 1;\r\n        let bezierIntensity = Math.min(100, Math.max(Math.abs(bezierFromX - bezierToX) / 2, Math.abs(fromY - toY)));\r\n        this.element.setAttribute(\"d\", 'M' + bezierFromX + ',' + (fromY) + ' C' + (fromX + distanceFromArrow + bezierIntensity) + ',' + fromY + ' ' + (toX - bezierIntensity) + ',' + toY + ' ' + bezierToX + ',' + toY);\r\n    }\r\n}\r\n","import {FlowchartInputConnector, FlowchartOutputConnector } from \"./FlowchartConnector\";\r\nimport {Flowchart} from \"./Flowchart\";\r\nimport { SerializeContextAndAdressMap } from \"./FlowchartCompiler\";\r\nimport {$, KeyValueTuple} from \"../utils\"\r\nimport { SimulationContext } from \"./SimulationContext\";\r\n\r\nexport enum PositionType{\r\n    Default,\r\n    Input,\r\n    Output,\r\n};\r\nexport enum SingletonType{\r\n    Default,\r\n    Singleton,\r\n};\r\nexport class TypeInfo\r\n{\r\n    constructor(\r\n        public GlobalTypeIndex:number, \r\n        public GroupName:string, \r\n        public OperatorName:string, \r\n        public Position:PositionType, \r\n        public Singleton:SingletonType, \r\n        public Builder:(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null)=>FlowchartOperator)\r\n        {}\r\n}\r\n\r\nexport abstract class FlowchartOperator {\r\n\r\n    //der Index der Inputs ist rein lokal und beginnt bei 0 fortlaufend\r\n    private Inputs: FlowchartInputConnector[]=[];\r\n    //der Index der Outputs ist rein lokal und beginnt bei 0 fortlaufend\r\n    private Outputs: FlowchartOutputConnector[]= [];\r\n\r\n\r\n    private static MAX_INDEX: number = 0;\r\n    private index: number;\r\n    get GlobalOperatorIndex(){return this.index;}\r\n\r\n    private elementSvgG: SVGGElement;\r\n    get ElementSvgG() { return this.elementSvgG; }\r\n    private inputSvgG:SVGGElement;\r\n    get InputSvgG(): SVGGElement { return this.inputSvgG; }\r\n    private outputSvgG:SVGGElement;\r\n    get OutputSvgG(): SVGGElement { return this.outputSvgG;}\r\n    private debugInfoSvgText:SVGTextElement;\r\n\r\n    get TypeInfo(){return this.typeInfo;}\r\n\r\n    get Xpos(){return this.x;}\r\n    get Ypos(){return this.y;}\r\n    get Config_Copy(){\r\n        return this.configurationData?this.configurationData.slice(0):null;\r\n    }\r\n\r\n    private x=0;\r\n    private y=0;\r\n\r\n    protected box:SVGRectElement;\r\n\r\n    public ShowAsSelected(state:boolean)\r\n    {\r\n        if(state)\r\n        {\r\n            this.box.classList.add('selected');\r\n        }\r\n        else{\r\n            this.box.classList.remove('selected');\r\n        }\r\n    }\r\n\r\n    public SetDebugInfoText(text:string):void{\r\n        this.debugInfoSvgText.textContent=text;\r\n    }\r\n\r\n    protected cfg_setDefault(key:string, value:any)\r\n    {\r\n        if(this.configurationData==null) this.configurationData=[];\r\n        for (const e of this.configurationData) {\r\n            if(e.key==key){\r\n                return;\r\n            }\r\n        } \r\n        this.configurationData.push({key:key, value:value});\r\n    }\r\n\r\n    protected cfg_getValue(key:string, defaultValue:any):any\r\n    {\r\n        if(this.configurationData==null) this.configurationData=[];\r\n        for (const e of this.configurationData) {\r\n            if(e.key==key){\r\n                return e.value;\r\n            }\r\n        };\r\n        this.configurationData.push({key:key, value:defaultValue});\r\n        return defaultValue;\r\n    }\r\n\r\n    protected cfg_setValue(key:string, value:any)\r\n    {\r\n        if(this.configurationData==null) this.configurationData=[];\r\n        for (const e of this.configurationData) {\r\n            if(e.key==key){\r\n                e.value=value;\r\n                return;\r\n            }\r\n        } \r\n        this.configurationData.push({key:key, value:value});\r\n    }\r\n\r\n    constructor(private parent: Flowchart, private caption: string, private typeInfo: TypeInfo, protected configurationData:KeyValueTuple[]|null) {\r\n        this.index = FlowchartOperator.MAX_INDEX++;\r\n        this.elementSvgG = <SVGGElement>$.Svg(parent.OperatorsLayer, \"g\", [], [\"operator\"]);\r\n        this.elementSvgG.setAttribute('data-operator-index', \"\" + this.index);\r\n        let dragGroup = <SVGGElement>$.Svg(this.elementSvgG, \"g\", [], []);\r\n        this.box = <SVGRectElement>$.Svg(dragGroup, \"rect\", [\"width\",\"140\", \"height\", \"100\", \"rx\", \"10\", \"ry\", \"10\"], [\"operator-box\"]);\r\n        let title = <SVGTextElement>$.Svg(dragGroup,\"text\", [\"x\", \"5\", \"y\", \"21\"],[\"operator-title\"]);\r\n        title.textContent = caption;\r\n        this.debugInfoSvgText = <SVGTextElement>$.Svg(dragGroup, \"text\", [\"x\", \"0\", \"y\", \"100\"],[\"operator-debuginfo\"]);\r\n        this.debugInfoSvgText.textContent=\"No debug info\";\r\n\r\n        this.inputSvgG= <SVGGElement>$.Svg(this.elementSvgG,\"g\", [\"transform\", \"translate(0 50)\"], [\"operator-inputs\"]);\r\n        this.outputSvgG= <SVGGElement>$.Svg(this.elementSvgG,\"g\", [\"transform\", \"translate(140 50)\"], [\"operator-outputs\"]);\r\n\r\n\r\n        this.elementSvgG.onclick = (e) => {\r\n            console.log(\"FlowchartOperator this.elementSvgG.onclick\");\r\n            parent._notifyOperatorClicked(this, e);\r\n        };\r\n        \r\n        if (this.parent.Options.canUserMoveOperators) {\r\n            dragGroup.onmousedown = (e) => {\r\n                this.RegisterDragging(e);\r\n            }\r\n        }\r\n    }\r\n    public RegisterDragging(e:MouseEvent)\r\n    {\r\n        let offsetX= e.clientX-this.x;\r\n        let offsetY = e.clientY-this.y;\r\n\r\n        document.onmouseup = (e) => {\r\n            document.onmouseup = null;\r\n            document.onmousemove = null;\r\n        };\r\n        document.onmousemove = e => {\r\n            //TODO: neue Position nur setzen, wenn this.element.clientRect innerhalb von parent.clientRectangle ist\r\n            this.MoveTo(e.clientX - offsetX, e.clientY - offsetY);\r\n        };\r\n    }\r\n    get Parent() { return this.parent };\r\n    get Caption() { return this.caption; }\r\n\r\n    get InputsKVIt(){return this.Inputs.entries()}\r\n    get OutputsKVIt(){return this.Outputs.entries()}\r\n    public GetOutputConnectorByIndex=(i:number)=>this.Outputs[i];\r\n    public GetInputConnectorByIndex=(i:number)=>this.Inputs[i];\r\n\r\n    public RemoveFromDOM(): void {\r\n        this.elementSvgG.remove();\r\n    }\r\n\r\n    protected AppendConnectors(inputs: FlowchartInputConnector[], outputs: FlowchartOutputConnector[]) {\r\n        if(this.Inputs.length!=0 || this.Outputs.length !=0) throw new Error(\"AppendConnectors may only be called once!\");\r\n        for (const i of inputs) {\r\n            if (i.Parent != this) continue;\r\n            this.Inputs.push(i);\r\n        }\r\n        for (const o of outputs) {\r\n            if (o.Parent != this) continue;\r\n            this.Outputs.push(o);\r\n        }\r\n        let num = Math.max(this.Inputs.length, this.Outputs.length);\r\n        let height = 50+num*20+10;\r\n        this.box.setAttribute(\"height\", \"\"+height);\r\n        this.debugInfoSvgText.setAttribute(\"y\", \"\"+height);\r\n    }\r\n\r\n    public MoveTo(x: number, y: number) {\r\n        let g = this.parent.Options.grid;\r\n        this.x = Math.round(x / g) * g;\r\n        this.y = Math.round(y / g) * g;\r\n        this.elementSvgG.setAttribute(\"transform\", `translate(${this.x} ${this.y})`);\r\n        for (const c of this.Inputs) {\r\n            c.RefreshLinkPositions();\r\n        }\r\n        for (const c of this.Outputs) {\r\n            c.RefreshLinkPositions();\r\n        }\r\n    }\r\n\r\n    public PopulateProperyGrid(parent:HTMLTableSectionElement):boolean\r\n    {\r\n        return false;\r\n    }\r\n\r\n    public SavePropertyGrid(tbody:HTMLTableSectionElement){\r\n        return;\r\n    }\r\n\r\n    public OnSimulationStart(ctx:SimulationContext){\r\n        return;\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        return;\r\n    }\r\n\r\n    public OnSimulationStop(ctx:SimulationContext){\r\n        return;\r\n    }\r\n\r\n    \r\n    protected SerializeInputsAndOutputs(ctx:SerializeContextAndAdressMap)\r\n    {\r\n        for (const input of this.Inputs) {\r\n            let variableAdress = 0;\r\n            let links = input.GetLinksCopy();\r\n            if(links.length==0){\r\n                variableAdress=1; //because unconnected inputs read from adress 1 (which is \"false\", 0, 0.0, black...)\r\n            }\r\n            else{\r\n                let out = links[0].From;\r\n                variableAdress=ctx.typeIndex2globalConnectorIndex2adressOffset.get(out.Type)!.get(out.GlobalConnectorIndex)||1;\r\n            }\r\n            ctx.ctx.writeU32(variableAdress);\r\n        }\r\n        for(const output of this.Outputs)\r\n        {\r\n            let variableAdress = 0;\r\n            if(output.LinksLength==0){\r\n                variableAdress=0; //because unconnected outputs write to adress 0 (which is never read!)\r\n            }\r\n            else{\r\n                variableAdress=ctx.typeIndex2globalConnectorIndex2adressOffset.get(output.Type)!.get(output.GlobalConnectorIndex)||1;\r\n            }\r\n            ctx.ctx.writeU32(variableAdress);\r\n        }\r\n    }\r\n\r\n    public SerializeToBinary(ctx:SerializeContextAndAdressMap)\r\n    {\r\n        //serialize Type\r\n        ctx.ctx.writeU32(this.TypeInfo.GlobalTypeIndex);\r\n        //Index of instance\r\n        ctx.ctx.writeU32(this.GlobalOperatorIndex);\r\n        this.SerializeInputsAndOutputs(ctx);\r\n        this.SerializeFurtherProperties(ctx);\r\n    }\r\n    \r\n    protected SerializeFurtherProperties(mapper:SerializeContextAndAdressMap):void{\r\n        return;\r\n    }\r\n}\r\n","import {FlowchartOperator, TypeInfo, PositionType, SingletonType} from \"./FlowchartOperator\";\r\nimport {Flowchart} from \"./Flowchart\";\r\nimport {FlowchartInputConnector, FlowchartOutputConnector, ConnectorType} from \"./FlowchartConnector\";\r\nimport { SerializeContextAndAdressMap } from \"./FlowchartCompiler\";\r\nimport {$, KeyValueTuple} from \"../utils\";\r\nimport * as Song from \"./Songs\";\r\nimport { SimulationContext } from \"./SimulationContext\";\r\n\r\nconst Basic=\"Basic\";\r\nconst Arithmetic=\"Arithmetic\";\r\nconst Input=\"Input\";\r\nconst Sensor = \"Sensor\";\r\nconst Output=\"Output\";\r\nconst Converter=\"Converter\";\r\nconst Sound = \"Sound\";\r\nconst Control = \"Control\";\r\nconst Custom =\"Custom\";\r\n\r\nconst CONSTANT = \"Constant\";\r\nconst SONG_INDEX = \"Song Index\"\r\n\r\nexport class OperatorRegistry{\r\n    IsIndexKnown(globalTypeIndex: number) {\r\n        return this.index2Info.has(globalTypeIndex);\r\n    }\r\n    \r\n    private index2Info = new Map<number, TypeInfo>();\r\n    private groupName2operatorName2Info = new Map<string, Map<string, TypeInfo>>();\r\n    \r\n    private Register(globalTypeIndex:number, groupName:string, operatorName:string, position:PositionType, singleton:SingletonType, builder:(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null)=>FlowchartOperator)\r\n    {\r\n        let ti:TypeInfo=new TypeInfo(globalTypeIndex, groupName, operatorName, position, singleton, builder)\r\n        if(this.index2Info.has(globalTypeIndex)) throw new Error(`this.index2Info.has(globalTypeIndex) for ${groupName}::${operatorName}`);\r\n        this.index2Info.set(globalTypeIndex, ti);\r\n        if(!this.groupName2operatorName2Info.has(groupName)) this.groupName2operatorName2Info.set(groupName, new Map<string, TypeInfo>());\r\n        let operatorName2Info = this.groupName2operatorName2Info.get(groupName)!;\r\n        if(operatorName2Info.has(operatorName)) throw new Error(`operatorName2Info.has(operatorName) for ${groupName}::${operatorName}`);\r\n        operatorName2Info.set(operatorName, ti);\r\n    }\r\n\r\n    public CreateByIndex(index:number, parent: Flowchart, caption: string, configurationData:KeyValueTuple[]|null):FlowchartOperator|null\r\n    {\r\n        let ti=this.index2Info.get(index);\r\n        if(ti===undefined) return null;\r\n        return ti.Builder(parent, caption, ti, configurationData);\r\n    }\r\n\r\n    public GetTypeInfo(index:number):TypeInfo|null\r\n    {\r\n        let ti=this.index2Info.get(index);\r\n        if(ti===undefined) return null;\r\n        return ti;\r\n    }\r\n\r\n    public populateOperatorLib(parent: HTMLDivElement, onmousedownHandler: (e:MouseEvent, ti:TypeInfo)=>any) { \r\n        let y = 10;\r\n        let top = $.Html(parent, \"ul\", [], []);\r\n        for (const kv of this.groupName2operatorName2Info.entries()) {\r\n            let groupName = kv[0];\r\n            $.Html(top, \"li\", [], [], groupName);\r\n            let ul = $.Html(top, \"ul\", [], [\"nested\"]);\r\n            for (const info of kv[1].values()) {\r\n                let li = $.Html(ul, \"li\", [], [], info.OperatorName);\r\n                li.onmousedown = (e) => onmousedownHandler(e, info);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static Build():OperatorRegistry{\r\n        let r:OperatorRegistry = new OperatorRegistry();\r\n        r.Register(1, Basic, \"AND\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_ANDOperator(p, ca, ti, co));\r\n        r.Register(2, Basic, \"OR\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_OROperator(p, ca, ti, co));\r\n        r.Register(3, Basic, \"XOR\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_XOROperator(p, ca, ti, co));\r\n        r.Register(4, Basic, \"NOT\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_NotOperator(p, ca, ti, co));\r\n        r.Register(5, Basic, \"RS\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_RSOperator(p, ca, ti, co));\r\n        r.Register(6, Basic, \"SR\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_SROperator(p, ca, ti, co));\r\n        r.Register(7, Basic,\"ConstTRUE\", PositionType.Input, SingletonType.Default, (p, ca, ti, co)=>new Basic_ConstTRUEOperator(p, ca, ti, co));\r\n        r.Register(8, Basic,\"ConstFALSE\", PositionType.Input, SingletonType.Default, (p, ca, ti, co)=>new Basic_ConstFALSEOperator(p, ca, ti, co));\r\n        r.Register(9, Basic, \"CNT\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_CNTOperator(p, ca, ti, co));\r\n        r.Register(10, Basic, \"Timekeeper\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_TimekeeperOperator(p, ca, ti, co));\r\n        r.Register(11, Basic,\"TON\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_TONOperator(p, ca, ti, co));\r\n        r.Register(12, Basic,\"TOF\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Basic_TOFOperator(p, ca, ti, co));\r\n        \r\n        r.Register(13, Arithmetic, \"ADD\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_ADDOperator(p, ca, ti, co));\r\n        r.Register(14, Arithmetic, \"SUB\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_SUBOperator(p, ca, ti, co));\r\n        r.Register(15, Arithmetic, \"MULTIPLY\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_MULTIPLYOperator(p, ca, ti, co));\r\n        r.Register(16, Arithmetic, \"DIVIDE\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_DIVIDEOperator(p, ca, ti, co));\r\n        r.Register(17, Arithmetic, \"MAX\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_MAXOperator(p, ca, ti, co));\r\n        r.Register(18, Arithmetic, \"MIN\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_MINOperator(p, ca, ti, co));\r\n        r.Register(19, Arithmetic,\"GreaterThan\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_GreaterThanOperator(p, ca, ti, co));\r\n        r.Register(20, Arithmetic,\"LessThan\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_LessThanOperator(p, ca, ti, co));\r\n        r.Register(21, Arithmetic, \"ConstINT\", PositionType.Input, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_ConstINTOperator(p, ca, ti, co));\r\n        r.Register(22, Arithmetic, \"LIMIT\", PositionType.Input, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_LIMITOperator(p, ca, ti, co));\r\n        r.Register(23, Arithmetic, \"LIMITMONITOR\", PositionType.Input, SingletonType.Default, (p, ca, ti, co)=>new Arithmetic_LIMITMONITOROperator(p, ca, ti, co));\r\n\r\n        r.Register(24, Converter, \"Bool2Color\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Bool2ColorConvert(p, ca, ti, co));\r\n        r.Register(25, Converter, \"Bool2Int\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Bool2IntConvert(p, ca, ti, co));\r\n        r.Register(26, Converter, \"Int2Bool\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Int2BoolConvert(p, ca, ti, co));\r\n        r.Register(27, Converter, \"Int2Float\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Int2FloatConvert(p, ca, ti, co));\r\n        r.Register(28, Converter, \"Int2Color\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Int2ColorConvert(p, ca, ti, co));\r\n        r.Register(29, Converter, \"Float2Int\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Float2IntConvert(p, ca, ti, co));\r\n        \r\n        r.Register(30, Input, \"GreenButton\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Input_GreenButtonOperator(p, ca, ti, co));\r\n        r.Register(31, Input, \"EncoderButton\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Input_EncoderButtonOperator(p, ca, ti, co));\r\n        r.Register(32, Input, \"EncoderTicks\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Input_EncoderTicksOperator(p, ca, ti, co));\r\n        r.Register(33, Input, \"RedButton\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Input_RedButtonOperator(p, ca, ti, co));\r\n        \r\n        r.Register(34, Sensor, \"Movement\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_MovementOperator(p, ca, ti, co));\r\n        r.Register(35, Sensor, \"AirTemperatureDS18\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_AirTemperatureDS18Operator(p, ca, ti, co));\r\n        r.Register(36, Sensor, \"AirTemperatureBME\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_AirTemperatureBMEOperator(p, ca, ti, co));\r\n        r.Register(37, Sensor, \"AirHumidity\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_AirHumidityOperator(p, ca, ti, co));\r\n        r.Register(38, Sensor, \"AirPressure\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_AirPressureOperator(p, ca, ti, co));\r\n        r.Register(39, Sensor, \"AirCO2\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_AirCO2Operator(p, ca, ti, co));\r\n        r.Register(40, Sensor, \"AirQuality\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_AirQualityOperator(p, ca, ti, co));\r\n        r.Register(41, Sensor, \"AmbientBrightness\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_AmbientBrightnessOperator(p, ca, ti, co));\r\n        r.Register(42, Sensor, \"AmbientNoise\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_AmbientNoise(p, ca, ti, co));\r\n        r.Register(43, Sensor, \"ExternalPressure\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_ExternalPressure(p, ca, ti, co));\r\n        r.Register(44, Sensor, \"HeaterTemperature\", PositionType.Input, SingletonType.Singleton, (p, ca, ti, co)=>new Sensor_HeaterTemperatureOperator(p, ca, ti, co));\r\n        \r\n        r.Register(45, Output, \"Relay\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_RelayOperator(p, ca, ti, co));\r\n        r.Register(46, Output, \"RedLed\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_RedLedOperator(p, ca, ti, co));\r\n        r.Register(47, Output, \"YellowLed\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_YellowLedOperator(p, ca, ti, co));\r\n        r.Register(48, Output, \"GreenLed\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_GreenLedOperator(p, ca, ti, co));\r\n        r.Register(49, Output, \"LED3\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_Led3Operator(p, ca, ti, co));\r\n        r.Register(50, Output, \"LED4\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_Led4Operator(p, ca, ti, co));\r\n        r.Register(51, Output, \"LED5\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_Led5Operator(p, ca, ti, co));\r\n        r.Register(52, Output, \"LED6\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_Led6Operator(p, ca, ti, co));\r\n        r.Register(53, Output, \"LED7\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_Led7Operator(p, ca, ti, co));\r\n        r.Register(54, Output, \"Fan1\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_Fan1Operator(p, ca, ti, co));\r\n        r.Register(55, Output, \"Fan2\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_Fan2Operator(p, ca, ti, co));\r\n        r.Register(56, Output, \"PowerLed\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Output_PowerLedOperator(p, ca, ti, co));\r\n\r\n        r.Register(57, Sound, \"Melody\", PositionType.Output, SingletonType.Singleton, (p, ca, ti, co)=>new Sound_Melody(p, ca, ti, co));\r\n        \r\n        r.Register(58, Control, \"PID\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Control_PID(p, ca, ti, co));\r\n        \r\n        \r\n        r.Register(100, Custom, \"XYZXYZBlock\", PositionType.Default, SingletonType.Default, (p, ca, ti, co)=>new Custom_XYZBlock(p, ca, ti, co))\r\n        return r;\r\n    }\r\n}\r\n\r\nclass Sensor_CommonSensorOperator extends FlowchartOperator {\r\n    private sensorValue:number=0;\r\n    private O:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null, nameOfOutput:string, readonly minOutput:number, readonly maxOutput:number) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.O = new FlowchartOutputConnector(this, nameOfOutput, 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([], [this.O]);\r\n        this.ElementSvgG.onclick=(e)=>{\r\n            console.log(\"Input_CommonButtonOperator this.ElementSvgG.onclick\");\r\n            parent._notifyOperatorClicked(this, e);\r\n            this.sensorValue=this.sensorValue==this.minOutput?this.maxOutput:this.minOutput;\r\n        }\r\n    }\r\n    OnSimulationStart(ctx:SimulationContext){\r\n        this.sensorValue=this.minOutput;\r\n    }\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        ctx.SetInteger(this.O, this.sensorValue);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Sensor_HeaterTemperatureOperator extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"DegreesCelsius\", 25, 65);\r\n    }\r\n}\r\n\r\nexport class Sensor_AirTemperatureDS18Operator extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"Temperature*10\", 180, 250);\r\n    }\r\n}\r\n\r\nexport class Sensor_AirTemperatureBMEOperator extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"Temperature*10\", 180, 250);\r\n    }\r\n}\r\n\r\nexport class Sensor_AirHumidityOperator extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"RelHumid%\", 40, 60);\r\n    }\r\n}\r\nexport class Sensor_AirPressureOperator extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"Pa\", 800, 1200);\r\n    }\r\n}\r\n\r\nexport class Sensor_AirCO2Operator extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"CO2ppm\", 400, 1500);\r\n    }\r\n}\r\n\r\nexport class Sensor_AirQualityOperator extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"Quality%\", 20, 80);\r\n    }\r\n}\r\n\r\n\r\nexport class Sensor_AmbientBrightnessOperator extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"Lux\", 200, 700);\r\n    }\r\n}\r\n\r\nexport class Sensor_AmbientNoise extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"NoisedBA\", 30, 80);\r\n    }\r\n}\r\n\r\nexport class Sensor_ExternalPressure extends Sensor_CommonSensorOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"Pa\", 1000, 2000);\r\n    }\r\n}\r\n\r\n\r\nexport class Sensor_MovementOperator extends FlowchartOperator {\r\n    public StorageId:string;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        let O = new FlowchartOutputConnector(this, \"Movement\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([], [O]);\r\n        this.StorageId=\"4711\";\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nexport class Basic_ANDOperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.BOOLEAN);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.BOOLEAN);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetBoolean(this.A);\r\n        let B = ctx.GetBoolean(this.B);\r\n        ctx.SetBoolean(this.C, A && B);\r\n    }\r\n}\r\n\r\nexport class Basic_OROperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.BOOLEAN);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.BOOLEAN);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0,ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetBoolean(this.A);\r\n        let B = ctx.GetBoolean(this.B);\r\n        ctx.SetBoolean(this.C, A || B);\r\n    }\r\n}\r\n\r\nexport class Basic_XOROperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.BOOLEAN);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.BOOLEAN);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0,ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetBoolean(this.A);\r\n        let B = ctx.GetBoolean(this.B);\r\n        ctx.SetBoolean(this.C, A ? !B : B);\r\n    }\r\n}\r\n\r\nexport class Arithmetic_ADDOperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.INTEGER);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.INTEGER);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetInteger(this.A);\r\n        let B = ctx.GetInteger(this.B);\r\n        ctx.SetInteger(this.C, A + B);\r\n    }\r\n}\r\n\r\nexport class Arithmetic_SUBOperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.INTEGER);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.INTEGER);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetInteger(this.A);\r\n        let B = ctx.GetInteger(this.B);\r\n        ctx.SetInteger(this.C, A - B);\r\n    }\r\n}\r\n\r\n\r\nexport class Arithmetic_MULTIPLYOperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.INTEGER);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.INTEGER);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetInteger(this.A);\r\n        let B = ctx.GetInteger(this.B);\r\n        ctx.SetInteger(this.C, A * B);\r\n    }\r\n}\r\n\r\nexport class Arithmetic_DIVIDEOperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.INTEGER);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.INTEGER);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetInteger(this.A);\r\n        let B = ctx.GetInteger(this.B);\r\n        ctx.SetInteger(this.C, A / B);\r\n    }\r\n}\r\n\r\nexport class Arithmetic_MAXOperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.INTEGER);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.INTEGER);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetInteger(this.A);\r\n        let B = ctx.GetInteger(this.B);\r\n        ctx.SetInteger(this.C, Math.max(A,B));\r\n    }\r\n}\r\n\r\nexport class Arithmetic_MINOperator extends FlowchartOperator {\r\n    private A:FlowchartInputConnector;\r\n    private B:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.INTEGER);\r\n        this.B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.INTEGER);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.A, this.B], [this.C]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let A = ctx.GetInteger(this.A);\r\n        let B = ctx.GetInteger(this.B);\r\n        ctx.SetInteger(this.C, Math.min(A,B));\r\n    }\r\n}\r\n\r\nexport class Basic_RSOperator extends FlowchartOperator {\r\n    private R:FlowchartInputConnector;\r\n    private S:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    private state:boolean=false;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.R = new FlowchartInputConnector(this, \"R\", 0, ConnectorType.BOOLEAN);\r\n        this.S = new FlowchartInputConnector(this, \"S\", 1, ConnectorType.BOOLEAN);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.R, this.S], [this.C]);\r\n    }\r\n    OnSimulationStart(ctx:SimulationContext){\r\n        this.state=false;\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        if(ctx.GetBoolean(this.R)) this.state=false;\r\n        else if(ctx.GetBoolean(this.S)) this.state = true;\r\n        ctx.SetBoolean(this.C, this.state);\r\n    }\r\n}\r\n\r\nexport class Basic_SROperator extends FlowchartOperator {\r\n    private R:FlowchartInputConnector;\r\n    private S:FlowchartInputConnector;\r\n    private C:FlowchartOutputConnector;\r\n    private state:boolean=false;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.R = new FlowchartInputConnector(this, \"R\", 0, ConnectorType.BOOLEAN);\r\n        this.S = new FlowchartInputConnector(this, \"S\", 1, ConnectorType.BOOLEAN);\r\n        this.C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.R, this.S], [this.C]);\r\n    }\r\n    OnSimulationStart(ctx:SimulationContext){\r\n        this.state=false;\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        if(ctx.GetBoolean(this.S)) this.state = true;\r\n        else if(ctx.GetBoolean(this.R)) this.state=false;\r\n        ctx.SetBoolean(this.C, this.state);\r\n    }\r\n}\r\n\r\nexport class Basic_CNTOperator extends FlowchartOperator {\r\n    private CountUp:FlowchartInputConnector;\r\n    private Reset:FlowchartInputConnector;\r\n    private PresetValue:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    private CurrentValue:FlowchartOutputConnector;\r\n    private _CurrentValue:number=0;\r\n    private lastInputValue:boolean=false;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.CountUp = new FlowchartInputConnector(this, \"CU\", 0, ConnectorType.BOOLEAN);\r\n        this.Reset = new FlowchartInputConnector(this, \"Reset\", 1, ConnectorType.BOOLEAN);\r\n        this.PresetValue = new FlowchartInputConnector(this, \"PV\", 2, ConnectorType.INTEGER);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.BOOLEAN);\r\n        this.CurrentValue = new FlowchartOutputConnector(this, \"CV\", 1, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.CountUp, this.Reset, this.PresetValue], [this.OUT, this.CurrentValue]);\r\n    }\r\n    OnSimulationStart(ctx:SimulationContext){\r\n        this._CurrentValue=0;\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let currentInputValue = ctx.GetBoolean(this.CountUp);\r\n        let PV=ctx.GetInteger(this.PresetValue);\r\n        if(ctx.GetBoolean(this.Reset)){\r\n            this._CurrentValue=0;\r\n        }else if(this.lastInputValue==false && currentInputValue==true && this._CurrentValue<PV){\r\n            this._CurrentValue++;\r\n            console.log(\"Logic_CNTOperator this._CurrentValue++; \"+this._CurrentValue);\r\n        }\r\n        ctx.SetBoolean(this.OUT, this._CurrentValue>=PV);//kann auch durch Veränderung des PV passieren, deshalb nicht im if\r\n        ctx.SetInteger(this.CurrentValue, this._CurrentValue);\r\n        this.lastInputValue=currentInputValue\r\n    }\r\n}\r\n\r\n\r\nexport class Basic_TimekeeperOperator extends FlowchartOperator {\r\n    private CountUp:FlowchartInputConnector;\r\n    private Reset:FlowchartInputConnector;\r\n    private PresetValue:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    private CurrentValue:FlowchartOutputConnector;\r\n    private _CurrentValueMs:number=0;\r\n    private lastInputValue:boolean=false;\r\n    private lastMillis:number=0;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.CountUp = new FlowchartInputConnector(this, \"CU\", 0, ConnectorType.BOOLEAN);\r\n        this.Reset = new FlowchartInputConnector(this, \"Reset\", 1, ConnectorType.BOOLEAN);\r\n        this.PresetValue = new FlowchartInputConnector(this, \"PV_ms\", 2, ConnectorType.INTEGER);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.BOOLEAN);\r\n        this.CurrentValue = new FlowchartOutputConnector(this, \"CV_ms\", 1, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.CountUp, this.Reset, this.PresetValue], [this.OUT, this.CurrentValue]);\r\n    }\r\n    OnSimulationStart(ctx:SimulationContext){\r\n        this._CurrentValueMs=0;\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let currentInputValue = ctx.GetBoolean(this.CountUp);\r\n        let PV=ctx.GetInteger(this.PresetValue);\r\n        if(ctx.GetBoolean(this.Reset)){\r\n            this._CurrentValueMs=0;\r\n            this.lastMillis=ctx.GetMillis();\r\n        }else if(this.lastInputValue==false && currentInputValue==true && this._CurrentValueMs<PV){\r\n            let now = ctx.GetMillis();\r\n            this._CurrentValueMs+=now-this.lastMillis;\r\n            this.lastMillis=now;\r\n            console.log(\"Logic_CNTOperator this._CurrentValue++; \"+this._CurrentValueMs);\r\n        }\r\n        ctx.SetBoolean(this.OUT, this._CurrentValueMs>=PV);//kann auch durch Veränderung des PV passieren, deshalb nicht im if\r\n        ctx.SetInteger(this.CurrentValue, this._CurrentValueMs);\r\n        this.lastInputValue=currentInputValue\r\n    }\r\n}\r\n\r\nexport class Basic_NotOperator extends FlowchartOperator {\r\n    private IN:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.IN = new FlowchartInputConnector(this, \"IN\", 0, ConnectorType.BOOLEAN);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.IN], [this.OUT]);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        ctx.SetBoolean(this.OUT, !ctx.GetBoolean(this.IN));\r\n    }\r\n\r\n}\r\nclass Input_CommonButtonOperator extends FlowchartOperator {\r\n    private state:boolean=false;\r\n    private O:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.O = new FlowchartOutputConnector(this, \"IsPressed\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([], [this.O]);\r\n        this.ElementSvgG.onclick=(e)=>{\r\n            console.log(\"Input_CommonButtonOperator this.ElementSvgG.onclick\");\r\n            parent._notifyOperatorClicked(this, e);\r\n            this.state=!this.state;\r\n        }\r\n    }\r\n\r\n    OnSimulationStart(ctx:SimulationContext){\r\n        this.state=false;\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        this.box.classList.remove(this.state?\"False\":\"True\");\r\n        this.box.classList.add(this.state?\"True\":\"False\");\r\n        ctx.SetBoolean(this.O, this.state);\r\n    }\r\n\r\n    OnSimulationStop(ctx:SimulationContext){\r\n        this.box.classList.remove(\"False\", \"True\");\r\n    }\r\n}\r\n\r\n\r\nexport class Input_GreenButtonOperator extends Input_CommonButtonOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n    }\r\n}\r\n\r\nexport class Input_EncoderButtonOperator extends Input_CommonButtonOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n    }\r\n}\r\n\r\nexport class Input_RedButtonOperator extends Input_CommonButtonOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n    }\r\n}\r\n\r\nexport class Input_EncoderTicksOperator extends FlowchartOperator {\r\n    public StorageId:string;\r\n    protected O:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.O = new FlowchartOutputConnector(this, \"Ticks\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([], [this.O]);\r\n        this.StorageId=\"4711\";\r\n    }\r\n\r\n    public OnSimulationStart(ctx: SimulationContext): void {\r\n        ctx.SetInteger(this.O, 1000);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport class Output_RelayOperator extends FlowchartOperator {\r\n    private I:FlowchartInputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.I=new FlowchartInputConnector(this, \"Relay\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.I], []);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let state = ctx.GetBoolean(this.I);\r\n        this.box.classList.remove(state?\"False\":\"True\");\r\n        this.box.classList.add(state?\"True\":\"False\");\r\n    }\r\n}\r\n\r\nexport class Output_Fan1Operator extends FlowchartOperator {\r\n    private I:FlowchartInputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.I=new FlowchartInputConnector(this, \"Power%\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.I], []);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let state = ctx.GetInteger(this.I);\r\n        this.box.innerHTML=state+\"%\";\r\n    }\r\n}\r\n\r\nexport class Output_Fan2Operator extends FlowchartOperator {\r\n    private I:FlowchartInputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.I=new FlowchartInputConnector(this, \"Power%\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.I], []);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let state = ctx.GetInteger(this.I);\r\n        this.box.innerHTML=state+\"%\";\r\n    }\r\n}\r\n\r\nexport class Output_PowerLedOperator extends FlowchartOperator {\r\n    private I:FlowchartInputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.I=new FlowchartInputConnector(this, \"Power%\", 0, ConnectorType.FLOAT);\r\n        this.AppendConnectors([this.I], []);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let state = ctx.GetFloat(this.I);\r\n        this.box.innerHTML=state+\"%\";\r\n    }\r\n}\r\n\r\n\r\nclass Output_CommonLedOperator extends FlowchartOperator {\r\n    protected  I:FlowchartInputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null, protected colorOnTRUE:string, protected colorOnFALSE:string) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.I = new FlowchartInputConnector(this, \"LED\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.I], []);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        let state = ctx.GetBoolean(this.I);\r\n        this.box.style.fill=state?this.colorOnTRUE:this.colorOnFALSE;\r\n    }\r\n\r\n    OnSimulationStop(ctx:SimulationContext){\r\n        this.box.style.removeProperty(\"fill\");\r\n    }\r\n}\r\n\r\n\r\nexport class Output_RedLedOperator extends Output_CommonLedOperator {\r\n\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"red\", \"grey\");\r\n    }\r\n}\r\n\r\nexport class Output_YellowLedOperator extends Output_CommonLedOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"yellow\", \"grey\");\r\n    }\r\n}\r\n\r\nexport class Output_GreenLedOperator extends Output_CommonLedOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData, \"green\", \"grey\");\r\n    }\r\n}\r\n\r\nexport class Output_CommonRGBLedOperator extends FlowchartOperator {\r\n    protected LED:FlowchartInputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.LED = new FlowchartInputConnector(this, \"LED\", 0, ConnectorType.COLOR);\r\n        this.AppendConnectors([this.LED], []);\r\n    }\r\n\r\n    OnSimulationStep(ctx:SimulationContext){\r\n        this.box.style.fill=ctx.GetColor(this.LED);\r\n    }\r\n\r\n    OnSimulationStop(ctx:SimulationContext){\r\n        this.box.style.removeProperty(\"fill\");\r\n    }\r\n}\r\n\r\nexport class Output_Led3Operator extends Output_CommonRGBLedOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n    }\r\n}\r\n\r\nexport class Output_Led4Operator extends Output_CommonRGBLedOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n    }\r\n}\r\n\r\nexport class Output_Led5Operator extends Output_CommonRGBLedOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n    }\r\n}\r\n\r\nexport class Output_Led6Operator extends Output_CommonRGBLedOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n    }\r\n}\r\n\r\nexport class Output_Led7Operator extends Output_CommonRGBLedOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n    }\r\n}\r\n\r\nexport class Basic_ConstTRUEOperator extends FlowchartOperator {\r\n    protected O:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.O = new FlowchartOutputConnector(this, \"TRUE\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([], [this.O]);\r\n    }\r\n\r\n    OnSimulationStart(ctx:SimulationContext){\r\n        ctx.SetBoolean(this.O, false);\r\n    }\r\n}\r\n\r\nexport class Basic_ConstFALSEOperator extends FlowchartOperator {\r\n\r\n    protected O:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.O = new FlowchartOutputConnector(this, \"TRUE\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([], [this.O]);\r\n    }\r\n\r\n    OnSimulationStart(ctx:SimulationContext){\r\n        ctx.SetBoolean(this.O, true);\r\n    }\r\n}\r\n\r\nexport class Sound_Melody extends FlowchartOperator {\r\n  \r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        let A = new FlowchartInputConnector(this, \"Trigger\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([A], []);\r\n        this.cfg_setDefault(SONG_INDEX, 0);\r\n    }\r\n\r\n    private songIndexHTMLSelect:HTMLSelectElement|null=null;\r\n    public PopulateProperyGrid(tbody:HTMLTableSectionElement):boolean\r\n    {\r\n        this.songIndexHTMLSelect=$.InputSelect(tbody, Song.default(), SONG_INDEX, this.configurationData);\r\n        return true;\r\n    }\r\n\r\n    public SavePropertyGrid(tbody:HTMLTableSectionElement){\r\n        if(this.songIndexHTMLSelect==null) return;\r\n        this.cfg_setValue(SONG_INDEX, parseInt(this.songIndexHTMLSelect.value));\r\n    }\r\n\r\n    protected SerializeFurtherProperties(ctx:SerializeContextAndAdressMap):void{\r\n        ctx.ctx.writeS32(this.cfg_getValue(SONG_INDEX, 0));\r\n        return;\r\n    }\r\n}\r\n\r\nexport class Arithmetic_ConstINTOperator extends FlowchartOperator {\r\n    private O:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.O = new FlowchartOutputConnector(this, \"Out\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([], [this.O]);\r\n        this.cfg_setDefault(CONSTANT, 0);\r\n    }\r\n\r\n    private constantHTMLInput:HTMLInputElement|null=null;\r\n    public PopulateProperyGrid(tbody:HTMLTableSectionElement):boolean\r\n    {\r\n        this.constantHTMLInput=$.InputNumber(tbody, -32768, 32767, CONSTANT, this.configurationData);\r\n        return true;\r\n    }\r\n\r\n    public SavePropertyGrid(tbody:HTMLTableSectionElement){\r\n        if(this.constantHTMLInput==null) return;\r\n        this.cfg_setValue(CONSTANT, this.constantHTMLInput.valueAsNumber);\r\n    }\r\n\r\n    protected SerializeFurtherProperties(ctx:SerializeContextAndAdressMap):void{\r\n        ctx.ctx.writeS32(this.cfg_getValue(CONSTANT, 0));\r\n        return;\r\n    }\r\n\r\n    public OnSimulationStart(ctx:SimulationContext){\r\n        ctx.SetInteger(this.O, this.cfg_getValue(CONSTANT, 0));\r\n    }\r\n\r\n}\r\n\r\n\r\nconst COLOR_TRUE=\"Color for TRUE\";\r\nconst COLOR_FALSE=\"Color for FALSE\";\r\n\r\nexport class Bool2ColorConvert extends FlowchartOperator {\r\n    private IN:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.IN = new FlowchartInputConnector(this, \"IN\", 0, ConnectorType.BOOLEAN);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.COLOR);\r\n        this.AppendConnectors([this.IN], [this.OUT]);\r\n    }\r\n\r\n    private colorTRUEHTMLInput:HTMLInputElement|null=null;\r\n    private colorFALSEHTMLInput:HTMLInputElement|null=null;\r\n    \r\n    public PopulateProperyGrid(tbody:HTMLTableSectionElement):boolean\r\n    {\r\n        this.colorTRUEHTMLInput=$.InputColor(tbody, COLOR_TRUE, this.configurationData);\r\n        this.colorFALSEHTMLInput=$.InputColor(tbody, COLOR_FALSE, this.configurationData);\r\n        return true;\r\n    }\r\n\r\n    public SavePropertyGrid(tbody:HTMLTableSectionElement){\r\n        if(this.colorTRUEHTMLInput==null || this.colorFALSEHTMLInput==null) return;\r\n        this.cfg_setValue(COLOR_TRUE, this.colorTRUEHTMLInput.value);\r\n        this.cfg_setValue(COLOR_FALSE, this.colorFALSEHTMLInput.value);\r\n    }\r\n\r\n    protected SerializeFurtherProperties(ctx:SerializeContextAndAdressMap):void{\r\n        let colorString = this.cfg_getValue(COLOR_TRUE, \"#ff0000\");\r\n        let colorNum=$.ColorDomString2ColorNum(colorString);\r\n        ctx.ctx.writeU32(colorNum);\r\n        colorString = this.cfg_getValue(COLOR_FALSE, \"#000000\");\r\n        colorNum=$.ColorDomString2ColorNum(colorString);\r\n        ctx.ctx.writeU32(colorNum);\r\n        return;\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        let currentInputValue = ctx.GetBoolean(this.IN);\r\n        let color =currentInputValue?this.cfg_getValue(COLOR_TRUE, \"RED\"):this.cfg_getValue(COLOR_FALSE, \"GREY\");\r\n        ctx.SetColor(this.OUT, color);\r\n    }\r\n}\r\n\r\nconst NUMBER_TRUE=\"Number for TRUE\";\r\nconst NUMBER_FALSE=\"Number for FALSE\";\r\n\r\nexport class Bool2IntConvert extends FlowchartOperator {\r\n    private IN:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    private numberTRUEHTMLInput:HTMLInputElement|null=null;\r\n    private numberFALSEHTMLInput:HTMLInputElement|null=null;\r\n    \r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.IN = new FlowchartInputConnector(this, \"IN\", 0, ConnectorType.BOOLEAN);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.IN], [this.OUT]);\r\n    }\r\n\r\n    public PopulateProperyGrid(tbody:HTMLTableSectionElement):boolean\r\n    {\r\n        this.numberTRUEHTMLInput=$.InputNumber(tbody, Number.MIN_VALUE, Number.MAX_VALUE, NUMBER_TRUE, this.configurationData);\r\n        this.numberFALSEHTMLInput=$.InputNumber(tbody, Number.MIN_VALUE, Number.MAX_VALUE, NUMBER_FALSE, this.configurationData);\r\n        return true;\r\n    }\r\n\r\n    public SavePropertyGrid(tbody:HTMLTableSectionElement){\r\n        if(this.numberFALSEHTMLInput==null || this.numberTRUEHTMLInput==null) return;\r\n        this.cfg_setValue(NUMBER_TRUE, this.numberTRUEHTMLInput.valueAsNumber);\r\n        this.cfg_setValue(NUMBER_FALSE, this.numberFALSEHTMLInput.valueAsNumber);\r\n    }\r\n\r\n    protected SerializeFurtherProperties(ctx:SerializeContextAndAdressMap):void{\r\n        ctx.ctx.writeS32(this.cfg_getValue(NUMBER_TRUE, 1));\r\n        ctx.ctx.writeS32(this.cfg_getValue(NUMBER_FALSE, 0));\r\n        return;\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        let i = ctx.GetBoolean(this.IN);\r\n        ctx.SetInteger(this.OUT, i?this.cfg_getValue(NUMBER_TRUE, 1):this.cfg_getValue(NUMBER_FALSE, 0));\r\n    }\r\n}\r\n\r\nexport class Int2BoolConvert extends FlowchartOperator {\r\n    private IN:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    \r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.IN = new FlowchartInputConnector(this, \"IN\", 0, ConnectorType.INTEGER);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.IN], [this.OUT]);\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        let i = ctx.GetInteger(this.IN);\r\n        ctx.SetBoolean(this.OUT, i!=0);\r\n    }\r\n}\r\n\r\nexport class Int2FloatConvert extends FlowchartOperator {\r\n    private IN:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    \r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.IN = new FlowchartInputConnector(this, \"IN\", 0, ConnectorType.INTEGER);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.FLOAT);\r\n        this.AppendConnectors([this.IN], [this.OUT]);\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        let i = ctx.GetInteger(this.IN);\r\n        ctx.SetFloat(this.OUT, i);\r\n    }\r\n}\r\n\r\n\r\nexport class Int2ColorConvert extends FlowchartOperator {\r\n    private IN:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    \r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.IN = new FlowchartInputConnector(this, \"IN\", 0, ConnectorType.INTEGER);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.COLOR);\r\n        this.AppendConnectors([this.IN], [this.OUT]);\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        let currentInputValue = ctx.GetInteger(this.IN);\r\n        ctx.SetColor(this.OUT, currentInputValue?\"RED\": \"GREY\");//TODO: Has to be improved\r\n    }\r\n}\r\n\r\nexport class Float2IntConvert extends FlowchartOperator {\r\n    private IN:FlowchartInputConnector;\r\n    private OUT:FlowchartOutputConnector;\r\n    \r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.IN = new FlowchartInputConnector(this, \"IN\", 0, ConnectorType.FLOAT);\r\n        this.OUT = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.IN], [this.OUT]);\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        let i = ctx.GetFloat(this.IN);\r\n        ctx.SetInteger(this.OUT, i);\r\n    }\r\n}\r\n\r\nexport class Basic_TONOperator extends FlowchartOperator {\r\n    private inputTRIGGER:FlowchartInputConnector;\r\n    private inputPresetTime_msecs:FlowchartInputConnector;\r\n    private output:FlowchartOutputConnector;\r\n    private outputElapsedTime_msecs:FlowchartOutputConnector;\r\n    private lastInputValue:boolean=false;\r\n    private inputPositiveEdge:number = Number.MAX_VALUE;\r\n    \r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.inputTRIGGER = new FlowchartInputConnector(this, \"TRIGGER\", 0, ConnectorType.BOOLEAN);\r\n        this.inputPresetTime_msecs = new FlowchartInputConnector(this, \"PT_MS\", 1, ConnectorType.INTEGER);\r\n        this.output = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.BOOLEAN);\r\n        this.outputElapsedTime_msecs = new FlowchartOutputConnector(this, \"ET_MS\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.inputTRIGGER, this.inputPresetTime_msecs], [this.output,this.outputElapsedTime_msecs]);\r\n    }\r\n\r\n    public OnSimulationStart(ctx:SimulationContext){\r\n        this.inputPositiveEdge = Number.MAX_VALUE;\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        let currentInputValue = ctx.GetBoolean(this.inputTRIGGER);\r\n        let presetTime_msecs = ctx.GetInteger(this.inputPresetTime_msecs);\r\n        let now = ctx.GetMillis();\r\n        if(this.lastInputValue==false && currentInputValue==true){\r\n            this.inputPositiveEdge=now;\r\n        }\r\n        else if(currentInputValue==false){\r\n            this.inputPositiveEdge=Number.MAX_VALUE;\r\n        }\r\n        this.lastInputValue=currentInputValue;\r\n        let elapsed = (now-this.inputPositiveEdge);\r\n        ctx.SetBoolean(this.output, elapsed>=presetTime_msecs);\r\n        ctx.SetInteger(this.outputElapsedTime_msecs, elapsed);\r\n    }\r\n}\r\n\r\nexport class Basic_TOFOperator extends FlowchartOperator {\r\n  \r\n    private inputTRIGGER:FlowchartInputConnector;\r\n    private inputPresetTime_msecs:FlowchartInputConnector;\r\n    private output:FlowchartOutputConnector;\r\n    private outputElapsedTime_msecs:FlowchartOutputConnector;\r\n    private lastInputValue:boolean=false;\r\n    private inputNegativeEdge:number = 0;\r\n    \r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.inputTRIGGER = new FlowchartInputConnector(this, \"TRIGGER\", 0, ConnectorType.BOOLEAN);\r\n        this.inputPresetTime_msecs = new FlowchartInputConnector(this, \"PT_MS\", 1, ConnectorType.INTEGER);\r\n        this.output = new FlowchartOutputConnector(this, \"OUT\", 0, ConnectorType.BOOLEAN);\r\n        this.outputElapsedTime_msecs = new FlowchartOutputConnector(this, \"ET_MS\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.inputTRIGGER, this.inputPresetTime_msecs], [this.output,this.outputElapsedTime_msecs]);\r\n    }\r\n\r\n    public OnSimulationStart(ctx:SimulationContext){\r\n        this.inputNegativeEdge = 0;\r\n    }\r\n\r\n    public OnSimulationStep(ctx:SimulationContext){\r\n        let currentInputValue = ctx.GetBoolean(this.inputTRIGGER);\r\n        let presetTime_msecs = ctx.GetInteger(this.inputPresetTime_msecs);\r\n        let now = ctx.GetMillis();\r\n        if(this.lastInputValue==true && currentInputValue==false){\r\n            this.inputNegativeEdge=now;\r\n        }\r\n        else if(currentInputValue==true){\r\n            this.inputNegativeEdge=0;\r\n        }\r\n        this.lastInputValue=currentInputValue;\r\n        let elapsed = (now-this.inputNegativeEdge);\r\n        elapsed=Math.min(elapsed, presetTime_msecs)\r\n        ctx.SetBoolean(this.output, currentInputValue || (elapsed<presetTime_msecs));\r\n        ctx.SetInteger(this.outputElapsedTime_msecs, elapsed);\r\n    }\r\n}\r\n\r\n\r\nexport class Arithmetic_LIMITOperator extends FlowchartOperator {\r\n    protected Minimum:FlowchartInputConnector;\r\n    protected Input:FlowchartInputConnector;\r\n    protected Maximum:FlowchartInputConnector;\r\n    protected Output:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.Minimum = new FlowchartInputConnector(this, \"Minimum\", 0, ConnectorType.INTEGER);\r\n        this.Input = new FlowchartInputConnector(this, \"Input\", 1, ConnectorType.INTEGER);\r\n        this.Maximum = new FlowchartInputConnector(this, \"Maximum\", 2, ConnectorType.INTEGER);\r\n        this.Output = new FlowchartOutputConnector(this, \"Output\", 0, ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.Minimum, this.Input, this.Maximum], [this.Output]);\r\n    }\r\n\r\n    public OnSimulationStep(ctx: SimulationContext): void {\r\n        let i = ctx.GetInteger(this.Input);\r\n        let min = ctx.GetInteger(this.Minimum);\r\n        let max = ctx.GetInteger(this.Minimum);\r\n        ctx.SetInteger(this.Output, i>max?max:i<min?min:i);\r\n    }\r\n}\r\n\r\nexport class Arithmetic_LIMITMONITOROperator extends FlowchartOperator {\r\n    protected Minimum:FlowchartInputConnector;\r\n    protected Input:FlowchartInputConnector;\r\n    protected Maximum:FlowchartInputConnector;\r\n    protected Hysterese:FlowchartInputConnector;\r\n    protected LLE:FlowchartOutputConnector;\r\n    protected ULE:FlowchartOutputConnector;\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.Minimum = new FlowchartInputConnector(this, \"Minimum\", 0, ConnectorType.INTEGER);\r\n        this.Input = new FlowchartInputConnector(this, \"Input\", 1, ConnectorType.INTEGER);\r\n        this.Maximum = new FlowchartInputConnector(this, \"Maximum\", 2, ConnectorType.INTEGER);\r\n        this.Hysterese = new FlowchartInputConnector(this, \"Hysterese\", 3, ConnectorType.INTEGER);\r\n        this.LLE = new FlowchartOutputConnector(this, \"LLE\", 0, ConnectorType.BOOLEAN);\r\n        this.ULE = new FlowchartOutputConnector(this, \"ULE\", 1, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([this.Minimum, this.Input, this.Maximum], [this.LLE, this.ULE]);\r\n    }\r\n\r\n    public OnSimulationStep(ctx: SimulationContext): void {\r\n        let i = ctx.GetInteger(this.Input);\r\n        let min = ctx.GetInteger(this.Minimum);\r\n        let max = ctx.GetInteger(this.Minimum);\r\n        let h = ctx.GetInteger(this.Hysterese);\r\n        if(i>max){\r\n            ctx.SetBoolean(this.ULE, true);\r\n        }else if(i<=max-h){\r\n            ctx.SetBoolean(this.ULE, false);\r\n        }\r\n        if(i<min){\r\n            ctx.SetBoolean(this.LLE, true);\r\n        } else if(i>=min+h){\r\n            ctx.SetBoolean(this.LLE, false);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport class Arithmetic_GreaterThanOperator extends FlowchartOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        let A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.INTEGER);\r\n        let B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.INTEGER);\r\n        let C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([A, B], [C]);\r\n    }\r\n}\r\n\r\nexport class Arithmetic_LessThanOperator extends FlowchartOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        let A = new FlowchartInputConnector(this, \"A\", 0, ConnectorType.INTEGER);\r\n        let B = new FlowchartInputConnector(this, \"B\", 1, ConnectorType.INTEGER);\r\n        let C = new FlowchartOutputConnector(this, \"C\", 0, ConnectorType.BOOLEAN);\r\n        this.AppendConnectors([A, B], [C]);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Custom_XYZBlock extends FlowchartOperator {\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        let A = new FlowchartInputConnector(this, \"TempVL\", 0, ConnectorType.INTEGER);\r\n        let B = new FlowchartInputConnector(this, \"TempRL\", 1, ConnectorType.INTEGER);\r\n        let B1 = new FlowchartInputConnector(this, \"Switch\", 2, ConnectorType.BOOLEAN);\r\n        let C = new FlowchartOutputConnector(this, \"Motor\", 0,ConnectorType.BOOLEAN);\r\n        let C1 = new FlowchartOutputConnector(this, \"Valve\", 1,ConnectorType.INTEGER);\r\n        this.AppendConnectors([A, B, B1], [C, C1]);\r\n    }\r\n\r\n    private value1HTMLInput:HTMLInputElement|null=null;\r\n    private value2HTMLInput:HTMLInputElement|null=null;\r\n    private value3HTMLInput:HTMLInputElement|null=null;\r\n    private color1HTMLInput:HTMLInputElement|null=null;\r\n    public PopulateProperyGrid(tbody:HTMLTableSectionElement):boolean\r\n    {\r\n        this.value1HTMLInput=$.InputNumber(tbody, -32768, 32767, \"Value1\", this.configurationData);\r\n        this.value1HTMLInput=$.InputNumber(tbody, -32768, 32767, \"Value2\", this.configurationData);\r\n        this.value1HTMLInput=$.InputNumber(tbody, -32768, 32767, \"Value3\", this.configurationData);\r\n        this.color1HTMLInput=$.InputColor(tbody, \"Color1\", this.configurationData);\r\n        return true;\r\n    }\r\n\r\n    public SavePropertyGrid(tbody:HTMLTableSectionElement){\r\n        this.cfg_setValue(\"Value1\", this.value1HTMLInput!.valueAsNumber);\r\n        this.cfg_setValue(\"Value2\", this.value2HTMLInput!.valueAsNumber);\r\n        this.cfg_setValue(\"Value3\", this.value3HTMLInput!.valueAsNumber);\r\n        this.cfg_setValue(\"Color1\", this.color1HTMLInput!.valueAsNumber);\r\n    }\r\n\r\n    protected SerializeFurtherProperties(ctx:SerializeContextAndAdressMap):void{\r\n        ctx.ctx.writeS32(this.cfg_getValue(\"Value1\", 0));\r\n        ctx.ctx.writeS32(this.cfg_getValue(\"Value2\", 0));\r\n        ctx.ctx.writeS32(this.cfg_getValue(\"Value3\", 0));\r\n        let colorString = this.cfg_getValue(\"Color1\", \"#000000\");\r\n        let colorNum=$.ColorDomString2ColorNum(colorString);\r\n        ctx.ctx.writeU32(colorNum);\r\n        return;\r\n    }\r\n}\r\n\r\nexport class Control_PID extends FlowchartOperator {\r\n    private inputActualValue:FlowchartInputConnector;\r\n    private inputSetpoint:FlowchartInputConnector;\r\n    private inputKP:FlowchartInputConnector;\r\n    private inputKI:FlowchartInputConnector;\r\n    private inputKD:FlowchartInputConnector;\r\n    private output:FlowchartOutputConnector;\r\n\r\n\r\n    constructor(parent: Flowchart, caption: string, ti:TypeInfo, configurationData:KeyValueTuple[]|null) {\r\n        super(parent, caption, ti, configurationData);\r\n        this.inputActualValue = new FlowchartInputConnector(this, \"Actual\", 0, ConnectorType.FLOAT);\r\n        this.inputSetpoint = new FlowchartInputConnector(this, \"Setpoint\", 1, ConnectorType.FLOAT);\r\n        this.inputKP= new FlowchartInputConnector(this, \"KP\", 2, ConnectorType.FLOAT);\r\n        this.inputKI= new FlowchartInputConnector(this, \"KI\", 3, ConnectorType.FLOAT);\r\n        this.inputKD= new FlowchartInputConnector(this, \"KD\", 4, ConnectorType.FLOAT);\r\n        this.output = new FlowchartOutputConnector(this, \"Out\", 1,ConnectorType.INTEGER);\r\n        this.AppendConnectors([this.inputActualValue, this.inputSetpoint, this.inputKP, this.inputKI, this.inputKD], [this.output]);\r\n    }\r\n}","\r\nexport class SerializeContext {\r\n    public writeGUID(guid: Uint8Array) {\r\n        for (let i = 0; i < 16; i++) {\r\n            this.bufferDV.setUint8(this.bufferOffset + i, guid[i]);\r\n        }\r\n        this.bufferOffset += 16;\r\n    }\r\n\r\n    public consumeGUIDandCompare(compare:Uint8Array): boolean {\r\n        let val=true;\r\n        for (let i = 0; i < 16; i++) {\r\n            if(compare[i]!=this.bufferDV.getUint8(this.bufferOffset + i)){\r\n                val=false;\r\n                break;\r\n            }\r\n        }\r\n        this.bufferOffset += 16;\r\n        return val;\r\n    }\r\n    private bufferDV: DataView;\r\n    constructor(private buffer: ArrayBuffer, private bufferOffset: number = 0) {\r\n        this.bufferDV = new DataView(buffer);\r\n    }\r\n\r\n    public funhash(start:number, end:number):number{\r\n        end=Math.min(end, this.bufferDV.byteLength);\r\n        for(var i = start, h = 0xdeadbeef; i < end; i++)\r\n            h = Math.imul(h ^ this.bufferDV.getUint8(i), 2654435761);\r\n        return (h ^ h >>> 16) >>> 0;\r\n    }\r\n\r\n    public overwriteU32(theNumber: number, offset:number): void {\r\n        if(offset>this.bufferOffset-4) throw new Error(\"offset>this.bufferOffset-4\");\r\n        this.bufferDV.setUint32(offset, theNumber, true);\r\n    }\r\n    public writeS32(theNumber: number): void {\r\n        this.bufferDV.setInt32(this.bufferOffset, theNumber, true);\r\n        this.bufferOffset += 4;\r\n    }\r\n\r\n    public writeU32(theNumber: number): void {\r\n        this.bufferDV.setUint32(this.bufferOffset, theNumber, true);\r\n        this.bufferOffset += 4;\r\n    }\r\n\r\n    public writeF32(theNumber: number): void {\r\n        this.bufferDV.setFloat32(this.bufferOffset, theNumber, true);\r\n        this.bufferOffset += 4;\r\n    }\r\n\r\n    public readF32(): number {\r\n        let val = this.bufferDV.getFloat32(this.bufferOffset, true);\r\n        this.bufferOffset += 4;\r\n        return val;\r\n    }\r\n\r\n    public readU32(): number {\r\n        let val = this.bufferDV.getUint32(this.bufferOffset, true);\r\n        this.bufferOffset += 4;\r\n        return val;\r\n    }\r\n\r\n    public readS32(): number {\r\n        let val = this.bufferDV.getInt32(this.bufferOffset, true);\r\n        this.bufferOffset += 4;\r\n        return val;\r\n    }\r\n\r\n    public getResult(): ArrayBuffer {\r\n        return this.buffer.slice(0, this.bufferOffset);\r\n    }\r\n}\r\n","import { HashAndBufAndMaps, SortedOperatorsAndMaps } from \"./FlowchartCompiler\";\r\nimport { FlowchartInputConnector, FlowchartOutputConnector } from \"./FlowchartConnector\";\r\nimport { FlowchartOperator } from \"./FlowchartOperator\";\r\nimport { SimulationContext } from \"./SimulationContext\";\r\n\r\nexport class SimulationManager implements SimulationContext{\r\n    private booleans!: boolean[];\r\n    private integers!:number[];\r\n    private floats!:number[];\r\n    private colors!:string[];\r\n    private millisSince1970!:number;\r\n    private running:boolean=false;\r\n\r\n    constructor(private sortedOperatorsAndMaps: SortedOperatorsAndMaps){\r\n        this.resetDatastructures()!;\r\n    }\r\n\r\n    private resetDatastructures(){\r\n        this.booleans =new Array(this.sortedOperatorsAndMaps.typeIndex2maxOffset.get(0));\r\n        this.integers  = new Array(this.sortedOperatorsAndMaps.typeIndex2maxOffset.get(1));\r\n        this.floats  = new Array(this.sortedOperatorsAndMaps.typeIndex2maxOffset.get(2));\r\n        this.colors  = new Array(this.sortedOperatorsAndMaps.typeIndex2maxOffset.get(3));\r\n        this.millisSince1970=Date.now();\r\n    }\r\n\r\n\r\n    SetBoolean(outConn: FlowchartOutputConnector, value: boolean): void {\r\n        let i = this.sortedOperatorsAndMaps.typeIndex2globalConnectorIndex2adressOffset.get(0)!.get(outConn.GlobalConnectorIndex)!;\r\n        this.booleans[i]=value;\r\n    }\r\n    SetInteger(outConn: FlowchartOutputConnector, value: number): void {\r\n        let i = this.sortedOperatorsAndMaps.typeIndex2globalConnectorIndex2adressOffset.get(1)!.get(outConn.GlobalConnectorIndex)!;\r\n        this.integers[i]=value;\r\n    }\r\n    SetFloat(outConn: FlowchartOutputConnector, value: number): void {\r\n        let i = this.sortedOperatorsAndMaps.typeIndex2globalConnectorIndex2adressOffset.get(2)!.get(outConn.GlobalConnectorIndex)!;\r\n        this.floats[i]=value;\r\n    }\r\n    SetColor(outConn: FlowchartOutputConnector, value: string): void {\r\n        let i = this.sortedOperatorsAndMaps.typeIndex2globalConnectorIndex2adressOffset.get(3)!.get(outConn.GlobalConnectorIndex)!;\r\n        this.colors[i]=value;\r\n    }\r\n    GetBoolean(inConn: FlowchartInputConnector): boolean {\r\n        \r\n        let i = this.sortedOperatorsAndMaps.typeIndex2globalConnectorIndex2adressOffset.get(0)!.get(inConn.GetGlobalConnectorIndexOfSignalSource())!;\r\n        return this.booleans[i];\r\n    }\r\n    GetInteger(inConn: FlowchartInputConnector): number {\r\n        let i = this.sortedOperatorsAndMaps.typeIndex2globalConnectorIndex2adressOffset.get(1)!.get(inConn.GetGlobalConnectorIndexOfSignalSource())!;\r\n        return this.integers[i];\r\n    }\r\n    GetFloat(inConn: FlowchartInputConnector): number {\r\n        let i = this.sortedOperatorsAndMaps.typeIndex2globalConnectorIndex2adressOffset.get(2)!.get(inConn.GetGlobalConnectorIndexOfSignalSource())!;\r\n        return this.floats[i];\r\n    }\r\n    GetColor(inConn: FlowchartInputConnector): string {\r\n        let i = this.sortedOperatorsAndMaps.typeIndex2globalConnectorIndex2adressOffset.get(3)!.get(inConn.GetGlobalConnectorIndexOfSignalSource())!;\r\n        return this.colors[i];\r\n    }\r\n\r\n    public Start(warmstart:boolean=false){\r\n        if(!warmstart) this.resetDatastructures();\r\n        this.running=true;\r\n        for(let o of this.sortedOperatorsAndMaps.sortedOperators){\r\n            o.OnSimulationStart(this);\r\n        }\r\n        window.requestAnimationFrame(()=>this.Step());\r\n\r\n    }\r\n\r\n    public Stop(){\r\n        this.running=false;\r\n    }\r\n\r\n\r\n    Step():void{\r\n        this.millisSince1970= Date.now();\r\n        for(let o of this.sortedOperatorsAndMaps.sortedOperators){\r\n            o.OnSimulationStep(this);\r\n        }\r\n        //colorize booleans links\r\n        for(let kv of this.sortedOperatorsAndMaps.typeIndex2adressOffset2ListOfLinks.get(0)!.entries())\r\n        {\r\n            let adressOffset=kv[0];\r\n            if(adressOffset<2) continue;\r\n            let value = this.booleans[adressOffset]\r\n            let linksToChange=kv[1];\r\n            linksToChange.forEach((e)=>{\r\n                e.SetColor(value?\"red\":\"grey\");\r\n                e.SetCaption(\"\"+value);\r\n            });\r\n        }\r\n\r\n        //colorize integers links\r\n        for(let kv of this.sortedOperatorsAndMaps.typeIndex2adressOffset2ListOfLinks.get(1)!.entries())\r\n        {\r\n            let adressOffset=kv[0];\r\n            if(adressOffset<2) continue;\r\n            let value = this.integers[adressOffset]\r\n            let linksToChange=kv[1];\r\n            linksToChange.forEach((e)=>{\r\n                e.SetCaption(\"\"+value);\r\n            });\r\n        }\r\n        //colorize floats links\r\n        for(let kv of this.sortedOperatorsAndMaps.typeIndex2adressOffset2ListOfLinks.get(2)!.entries())\r\n        {\r\n            let adressOffset=kv[0];\r\n            if(adressOffset<2) continue;\r\n            let value = this.floats[adressOffset]\r\n            let linksToChange=kv[1];\r\n            linksToChange.forEach((e)=>{\r\n                e.SetCaption(\"\"+value);\r\n            });\r\n        }\r\n        //colorize colors links\r\n        for(let kv of this.sortedOperatorsAndMaps.typeIndex2adressOffset2ListOfLinks.get(3)!.entries())\r\n        {\r\n            let adressOffset=kv[0];\r\n            if(adressOffset<2) continue;\r\n            let value = this.colors[adressOffset]\r\n            let linksToChange=kv[1];\r\n            linksToChange.forEach((e)=>{\r\n                e.SetCaption(value);\r\n                e.SetColor(value);\r\n            });\r\n        }\r\n        if(this.running){\r\n            window.requestAnimationFrame(()=>this.Step());\r\n        }\r\n        else{\r\n            for(let o of this.sortedOperatorsAndMaps.sortedOperators){\r\n                o.OnSimulationStop(this);\r\n            }\r\n            for(let types of this.sortedOperatorsAndMaps.typeIndex2adressOffset2ListOfLinks.values())\r\n            {\r\n                for(let kv of types.entries()){\r\n                    let adressOffset=kv[0];\r\n                    if(adressOffset<2) continue;\r\n                    let value = this.booleans[adressOffset]\r\n                    let linksToChange=kv[1];\r\n                    linksToChange.forEach((e)=>{\r\n                        e.SetColor(\"blue\");\r\n                        e.SetCaption(\"\");\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    GetMillis(): number {\r\n        return this.millisSince1970;\r\n    }\r\n\r\n}","import { StringNumberTuple } from \"../utils\";\r\nexport default function(){ return [\r\n\tnew StringNumberTuple(\"No Song\", 0),\r\n\tnew StringNumberTuple(\"positive\", 1),\r\n\tnew StringNumberTuple(\"negative\", 2),\r\n\tnew StringNumberTuple(\"Barbie_girl\", 3),\r\n\tnew StringNumberTuple(\"HauntedHouse\", 4),\r\n\tnew StringNumberTuple(\"axelf\", 5),\r\n\tnew StringNumberTuple(\"Bond_007\", 6),\r\n];\r\n};\r\n","//https://en.wikipedia.org/wiki/Topological_sorting\r\n\r\n\r\nenum MarkerState\r\n{\r\n    NONE,\r\n    TEMPORARY,\r\n    PERMANENT,\r\n}\r\n\r\nexport class  NodeWrapper<N> {\r\n    constructor(private payload:N) {\r\n        this.Mark=MarkerState.NONE;\r\n        this.DependendNodes=[];\r\n    }\r\n    public Mark:MarkerState\r\n    public DependendNodes:NodeWrapper<N>[];\r\n    get Payload() {return this.payload;}\r\n};\r\n\r\nexport class TopologicalSortDFS<N>{\r\n    private L:Array<NodeWrapper<N>>;\r\n    constructor()\r\n    {\r\n        this.L=new Array<NodeWrapper<N>>();\r\n    }\r\n\r\n    public sort(headNode:Array<NodeWrapper<N>>)\r\n    {\r\n        this.L=new Array<NodeWrapper<N>>();\r\n        headNode.forEach((n)=>this.visit(n));\r\n        return this.L;\r\n    }\r\n\r\n    private visit(n:NodeWrapper<N>){\r\n        if(n.Mark==MarkerState.PERMANENT) return;\r\n        if(n.Mark==MarkerState.TEMPORARY) throw new Error(\"not a DAG\");\r\n        n.Mark=MarkerState.TEMPORARY;\r\n        for (const d of n.DependendNodes) {\r\n            this.visit(d);\r\n        }\r\n        n.Mark=MarkerState.PERMANENT;\r\n        this.L.push(n);\r\n    }\r\n}","export class Utils\r\n{\r\n    public static EventCoordinatesInSVG(evt:MouseEvent, element:Element, positionRatio:number=1):Location2D {\r\n        let rect = element.getBoundingClientRect();\r\n        return {x: (evt.clientX - rect.left)/positionRatio, y:(evt.clientY - rect.top)/positionRatio}\r\n    }\r\n}\r\n\r\nexport interface Location2D {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface KeyValueTuple {\r\n    key: string;\r\n    value: any;\r\n}\r\n\r\nexport class StringNumberTuple{\r\n    public constructor(public s:string, public n:number){}\r\n}\r\n\r\n\r\nexport class $\r\n{\r\n    public static readonly SVGNS = \"http://www.w3.org/2000/svg\";\r\n    public static readonly XLINKNS = \"http://www.w3.org/1999/xlink\";\r\n    public static readonly HTMLNS = \"http://www.w3.org/1999/xhtml\";\r\n\r\n    public static Svg(parent: Element, type:string,  attributes:string[], classes?: string[]):SVGElement {\r\n        return  parent.appendChild(<SVGElement>$.Elem($.SVGNS, type, attributes, classes));\r\n    }\r\n\r\n    //<svg class=\"icon icon-wastebasket\"><use xlink:href=\"#icon-wastebasket\"></use></svg>\r\n    public static SvgIcon(parent: Element, iconname:string):SVGSVGElement\r\n    {\r\n        let svg = <SVGSVGElement>$.Svg(parent, \"svg\", [], [\"icon\", \"icon-\"+iconname]);\r\n        let use =$.Svg(svg, \"use\", [], []);\r\n        use.setAttributeNS(this.XLINKNS, \"href\", \"#icon-\"+iconname);\r\n        parent.appendChild(svg);\r\n        return svg;\r\n    }\r\n\r\n    public static ColorNumColor2ColorDomString(num:number):string {\r\n        let str = num.toString(16);\r\n        while (str.length < 6) str = \"0\" + num;\r\n        return \"#\"+str;\r\n    }\r\n\r\n    public static ColorDomString2ColorNum(colorString: string):number {\r\n        return parseInt(colorString.substring(1), 16);\r\n    }\r\n\r\n    public static Html(parent: Element, type:string,  attributes:string[], classes?: string[], textContent?:string):HTMLElement {\r\n        return parent.appendChild(<HTMLElement>$.Elem($.HTMLNS, type, attributes, classes, textContent));\r\n    }\r\n\r\n    public static HtmlAsFirstChild(parent: Element, type:string,  attributes:string[], classes?: string[], textContent?:string):HTMLElement {\r\n        if(parent.firstChild)\r\n            return parent.insertBefore(<HTMLElement>$.Elem($.HTMLNS, type, attributes, classes, textContent), parent.firstChild);\r\n        else\r\n            return parent.appendChild(<HTMLElement>$.Elem($.HTMLNS, type, attributes, classes, textContent));\r\n    }\r\n\r\n    private static Elem(ns:string, type:string, attributes:string[], classes?: string[], textContent?:string):Element\r\n    {\r\n        let element = document.createElementNS(ns, type);\r\n        if(classes)\r\n        {\r\n            for (const clazz of classes) {\r\n                element.classList.add(clazz);\r\n            }\r\n        }\r\n        let i:number;\r\n        for(i=0;i<attributes.length;i+=2)\r\n        {\r\n            element.setAttribute(attributes[i], attributes[i+1]);\r\n        }\r\n        if(textContent)\r\n        {\r\n            element.textContent=textContent;\r\n        }\r\n        return element;\r\n    }\r\n\r\n    public static InputNumber(table:HTMLTableSectionElement, min:number, max:number, key:string, cfg:KeyValueTuple[]|null):HTMLInputElement\r\n    {\r\n        let value:number=0;\r\n        if(cfg!=null)\r\n        {\r\n            for (const e of cfg) {\r\n                if(e.key==key && !isNaN(e.value)){\r\n                    value=e.value;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        let tr=$.Html(table, \"tr\", [],[\"develop-propertygrid-tr\"]);\r\n        $.Html(tr, \"td\", [],[\"develop-propertygrid-td\"], key);\r\n        let inputContainer = $.Html(tr, \"td\", [],[\"develop-propertygrid-td\"]);\r\n        return <HTMLInputElement>$.Html(inputContainer, \"input\", [\"type\", \"number\", \"min\", \"\"+Math.round(min), \"max\", \"\"+Math.round(max), \"value\", \"\"+Math.round(value),]);\r\n    }\r\n\r\n    public static InputSelect(table:HTMLTableSectionElement, displayValueAndKeyvalues:StringNumberTuple[], key:string, cfg:KeyValueTuple[]|null):HTMLSelectElement\r\n    {\r\n        let value:number=0;\r\n        if(cfg!=null)\r\n        {\r\n            for (const e of cfg) {\r\n                if(e.key==key && !isNaN(e.value)){\r\n                    value=e.value;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        let tr=$.Html(table, \"tr\", [],[\"develop-propertygrid-tr\"]);\r\n        $.Html(tr, \"td\", [],[\"develop-propertygrid-td\"], key);\r\n        let inputContainer = $.Html(tr, \"td\", [],[\"develop-propertygrid-td\"]);\r\n        let select = <HTMLSelectElement>$.Html(inputContainer, \"select\", [], []);\r\n        for(let i=0;i<displayValueAndKeyvalues.length;i++)\r\n        {\r\n            let option = $.Html(select, \"option\", [\"value\", \"\"+displayValueAndKeyvalues[i].n], [], displayValueAndKeyvalues[i].s);\r\n            if(i==value){\r\n                option.setAttribute(\"selected\", \"\");\r\n            }\r\n        }\r\n        return select;\r\n    }\r\n\r\n   \r\n\r\n    public static InputColor(table:HTMLTableSectionElement, key:string, cfg:KeyValueTuple[]|null):HTMLInputElement\r\n    {\r\n        let value:string=\"#ff0000\";\r\n        if(cfg!=null)\r\n        {\r\n            for (const e of cfg) {\r\n                if(e.key==key){\r\n                    value=e.value;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        let tr=$.Html(table, \"tr\", [],[\"develop-propertygrid-tr\"]);\r\n        $.Html(tr, \"td\", [],[\"develop-propertygrid-td\"], key);\r\n        let inputContainer = $.Html(tr, \"td\", [],[\"develop-propertygrid-td\"]);\r\n        return <HTMLInputElement>$.Html(inputContainer, \"input\", [\"type\", \"color\",  \"value\", value]);\r\n    }\r\n}"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaGFydC5qcyIsInNyYy9BRENFeHBlcmltZW50Q29udHJvbGxlci50cyIsInNyYy9BaXJzcGVlZEV4cGVyaW1lbnRDb250cm9sbGVyLnRzIiwic3JjL0FwcC50cyIsInNyYy9EZXZlbG9wQ0ZDQ29udHJvbGxlci50cyIsInNyYy9EaWFsb2dDb250cm9sbGVyLnRzIiwic3JjL0ZGVEV4cGVyaW1lbnRDb250cm9sbGVyLnRzIiwic3JjL0hlYXRlckV4cGVyaW1lbnRDb250cm9sbGVyLnRzIiwic3JjL1NjcmVlbkNvbnRyb2xsZXIudHMiLCJzcmMvZmxvd2NoYXJ0L0Zsb3djaGFydC50cyIsInNyYy9mbG93Y2hhcnQvRmxvd2NoYXJ0Q29tcGlsZXIudHMiLCJzcmMvZmxvd2NoYXJ0L0Zsb3djaGFydENvbm5lY3Rvci50cyIsInNyYy9mbG93Y2hhcnQvRmxvd2NoYXJ0TGluay50cyIsInNyYy9mbG93Y2hhcnQvRmxvd2NoYXJ0T3BlcmF0b3IudHMiLCJzcmMvZmxvd2NoYXJ0L0Zsb3djaGFydE9wZXJhdG9ySW1wbC50cyIsInNyYy9mbG93Y2hhcnQvU2VyaWFsaXplQ29udGV4dC50cyIsInNyYy9mbG93Y2hhcnQvU2ltdWxhdGlvbk1hbmFnZXIudHMiLCJzcmMvZmxvd2NoYXJ0L1NvbmdzLnRzIiwic3JjL2Zsb3djaGFydC9Ub3BvbG9naWNhbFNvcmZERlMudHMiLCJzcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTJHQzs7Ozs7QUM1R0QsdUNBQThDO0FBQzlDLHlEQUFzRDtBQUV0RCxtRUFBZ0U7QUFDaEUsOEVBQThFO0FBQzlFLE1BQU8sV0FBVyxHQUFVLENBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxLQUFLLEVBQUMsS0FBSyxDQUFDLENBQUM7QUFDMVQsTUFBTSxRQUFRLEdBQUMsSUFBSSxDQUFDO0FBQ3BCLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7QUFFM0MsTUFBYSx1QkFBd0IsU0FBUSxtQ0FBZ0I7SUErRnpELFlBQVksYUFBMkIsRUFB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Q0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RJLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsZ0NBQVksQ0FBQyxNQUFNLEVBQUUsaUNBQWEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUMsRUFBRSxDQUFBLElBQUksbUJBQW1CLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0SSxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLGdDQUFZLENBQUMsTUFBTSxFQUFFLGlDQUFhLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFDLEVBQUUsQ0FBQSxJQUFJLG1CQUFtQixDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdEksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxnQ0FBWSxDQUFDLE1BQU0sRUFBRSxpQ0FBYSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBQyxFQUFFLENBQUEsSUFBSSxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RJLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsZ0NBQVksQ0FBQyxNQUFNLEVBQUUsaUNBQWEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUMsRUFBRSxDQUFBLElBQUksbUJBQW1CLENBQUMsQ0FBQyxFQUFFLEVBQUUs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RCxJQUFJLGNBQWMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFDLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLE9BQXlCLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLE9BQU8sRUFBRSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUcsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDakcsQ0FBQzs7QUE1SEwsY0E2SEM7QUEzSDBCLE9BQUssR0FBRyw0QkFBNEIsQ0FBQztBQUNyQyxTQUFPLEdBQUcsOEJBQThCLENBQUM7QUFDekMsUUFBTSxHQUFHLDhCQUE4QixDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyohXG4gKiBDaGFydC5qcyB2My42LjJcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbihnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5DaGFydCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZywgdXBkYXRlRm4pIHtcbiAgY29uc3QgdXBkYXRlQXJncyA9IHVwZGF0ZUZuIHx8ICgoYXJncykgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuICBsZXQgYXJncyA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucmVzdCkge1xuICAgIGFyZ3MgPSB1cGRhdGVBcmdzKHJlc3QpO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbmNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5jb25zdCBfdGV4dFggPSAoYWxpZ24sIGxlZnQsIHJpZ2h0LCBydGwpID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcblxuY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuICAgIHRoaXMuX2NoYXJ0cy5mb3JFYWNoKChhbmltcywgY2hhcnQpID0+IHtcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZHJhdyA9IGZhbHNlO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgfVxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgYW5pbXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IGRhdGU7XG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0QW5pbXMoY2hhcnQpIHtcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgYW5pbXMgPSB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYXJ0cy5zZXQoY2hhcnQsIGFuaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1zO1xuICB9XG4gIGxpc3RlbihjaGFydCwgZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XG4gIH1cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cbiAgaGFzKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG4gIHN0YXJ0KGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1zLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBydW5uaW5nKGNoYXJ0KSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhbmltcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICB9XG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxudmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XG5cbi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4xLjlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyMCBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuY29uc3QgbWFwJDEgPSB7MDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCwgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSwgQTogMTAsIEI6IDExLCBDOiAxMiwgRDogMTMsIEU6IDE0LCBGOiAxNSwgYTogMTAsIGI6IDExLCBjOiAxMiwgZDogMTMsIGU6IDE0LCBmOiAxNX07XG5jb25zdCBoZXggPSAnMDEyMzQ1Njc4OUFCQ0RFRic7XG5jb25zdCBoMSA9IChiKSA9PiBoZXhbYiAmIDB4Rl07XG5jb25zdCBoMiA9IChiKSA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gKGIpID0+ICgoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpKTtcbmZ1bmN0aW9uIGlzU2hvcnQodikge1xuXHRyZXR1cm4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbn1cbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuXHR2YXIgbGVuID0gc3RyLmxlbmd0aDtcblx0dmFyIHJldDtcblx0aWYgKHN0clswXSA9PT0gJyMnKSB7XG5cdFx0aWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcblx0XHRcdHJldCA9IHtcblx0XHRcdFx0cjogMjU1ICYgbWFwJDFbc3RyWzFdXSAqIDE3LFxuXHRcdFx0XHRnOiAyNTUgJiBtYXAkMVtzdHJbMl1dICogMTcsXG5cdFx0XHRcdGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcblx0XHRcdFx0YTogbGVuID09PSA1ID8gbWFwJDFbc3RyWzRdXSAqIDE3IDogMjU1XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuXHRcdFx0cmV0ID0ge1xuXHRcdFx0XHRyOiBtYXAkMVtzdHJbMV1dIDw8IDQgfCBtYXAkMVtzdHJbMl1dLFxuXHRcdFx0XHRnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxuXHRcdFx0XHRiOiBtYXAkMVtzdHJbNV1dIDw8IDQgfCBtYXAkMVtzdHJbNl1dLFxuXHRcdFx0XHRhOiBsZW4gPT09IDkgPyAobWFwJDFbc3RyWzddXSA8PCA0IHwgbWFwJDFbc3RyWzhdXSkgOiAyNTVcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuXHR2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuXHRyZXR1cm4gdlxuXHRcdD8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgKHYuYSA8IDI1NSA/IGYodi5hKSA6ICcnKVxuXHRcdDogdjtcbn1cbmZ1bmN0aW9uIHJvdW5kKHYpIHtcblx0cmV0dXJuIHYgKyAwLjUgfCAwO1xufVxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcbmZ1bmN0aW9uIHAyYih2KSB7XG5cdHJldHVybiBsaW0ocm91bmQodiAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcblx0cmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG5cdHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG5cdHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIHJnYlBhcnNlKHN0cikge1xuXHRjb25zdCBtID0gUkdCX1JFLmV4ZWMoc3RyKTtcblx0bGV0IGEgPSAyNTU7XG5cdGxldCByLCBnLCBiO1xuXHRpZiAoIW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG1bN10gIT09IHIpIHtcblx0XHRjb25zdCB2ID0gK21bN107XG5cdFx0YSA9IDI1NSAmIChtWzhdID8gcDJiKHYpIDogdiAqIDI1NSk7XG5cdH1cblx0ciA9ICttWzFdO1xuXHRnID0gK21bM107XG5cdGIgPSArbVs1XTtcblx0ciA9IDI1NSAmIChtWzJdID8gcDJiKHIpIDogcik7XG5cdGcgPSAyNTUgJiAobVs0XSA/IHAyYihnKSA6IGcpO1xuXHRiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBiKTtcblx0cmV0dXJuIHtcblx0XHRyOiByLFxuXHRcdGc6IGcsXG5cdFx0YjogYixcblx0XHRhOiBhXG5cdH07XG59XG5mdW5jdGlvbiByZ2JTdHJpbmcodikge1xuXHRyZXR1cm4gdiAmJiAoXG5cdFx0di5hIDwgMjU1XG5cdFx0XHQ/IGByZ2JhKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0sICR7YjJuKHYuYSl9KWBcblx0XHRcdDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcblx0KTtcbn1cbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBoc2wycmdibihoLCBzLCBsKSB7XG5cdGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuXHRjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG5cdHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG59XG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XG5cdGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDYwKSAlIDYpID0+IHYgLSB2ICogcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG5cdHJldHVybiBbZig1KSwgZigzKSwgZigxKV07XG59XG5mdW5jdGlvbiBod2IycmdibihoLCB3LCBiKSB7XG5cdGNvbnN0IHJnYiA9IGhzbDJyZ2JuKGgsIDEsIDAuNSk7XG5cdGxldCBpO1xuXHRpZiAodyArIGIgPiAxKSB7XG5cdFx0aSA9IDEgLyAodyArIGIpO1xuXHRcdHcgKj0gaTtcblx0XHRiICo9IGk7XG5cdH1cblx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdHJnYltpXSAqPSAxIC0gdyAtIGI7XG5cdFx0cmdiW2ldICs9IHc7XG5cdH1cblx0cmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIHJnYjJoc2wodikge1xuXHRjb25zdCByYW5nZSA9IDI1NTtcblx0Y29uc3QgciA9IHYuciAvIHJhbmdlO1xuXHRjb25zdCBnID0gdi5nIC8gcmFuZ2U7XG5cdGNvbnN0IGIgPSB2LmIgLyByYW5nZTtcblx0Y29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuXHRsZXQgaCwgcywgZDtcblx0aWYgKG1heCAhPT0gbWluKSB7XG5cdFx0ZCA9IG1heCAtIG1pbjtcblx0XHRzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cdFx0aCA9IG1heCA9PT0gclxuXHRcdFx0PyAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHQ6IG1heCA9PT0gZ1xuXHRcdFx0XHQ/IChiIC0gcikgLyBkICsgMlxuXHRcdFx0XHQ6IChyIC0gZykgLyBkICsgNDtcblx0XHRoID0gaCAqIDYwICsgMC41O1xuXHR9XG5cdHJldHVybiBbaCB8IDAsIHMgfHwgMCwgbF07XG59XG5mdW5jdGlvbiBjYWxsbihmLCBhLCBiLCBjKSB7XG5cdHJldHVybiAoXG5cdFx0QXJyYXkuaXNBcnJheShhKVxuXHRcdFx0PyBmKGFbMF0sIGFbMV0sIGFbMl0pXG5cdFx0XHQ6IGYoYSwgYiwgYylcblx0KS5tYXAobjJiKTtcbn1cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgcywgbCkge1xuXHRyZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xufVxuZnVuY3Rpb24gaHdiMnJnYihoLCB3LCBiKSB7XG5cdHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XG59XG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcblx0cmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcbn1cbmZ1bmN0aW9uIGh1ZShoKSB7XG5cdHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBodWVQYXJzZShzdHIpIHtcblx0Y29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XG5cdGxldCBhID0gMjU1O1xuXHRsZXQgdjtcblx0aWYgKCFtKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChtWzVdICE9PSB2KSB7XG5cdFx0YSA9IG1bNl0gPyBwMmIoK21bNV0pIDogbjJiKCttWzVdKTtcblx0fVxuXHRjb25zdCBoID0gaHVlKCttWzJdKTtcblx0Y29uc3QgcDEgPSArbVszXSAvIDEwMDtcblx0Y29uc3QgcDIgPSArbVs0XSAvIDEwMDtcblx0aWYgKG1bMV0gPT09ICdod2InKSB7XG5cdFx0diA9IGh3YjJyZ2IoaCwgcDEsIHAyKTtcblx0fSBlbHNlIGlmIChtWzFdID09PSAnaHN2Jykge1xuXHRcdHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XG5cdH0gZWxzZSB7XG5cdFx0diA9IGhzbDJyZ2IoaCwgcDEsIHAyKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHI6IHZbMF0sXG5cdFx0ZzogdlsxXSxcblx0XHRiOiB2WzJdLFxuXHRcdGE6IGFcblx0fTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh2LCBkZWcpIHtcblx0dmFyIGggPSByZ2IyaHNsKHYpO1xuXHRoWzBdID0gaHVlKGhbMF0gKyBkZWcpO1xuXHRoID0gaHNsMnJnYihoKTtcblx0di5yID0gaFswXTtcblx0di5nID0gaFsxXTtcblx0di5iID0gaFsyXTtcbn1cbmZ1bmN0aW9uIGhzbFN0cmluZyh2KSB7XG5cdGlmICghdikge1xuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBhID0gcmdiMmhzbCh2KTtcblx0Y29uc3QgaCA9IGFbMF07XG5cdGNvbnN0IHMgPSBuMnAoYVsxXSk7XG5cdGNvbnN0IGwgPSBuMnAoYVsyXSk7XG5cdHJldHVybiB2LmEgPCAyNTVcblx0XHQ/IGBoc2xhKCR7aH0sICR7c30lLCAke2x9JSwgJHtiMm4odi5hKX0pYFxuXHRcdDogYGhzbCgke2h9LCAke3N9JSwgJHtsfSUpYDtcbn1cbmNvbnN0IG1hcCQxJDEgPSB7XG5cdHg6ICdkYXJrJyxcblx0WjogJ2xpZ2h0Jyxcblx0WTogJ3JlJyxcblx0WDogJ2JsdScsXG5cdFc6ICdncicsXG5cdFY6ICdtZWRpdW0nLFxuXHRVOiAnc2xhdGUnLFxuXHRBOiAnZWUnLFxuXHRUOiAnb2wnLFxuXHRTOiAnb3InLFxuXHRCOiAncmEnLFxuXHRDOiAnbGF0ZWcnLFxuXHREOiAnaWdodHMnLFxuXHRSOiAnaW4nLFxuXHRROiAndHVycXVvaXMnLFxuXHRFOiAnaGknLFxuXHRQOiAncm8nLFxuXHRPOiAnYWwnLFxuXHROOiAnbGUnLFxuXHRNOiAnZGUnLFxuXHRMOiAneWVsbG8nLFxuXHRGOiAnZW4nLFxuXHRLOiAnY2gnLFxuXHRHOiAnYXJrcycsXG5cdEg6ICdlYScsXG5cdEk6ICdpZ2h0ZycsXG5cdEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyA9IHtcblx0T2ljZVhlOiAnZjBmOGZmJyxcblx0YW50aXF1ZXdFdGU6ICdmYWViZDcnLFxuXHRhcXVhOiAnZmZmZicsXG5cdGFxdWFtYXJSZTogJzdmZmZkNCcsXG5cdGF6dVk6ICdmMGZmZmYnLFxuXHRiZWlnZTogJ2Y1ZjVkYycsXG5cdGJpc3F1ZTogJ2ZmZTRjNCcsXG5cdGJsYWNrOiAnMCcsXG5cdGJsYW5LZWRPbW9uZDogJ2ZmZWJjZCcsXG5cdFhlOiAnZmYnLFxuXHRYZXZpVGV0OiAnOGEyYmUyJyxcblx0YlB3bjogJ2E1MmEyYScsXG5cdGJ1cmx5d29vZDogJ2RlYjg4NycsXG5cdGNhTXRYZTogJzVmOWVhMCcsXG5cdEthcnRZdXNlOiAnN2ZmZjAwJyxcblx0S29jVGF0ZTogJ2QyNjkxZScsXG5cdGNTTzogJ2ZmN2Y1MCcsXG5cdGNTbmZsb3dlclhlOiAnNjQ5NWVkJyxcblx0Y1Nuc2lsazogJ2ZmZjhkYycsXG5cdGNyaW1zb246ICdkYzE0M2MnLFxuXHRjeWFuOiAnZmZmZicsXG5cdHhYZTogJzhiJyxcblx0eGN5YW46ICc4YjhiJyxcblx0eGdUTW5QZDogJ2I4ODYwYicsXG5cdHhXYXk6ICdhOWE5YTknLFxuXHR4Z1lGOiAnNjQwMCcsXG5cdHhnWXk6ICdhOWE5YTknLFxuXHR4a2hha2k6ICdiZGI3NmInLFxuXHR4bWFnRnRhOiAnOGIwMDhiJyxcblx0eFRpdmVnWUY6ICc1NTZiMmYnLFxuXHR4U2FuZ2U6ICdmZjhjMDAnLFxuXHR4U2NFZDogJzk5MzJjYycsXG5cdHhZZDogJzhiMDAwMCcsXG5cdHhzT21vbjogJ2U5OTY3YScsXG5cdHhzSGdZRjogJzhmYmM4ZicsXG5cdHhVWGU6ICc0ODNkOGInLFxuXHR4VVdheTogJzJmNGY0ZicsXG5cdHhVZ1l5OiAnMmY0ZjRmJyxcblx0eFFlOiAnY2VkMScsXG5cdHh2aVRldDogJzk0MDBkMycsXG5cdGRBcHBSazogJ2ZmMTQ5MycsXG5cdGRBcHNreVhlOiAnYmZmZicsXG5cdGRpbVdheTogJzY5Njk2OScsXG5cdGRpbWdZeTogJzY5Njk2OScsXG5cdGRvZGdlclhlOiAnMWU5MGZmJyxcblx0ZmlZYnJpY2s6ICdiMjIyMjInLFxuXHRmbFNPd0V0ZTogJ2ZmZmFmMCcsXG5cdGZvWXN0V0FuOiAnMjI4YjIyJyxcblx0ZnVLc2lhOiAnZmYwMGZmJyxcblx0Z2FSc2JTbzogJ2RjZGNkYycsXG5cdGdob3N0d0V0ZTogJ2Y4ZjhmZicsXG5cdGdUZDogJ2ZmZDcwMCcsXG5cdGdUTW5QZDogJ2RhYTUyMCcsXG5cdFdheTogJzgwODA4MCcsXG5cdGdZRjogJzgwMDAnLFxuXHRnWUZMdzogJ2FkZmYyZicsXG5cdGdZeTogJzgwODA4MCcsXG5cdGhvbmV5TXc6ICdmMGZmZjAnLFxuXHRob3RwUms6ICdmZjY5YjQnLFxuXHRSZGlhbllkOiAnY2Q1YzVjJyxcblx0UmRpZ286ICc0YjAwODInLFxuXHRpdlN5OiAnZmZmZmYwJyxcblx0a2hha2k6ICdmMGU2OGMnLFxuXHRsYXZGTXI6ICdlNmU2ZmEnLFxuXHRsYXZGTXJYc2g6ICdmZmYwZjUnLFxuXHRsYXduZ1lGOiAnN2NmYzAwJyxcblx0Tm1vbmNFZmZvbjogJ2ZmZmFjZCcsXG5cdFpYZTogJ2FkZDhlNicsXG5cdFpjU086ICdmMDgwODAnLFxuXHRaY3lhbjogJ2UwZmZmZicsXG5cdFpnVE1uUGRMdzogJ2ZhZmFkMicsXG5cdFpXYXk6ICdkM2QzZDMnLFxuXHRaZ1lGOiAnOTBlZTkwJyxcblx0WmdZeTogJ2QzZDNkMycsXG5cdFpwUms6ICdmZmI2YzEnLFxuXHRac09tb246ICdmZmEwN2EnLFxuXHRac0hnWUY6ICcyMGIyYWEnLFxuXHRac2t5WGU6ICc4N2NlZmEnLFxuXHRaVVdheTogJzc3ODg5OScsXG5cdFpVZ1l5OiAnNzc4ODk5Jyxcblx0WnN0QWxYZTogJ2IwYzRkZScsXG5cdFpMdzogJ2ZmZmZlMCcsXG5cdGxpbWU6ICdmZjAwJyxcblx0bGltZWdZRjogJzMyY2QzMicsXG5cdGxSRjogJ2ZhZjBlNicsXG5cdG1hZ0Z0YTogJ2ZmMDBmZicsXG5cdG1hUG9uOiAnODAwMDAwJyxcblx0VmFxdWFtYXJSZTogJzY2Y2RhYScsXG5cdFZYZTogJ2NkJyxcblx0VlNjRWQ6ICdiYTU1ZDMnLFxuXHRWcHVycE46ICc5MzcwZGInLFxuXHRWc0hnWUY6ICczY2IzNzEnLFxuXHRWVVhlOiAnN2I2OGVlJyxcblx0VnNwclJnZ1lGOiAnZmE5YScsXG5cdFZRZTogJzQ4ZDFjYycsXG5cdFZ2aVRldFlkOiAnYzcxNTg1Jyxcblx0bWlkbmlnaHRYZTogJzE5MTk3MCcsXG5cdG1SdGNZYW06ICdmNWZmZmEnLFxuXHRtaXN0eVBzZTogJ2ZmZTRlMScsXG5cdG1vY2Nhc1I6ICdmZmU0YjUnLFxuXHRuYXZham93RXRlOiAnZmZkZWFkJyxcblx0bmF2eTogJzgwJyxcblx0VGRsYWNlOiAnZmRmNWU2Jyxcblx0VGl2ZTogJzgwODAwMCcsXG5cdFRpdmVkQmI6ICc2YjhlMjMnLFxuXHRTYW5nZTogJ2ZmYTUwMCcsXG5cdFNhbmdlWWQ6ICdmZjQ1MDAnLFxuXHRTY0VkOiAnZGE3MGQ2Jyxcblx0cE9lZ1RNblBkOiAnZWVlOGFhJyxcblx0cE9lZ1lGOiAnOThmYjk4Jyxcblx0cE9lUWU6ICdhZmVlZWUnLFxuXHRwT2V2aVRldFlkOiAnZGI3MDkzJyxcblx0cGFwYXlhd0VwOiAnZmZlZmQ1Jyxcblx0cEhLcHVmZjogJ2ZmZGFiOScsXG5cdHBlcnU6ICdjZDg1M2YnLFxuXHRwUms6ICdmZmMwY2InLFxuXHRwbHVtOiAnZGRhMGRkJyxcblx0cG93TXJYZTogJ2IwZTBlNicsXG5cdHB1cnBOOiAnODAwMDgwJyxcblx0WWJlY2NhcHVycE46ICc2NjMzOTknLFxuXHRZZDogJ2ZmMDAwMCcsXG5cdFBzeWJyb3duOiAnYmM4ZjhmJyxcblx0UHlPWGU6ICc0MTY5ZTEnLFxuXHRzYWRkTmJQd246ICc4YjQ1MTMnLFxuXHRzT21vbjogJ2ZhODA3MicsXG5cdHNhbmR5YlB3bjogJ2Y0YTQ2MCcsXG5cdHNIZ1lGOiAnMmU4YjU3Jyxcblx0c0hzaGVsbDogJ2ZmZjVlZScsXG5cdHNpRm5hOiAnYTA1MjJkJyxcblx0c2lsdmVyOiAnYzBjMGMwJyxcblx0c2t5WGU6ICc4N2NlZWInLFxuXHRVWGU6ICc2YTVhY2QnLFxuXHRVV2F5OiAnNzA4MDkwJyxcblx0VWdZeTogJzcwODA5MCcsXG5cdHNub3c6ICdmZmZhZmEnLFxuXHRzcHJSZ2dZRjogJ2ZmN2YnLFxuXHRzdEFsWGU6ICc0NjgyYjQnLFxuXHR0YW46ICdkMmI0OGMnLFxuXHR0ZU86ICc4MDgwJyxcblx0dEVzdE46ICdkOGJmZDgnLFxuXHR0b21hdG86ICdmZjYzNDcnLFxuXHRRZTogJzQwZTBkMCcsXG5cdHZpVGV0OiAnZWU4MmVlJyxcblx0Skh0OiAnZjVkZWIzJyxcblx0d0V0ZTogJ2ZmZmZmZicsXG5cdHdFdGVzbW9rZTogJ2Y1ZjVmNScsXG5cdEx3OiAnZmZmZjAwJyxcblx0THdnWUY6ICc5YWNkMzInXG59O1xuZnVuY3Rpb24gdW5wYWNrKCkge1xuXHRjb25zdCB1bnBhY2tlZCA9IHt9O1xuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmFtZXMpO1xuXHRjb25zdCB0a2V5cyA9IE9iamVjdC5rZXlzKG1hcCQxJDEpO1xuXHRsZXQgaSwgaiwgaywgb2ssIG5rO1xuXHRmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdG9rID0gbmsgPSBrZXlzW2ldO1xuXHRcdGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuXHRcdFx0ayA9IHRrZXlzW2pdO1xuXHRcdFx0bmsgPSBuay5yZXBsYWNlKGssIG1hcCQxJDFba10pO1xuXHRcdH1cblx0XHRrID0gcGFyc2VJbnQobmFtZXNbb2tdLCAxNik7XG5cdFx0dW5wYWNrZWRbbmtdID0gW2sgPj4gMTYgJiAweEZGLCBrID4+IDggJiAweEZGLCBrICYgMHhGRl07XG5cdH1cblx0cmV0dXJuIHVucGFja2VkO1xufVxubGV0IG5hbWVzJDE7XG5mdW5jdGlvbiBuYW1lUGFyc2Uoc3RyKSB7XG5cdGlmICghbmFtZXMkMSkge1xuXHRcdG5hbWVzJDEgPSB1bnBhY2soKTtcblx0XHRuYW1lcyQxLnRyYW5zcGFyZW50ID0gWzAsIDAsIDAsIDBdO1xuXHR9XG5cdGNvbnN0IGEgPSBuYW1lcyQxW3N0ci50b0xvd2VyQ2FzZSgpXTtcblx0cmV0dXJuIGEgJiYge1xuXHRcdHI6IGFbMF0sXG5cdFx0ZzogYVsxXSxcblx0XHRiOiBhWzJdLFxuXHRcdGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuXHR9O1xufVxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG5cdGlmICh2KSB7XG5cdFx0bGV0IHRtcCA9IHJnYjJoc2wodik7XG5cdFx0dG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG5cdFx0dG1wID0gaHNsMnJnYih0bXApO1xuXHRcdHYuciA9IHRtcFswXTtcblx0XHR2LmcgPSB0bXBbMV07XG5cdFx0di5iID0gdG1wWzJdO1xuXHR9XG59XG5mdW5jdGlvbiBjbG9uZSQxKHYsIHByb3RvKSB7XG5cdHJldHVybiB2ID8gT2JqZWN0LmFzc2lnbihwcm90byB8fCB7fSwgdikgOiB2O1xufVxuZnVuY3Rpb24gZnJvbU9iamVjdChpbnB1dCkge1xuXHR2YXIgdiA9IHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTV9O1xuXHRpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcblx0XHRpZiAoaW5wdXQubGVuZ3RoID49IDMpIHtcblx0XHRcdHYgPSB7cjogaW5wdXRbMF0sIGc6IGlucHV0WzFdLCBiOiBpbnB1dFsyXSwgYTogMjU1fTtcblx0XHRcdGlmIChpbnB1dC5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdHYuYSA9IG4yYihpbnB1dFszXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHYgPSBjbG9uZSQxKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuXHRcdHYuYSA9IG4yYih2LmEpO1xuXHR9XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcblx0aWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuXHRcdHJldHVybiByZ2JQYXJzZShzdHIpO1xuXHR9XG5cdHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuXHRjb25zdHJ1Y3RvcihpbnB1dCkge1xuXHRcdGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXQ7XG5cdFx0fVxuXHRcdGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG5cdFx0bGV0IHY7XG5cdFx0aWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR2ID0gZnJvbU9iamVjdChpbnB1dCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0diA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuXHRcdH1cblx0XHR0aGlzLl9yZ2IgPSB2O1xuXHRcdHRoaXMuX3ZhbGlkID0gISF2O1xuXHR9XG5cdGdldCB2YWxpZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsaWQ7XG5cdH1cblx0Z2V0IHJnYigpIHtcblx0XHR2YXIgdiA9IGNsb25lJDEodGhpcy5fcmdiKTtcblx0XHRpZiAodikge1xuXHRcdFx0di5hID0gYjJuKHYuYSk7XG5cdFx0fVxuXHRcdHJldHVybiB2O1xuXHR9XG5cdHNldCByZ2Iob2JqKSB7XG5cdFx0dGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuXHR9XG5cdHJnYlN0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHRoaXMuX3JnYjtcblx0fVxuXHRoZXhTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB0aGlzLl9yZ2I7XG5cdH1cblx0aHNsU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdGhpcy5fcmdiO1xuXHR9XG5cdG1peChjb2xvciwgd2VpZ2h0KSB7XG5cdFx0Y29uc3QgbWUgPSB0aGlzO1xuXHRcdGlmIChjb2xvcikge1xuXHRcdFx0Y29uc3QgYzEgPSBtZS5yZ2I7XG5cdFx0XHRjb25zdCBjMiA9IGNvbG9yLnJnYjtcblx0XHRcdGxldCB3Mjtcblx0XHRcdGNvbnN0IHAgPSB3ZWlnaHQgPT09IHcyID8gMC41IDogd2VpZ2h0O1xuXHRcdFx0Y29uc3QgdyA9IDIgKiBwIC0gMTtcblx0XHRcdGNvbnN0IGEgPSBjMS5hIC0gYzIuYTtcblx0XHRcdGNvbnN0IHcxID0gKCh3ICogYSA9PT0gLTEgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdFx0dzIgPSAxIC0gdzE7XG5cdFx0XHRjMS5yID0gMHhGRiAmIHcxICogYzEuciArIHcyICogYzIuciArIDAuNTtcblx0XHRcdGMxLmcgPSAweEZGICYgdzEgKiBjMS5nICsgdzIgKiBjMi5nICsgMC41O1xuXHRcdFx0YzEuYiA9IDB4RkYgJiB3MSAqIGMxLmIgKyB3MiAqIGMyLmIgKyAwLjU7XG5cdFx0XHRjMS5hID0gcCAqIGMxLmEgKyAoMSAtIHApICogYzIuYTtcblx0XHRcdG1lLnJnYiA9IGMxO1xuXHRcdH1cblx0XHRyZXR1cm4gbWU7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG5cdH1cblx0YWxwaGEoYSkge1xuXHRcdHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsZWFyZXIocmF0aW8pIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG5cdFx0cmdiLmEgKj0gMSAtIHJhdGlvO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdyZXlzY2FsZSgpIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG5cdFx0Y29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuXHRcdHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRvcGFxdWVyKHJhdGlvKSB7XG5cdFx0Y29uc3QgcmdiID0gdGhpcy5fcmdiO1xuXHRcdHJnYi5hICo9IDEgKyByYXRpbztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRuZWdhdGUoKSB7XG5cdFx0Y29uc3QgdiA9IHRoaXMuX3JnYjtcblx0XHR2LnIgPSAyNTUgLSB2LnI7XG5cdFx0di5nID0gMjU1IC0gdi5nO1xuXHRcdHYuYiA9IDI1NSAtIHYuYjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRsaWdodGVuKHJhdGlvKSB7XG5cdFx0bW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRhcmtlbihyYXRpbykge1xuXHRcdG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2F0dXJhdGUocmF0aW8pIHtcblx0XHRtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGVzYXR1cmF0ZShyYXRpbykge1xuXHRcdG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cm90YXRlKGRlZykge1xuXHRcdHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cbmZ1bmN0aW9uIGluZGV4X2VzbShpbnB1dCkge1xuXHRyZXR1cm4gbmV3IENvbG9yKGlucHV0KTtcbn1cblxuY29uc3QgaXNQYXR0ZXJuT3JHcmFkaWVudCA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIENhbnZhc1BhdHRlcm47XG5mdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IGluZGV4X2VzbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IGluZGV4X2VzbSh2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCB1aWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWQrKztcbiAgfTtcbn0oKSk7XG5mdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zdWJzdHIoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnN1YnN0cigtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuY29uc3QgaXNOdW1iZXJGaW5pdGUgPSAodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgrdmFsdWUpO1xuZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDBcbiAgICA6IHZhbHVlIC8gZGltZW5zaW9uO1xuY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuZnVuY3Rpb24gY2FsbGJhY2soZm4sIGFyZ3MsIHRoaXNBcmcpIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlYWNoKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xuICBsZXQgaSwgbGVuLCBrZXlzO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwLCBhMSkge1xuICBsZXQgaSwgaWxlbiwgdjAsIHYxO1xuICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdjAgPSBhMFtpXTtcbiAgICB2MSA9IGExW2ldO1xuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcbiAgICBmb3IgKDsgayA8IGtsZW47ICsraykge1xuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUoc291cmNlW2tleXNba11dKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5mdW5jdGlvbiBfbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlSWYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXJJZihrZXksIHRhcmdldCwgc291cmNlKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlcHJlY2F0ZWQoc2NvcGUsIHZhbHVlLCBwcmV2aW91cywgY3VycmVudCkge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcblx0XHRcdCdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICB9XG59XG5jb25zdCBlbXB0eVN0cmluZyA9ICcnO1xuY29uc3QgZG90ID0gJy4nO1xuZnVuY3Rpb24gaW5kZXhPZkRvdE9yTGVuZ3RoKGtleSwgc3RhcnQpIHtcbiAgY29uc3QgaWR4ID0ga2V5LmluZGV4T2YoZG90LCBzdGFydCk7XG4gIHJldHVybiBpZHggPT09IC0xID8ga2V5Lmxlbmd0aCA6IGlkeDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gZW1wdHlTdHJpbmcpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgaWR4ID0gaW5kZXhPZkRvdE9yTGVuZ3RoKGtleSwgcG9zKTtcbiAgd2hpbGUgKG9iaiAmJiBpZHggPiBwb3MpIHtcbiAgICBvYmogPSBvYmpba2V5LnN1YnN0cihwb3MsIGlkeCAtIHBvcyldO1xuICAgIHBvcyA9IGlkeCArIDE7XG4gICAgaWR4ID0gaW5kZXhPZkRvdE9yTGVuZ3RoKGtleSwgcG9zKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5jb25zdCBkZWZpbmVkID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgc2V0c0VxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRTY29wZSQxKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbmNsYXNzIERlZmF1bHRzIHtcbiAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XG4gIH1cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgfVxuICBkZXNjcmliZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChkZXNjcmlwdG9ycywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCB0YXJnZXRTY29wZSk7XG4gICAgY29uc3QgcHJpdmF0ZU5hbWUgPSAnXycgKyBuYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxudmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2V2ZW50cycsXG4gIGhvdmVyOiB7XG4gICAgX2ZhbGxiYWNrOiAnaW50ZXJhY3Rpb24nXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9XG59KTtcblxuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgVEFVID0gMiAqIFBJO1xuY29uc3QgUElUQVUgPSBUQVUgKyBQSTtcbmNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmNvbnN0IEhBTEZfUEkgPSBQSSAvIDI7XG5jb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5jb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5jb25zdCBzaWduID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gbmljZU51bShyYW5nZSkge1xuICBjb25zdCByb3VuZGVkUmFuZ2UgPSBNYXRoLnJvdW5kKHJhbmdlKTtcbiAgcmFuZ2UgPSBhbG1vc3RFcXVhbHMocmFuZ2UsIHJvdW5kZWRSYW5nZSwgcmFuZ2UgLyAxMDAwKSA/IHJvdW5kZWRSYW5nZSA6IHJhbmdlO1xuICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcbiAgY29uc3QgZnJhY3Rpb24gPSByYW5nZSAvIG5pY2VSYW5nZTtcbiAgY29uc3QgbmljZUZyYWN0aW9uID0gZnJhY3Rpb24gPD0gMSA/IDEgOiBmcmFjdGlvbiA8PSAyID8gMiA6IGZyYWN0aW9uIDw9IDUgPyA1IDogMTA7XG4gIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XG59XG5mdW5jdGlvbiBfZmFjdG9yaXplKHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7XG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbmZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4LCB5LCBlcHNpbG9uKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuZnVuY3Rpb24gYWxtb3N0V2hvbGUoeCwgZXBzaWxvbikge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcbiAgcmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xufVxuZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KGFycmF5LCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcbn1cbmZ1bmN0aW9uIF9kZWNpbWFsUGxhY2VzKHgpIHtcbiAgaWYgKCFpc051bWJlckZpbml0ZSh4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gZ2V0QW5nbGVGcm9tUG9pbnQoY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG4gIGlmIChhbmdsZSA8ICgtMC41ICogUEkpKSB7XG4gICAgYW5nbGUgKz0gVEFVO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MSwgcHQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5mdW5jdGlvbiBfYW5nbGVEaWZmKGEsIGIpIHtcbiAgcmV0dXJuIChhIC0gYiArIFBJVEFVKSAlIFRBVSAtIFBJO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGEpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cbmZ1bmN0aW9uIF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0LCBlbmQsIHNhbWVBbmdsZUlzRnVsbENpcmNsZSkge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cbmZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBfaW50MTZSYW5nZSh2YWx1ZSkge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZSwgc3RhcnQsIGVuZCwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG5cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuZnVuY3Rpb24gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuICBsZXQgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuICBpZiAoIXRleHRXaWR0aCkge1xuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgfVxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuICAgIGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LCBhcnJheU9mVGhpbmdzLCBjYWNoZSkge1xuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xuICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICBsZXQgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udDtcbiAgbGV0IGxvbmdlc3QgPSAwO1xuICBjb25zdCBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XG4gIGxldCBpLCBqLCBqbGVuLCB0aGluZywgbmVzdGVkVGhpbmc7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICBpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XG4gICAgfVxuICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpIHtcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHguc2F2ZSgpO1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgeCwgeSkge1xuICBsZXQgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgZGVmYXVsdDpcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICBjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICBjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcbiAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICBjdHguYXJjKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICBjdHguYXJjKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlY3QnOlxuICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgIHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG4gICAgICBjdHgucmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIDIgKiBzaXplLCAyICogc2l6ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ3JlY3RSb3QnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAnY3Jvc3MnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3Rhcic6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnbGluZSc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnZGFzaCc6XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgYnJlYWs7XG4gIH1cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNQb2ludEluQXJlYShwb2ludCwgYXJlYSwgbWFyZ2luKSB7XG4gIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7XG4gIHJldHVybiAhYXJlYSB8fCAocG9pbnQgJiYgcG9pbnQueCA+IGFyZWEubGVmdCAtIG1hcmdpbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIG1hcmdpbiAmJlxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xufVxuZnVuY3Rpb24gY2xpcEFyZWEoY3R4LCBhcmVhKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB1bmNsaXBBcmVhKGN0eCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwLCBtb2RlKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeCA6IHByZXZpb3VzLmNwMngsXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeSA6IHRhcmdldC5jcDF5LFxuICAgIHRhcmdldC54LFxuICAgIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclRleHQoY3R4LCB0ZXh0LCB4LCB5LCBmb250LCBvcHRzID0ge30pIHtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcbiAgY29uc3Qgc3Ryb2tlID0gb3B0cy5zdHJva2VXaWR0aCA+IDAgJiYgb3B0cy5zdHJva2VDb2xvciAhPT0gJyc7XG4gIGxldCBpLCBsaW5lO1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgfVxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcbiAgICB5ICs9IGZvbnQubGluZUhlaWdodDtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpIHtcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICBjdHgudHJhbnNsYXRlKG9wdHMudHJhbnNsYXRpb25bMF0sIG9wdHMudHJhbnNsYXRpb25bMV0pO1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ247XG4gIH1cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIC1IQUxGX1BJLCBQSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCk7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cy50b3BMZWZ0LCB5KTtcbn1cblxuZnVuY3Rpb24gX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGNtcCkge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkO1xuICB3aGlsZSAoaGkgLSBsbyA+IDEpIHtcbiAgICBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAoY21wKG1pZCkpIHtcbiAgICAgIGxvID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuY29uc3QgX2xvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5jb25zdCBfcmxvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPj0gdmFsdWUpO1xuZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzLCBtaW4sIG1heCkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIHZhbHVlc1tzdGFydF0gPCBtaW4pIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiB2YWx1ZXNbZW5kIC0gMV0gPiBtYXgpIHtcbiAgICBlbmQtLTtcbiAgfVxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XG5mdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHtcbiAgICAgIGxpc3RlbmVyczogW2xpc3RlbmVyXVxuICAgIH1cbiAgfSk7XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaCgob2JqZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBjb25zdCBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG4gIGlmICghc3R1Yikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgZGVsZXRlIGFycmF5W2tleV07XG4gIH0pO1xuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5mdW5jdGlvbiBfYXJyYXlVbmlxdWUoaXRlbXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNldC5hZGQoaXRlbXNbaV0pO1xuICB9XG4gIGlmIChzZXQuc2l6ZSA9PT0gaWxlbikge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuXG5mdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gX2dldFBhcmVudE5vZGUoZG9tTm9kZSkge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcbiAgfVxuICByZXR1cm4gcGFyZW50O1xufVxuZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlLCBub2RlLCBwYXJlbnRQcm9wZXJ0eSkge1xuICBsZXQgdmFsdWVJblBpeGVscztcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG4gICAgaWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgdmFsdWVJblBpeGVscyA9IHZhbHVlSW5QaXhlbHMgLyAxMDAgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWVJblBpeGVscztcbn1cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudCkgPT4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5mdW5jdGlvbiBnZXRTdHlsZShlbCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXMsIHN0eWxlLCBzdWZmaXgpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIHN1ZmZpeCA9IHN1ZmZpeCA/ICctJyArIHN1ZmZpeCA6ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uc1tpXTtcbiAgICByZXN1bHRbcG9zXSA9IHBhcnNlRmxvYXQoc3R5bGVzW3N0eWxlICsgJy0nICsgcG9zICsgc3VmZml4XSkgfHwgMDtcbiAgfVxuICByZXN1bHQud2lkdGggPSByZXN1bHQubGVmdCArIHJlc3VsdC5yaWdodDtcbiAgcmVzdWx0LmhlaWdodCA9IHJlc3VsdC50b3AgKyByZXN1bHQuYm90dG9tO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHgsIHksIHRhcmdldCkgPT4gKHggPiAwIHx8IHkgPiAwKSAmJiAoIXRhcmdldCB8fCAhdGFyZ2V0LnNoYWRvd1Jvb3QpO1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oZXZ0LCBjYW52YXMpIHtcbiAgY29uc3QgZSA9IGV2dC5uYXRpdmUgfHwgZXZ0O1xuICBjb25zdCB0b3VjaGVzID0gZS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSB0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID8gdG91Y2hlc1swXSA6IGU7XG4gIGNvbnN0IHtvZmZzZXRYLCBvZmZzZXRZfSA9IHNvdXJjZTtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24kMShldnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZ0LCBjYW52YXMpO1xuICBjb25zdCB4T2Zmc2V0ID0gcGFkZGluZ3MubGVmdCArIChib3ggJiYgYm9yZGVycy5sZWZ0KTtcbiAgY29uc3QgeU9mZnNldCA9IHBhZGRpbmdzLnRvcCArIChib3ggJiYgYm9yZGVycy50b3ApO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgbGV0IG1heFdpZHRoLCBtYXhIZWlnaHQ7XG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuY29uc3Qgcm91bmQxID0gdiA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcbmZ1bmN0aW9uIGdldE1heGltdW1TaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gcmV0aW5hU2NhbGUoY2hhcnQsIGZvcmNlUmF0aW8sIGZvcmNlU3R5bGUpIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG4gIGNoYXJ0LmhlaWdodCA9IGRldmljZUhlaWdodCAvIHBpeGVsUmF0aW87XG4gIGNoYXJ0LndpZHRoID0gZGV2aWNlV2lkdGggLyBwaXhlbFJhdGlvO1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cbiAgICAgIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodFxuICAgICAgfHwgY2FudmFzLndpZHRoICE9PSBkZXZpY2VXaWR0aCkge1xuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRldmljZVdpZHRoO1xuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCkge1xuICBpZiAoJ25hdGl2ZScgaW4gZSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlLngsXG4gICAgICB5OiBlLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiBnZXRSZWxhdGl2ZVBvc2l0aW9uJDEoZSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVBbGxWaXNpYmxlSXRlbXMoY2hhcnQsIGhhbmRsZXIpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGxldCBpbmRleCwgZGF0YSwgZWxlbWVudDtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAoe2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldKTtcbiAgICBmb3IgKGxldCBqID0gMCwgamxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIHJldHVybiBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cbmZ1bmN0aW9uIG9wdGltaXplZEV2YWx1YXRlSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBpZiAoIV9pc1BvaW50SW5BcmVhKHBvc2l0aW9uLCBjaGFydC5jaGFydEFyZWEsIGNoYXJ0Ll9taW5QYWRkaW5nKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuICBvcHRpbWl6ZWRFdmFsdWF0ZUl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGlmICghX2lzUG9pbnRJbkFyZWEocG9zaXRpb24sIGNoYXJ0LmNoYXJ0QXJlYSwgY2hhcnQuX21pblBhZGRpbmcpKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmICghX2lzUG9pbnRJbkFyZWEoY2VudGVyLCBjaGFydC5jaGFydEFyZWEsIGNoYXJ0Ll9taW5QYWRkaW5nKSAmJiAhZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuICBvcHRpbWl6ZWRFdmFsdWF0ZUl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG4gIGV2YWx1YXRlQWxsVmlzaWJsZUl0ZW1zKGNoYXJ0LCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxudmFyIEludGVyYWN0aW9uID0ge1xuICBtb2Rlczoge1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIGUsIHtheGlzOiAneCcsIGludGVyc2VjdDogb3B0aW9ucy5pbnRlcnNlY3R9LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIGUsIHtheGlzOiAneScsIGludGVyc2VjdDogb3B0aW9ucy5pbnRlcnNlY3R9LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyk7XG5jb25zdCBGT05UX1NUWUxFID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLyk7XG5mdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWUsIHNpemUpIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICBjYXNlICdweCc6XG4gICAgcmV0dXJuIHZhbHVlO1xuICBjYXNlICclJzpcbiAgICB2YWx1ZSAvPSAxMDA7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cbmNvbnN0IG51bWJlck9yWmVybyQxID0gdiA9PiArdiB8fCAwO1xuZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHByb3BzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvJDEocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRvVFJCTCh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlKSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSk7XG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiB0b0ZvbnQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udDtcbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gJyc7XG4gIH1cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5mdW5jdGlvbiByZXNvbHZlKGlucHV0cywgY29udGV4dCwgaW5kZXgsIGluZm8pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heCwgZ3JhY2UsIGJlZ2luQXRaZXJvKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZSwgYWRkKSA9PiBiZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQsIGNvbnRleHQpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KSwgY29udGV4dCk7XG59XG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgY29uc3QgdjEgPSByZXZlcnNlID8gYSA6IGI7XG4gICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxuICAgICAgdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tzKGxheW91dHMpIHtcbiAgY29uc3Qgc3RhY2tzID0ge307XG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XG4gICAgY29uc3Qge3N0YWNrLCBwb3MsIHN0YWNrV2VpZ2h0fSA9IHdyYXA7XG4gICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgX3N0YWNrID0gc3RhY2tzW3N0YWNrXSB8fCAoc3RhY2tzW3N0YWNrXSA9IHtjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDB9KTtcbiAgICBfc3RhY2suY291bnQrKztcbiAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XG4gIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcih3cmFwID0+IHdyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gIGNvbnN0IHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcbiAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICBjb25zdCBjZW50ZXJIb3Jpem9udGFsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneCcpO1xuICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gIG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgY2hhcnRBcmVhW3Bvc10gLT0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge3NpemU6IDAsIGNvdW50OiAxfTtcbiAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBsYXlvdXQuc2l6ZTtcbiAgfVxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXG4gICAgPyB7c2FtZTogd2lkdGhDaGFuZ2VkLCBvdGhlcjogaGVpZ2h0Q2hhbmdlZH1cbiAgICA6IHtzYW1lOiBoZWlnaHRDaGFuZ2VkLCBvdGhlcjogd2lkdGhDaGFuZ2VkfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuICAgIGlmICghYm94LmZ1bGxTaXplKSB7XG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZml0ICYmIGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHx8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcbiAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge2NvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMX07XG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeSA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCB1c2VyUGFkZGluZy50b3AsIHdpZHRoLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSB1c2VyUGFkZGluZy5ib3R0b20gLSB1c2VyUGFkZGluZy50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgfVxuICB9XG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gIGF1dG9QYWRkaW5nOiB0cnVlLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH1cbn0pO1xudmFyIGxheW91dHMgPSB7XG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICAgICAgICBpdGVtLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfTtcbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBwYWRkaW5nKTtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nLFxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICB5OiBwYWRkaW5nLnRvcFxuICAgIH0sIHBhZGRpbmcpO1xuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cbiAgICBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53LFxuICAgIH07XG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzID0gWycnXSwgcm9vdFNjb3BlcyA9IHNjb3BlcywgZmFsbGJhY2ssIGdldFRhcmdldCA9ICgpID0+IHNjb3Blc1swXSkge1xuICBpZiAoIWRlZmluZWQoZmFsbGJhY2spKSB7XG4gICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgfVxuICBjb25zdCBjYWNoZSA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ09iamVjdCcsXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgX3Jvb3RTY29wZXM6IHJvb3RTY29wZXMsXG4gICAgX2ZhbGxiYWNrOiBmYWxsYmFjayxcbiAgICBfZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIHJvb3RTY29wZXMsIGZhbGxiYWNrKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHRhcmdldCkpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGVzWzBdKTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXQuX3N0b3JhZ2UgfHwgKHRhcmdldC5fc3RvcmFnZSA9IGdldFRhcmdldCgpKTtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHN0b3JhZ2VbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gX2F0dGFjaENvbnRleHQocHJveHksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgX2NhY2hlYWJsZTogZmFsc2UsXG4gICAgX3Byb3h5OiBwcm94eSxcbiAgICBfY29udGV4dDogY29udGV4dCxcbiAgICBfc3ViUHJveHk6IHN1YlByb3h5LFxuICAgIF9zdGFjazogbmV3IFNldCgpLFxuICAgIF9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzKHByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIHNldENvbnRleHQ6IChjdHgpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXG4gICAgICAgID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge2VudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm94eSwgcHJvcCk7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3h5KTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwcm94eSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKHByb3h5LCBkZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9KSB7XG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBfYWxsS2V5cyxcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgaXNTY3JpcHRhYmxlOiBpc0Z1bmN0aW9uKF9zY3JpcHRhYmxlKSA/IF9zY3JpcHRhYmxlIDogKCkgPT4gX3NjcmlwdGFibGUsXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxuICB9O1xufVxuY29uc3QgcmVhZEtleSA9IChwcmVmaXgsIG5hbWUpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbmNvbnN0IG5lZWRzU3ViUmVzb2x2ZXIgPSAocHJvcCwgdmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBwcm9wICE9PSAnYWRhcHRlcnMnICYmXG4gIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuZnVuY3Rpb24gX2NhY2hlZCh0YXJnZXQsIHByb3AsIHJlc29sdmUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICB2YWx1ZSA9IHZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGNyZWF0ZVN1YlJlc29sdmVyKF9wcm94eS5fc2NvcGVzLCBfcHJveHksIHByb3AsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGlzSW5kZXhhYmxlKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBpZiAoZGVmaW5lZChfY29udGV4dC5pbmRleCkgJiYgaXNJbmRleGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICBjb25zdCBhcnIgPSB2YWx1ZTtcbiAgICBjb25zdCBzY29wZXMgPSBfcHJveHkuX3Njb3Blcy5maWx0ZXIocyA9PiBzICE9PSBhcnIpO1xuICAgIHZhbHVlID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIF9wcm94eSwgcHJvcCwgaXRlbSk7XG4gICAgICB2YWx1ZS5wdXNoKF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKGZhbGxiYWNrLCBwcm9wLCB2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cbmNvbnN0IGdldFNjb3BlID0gKGtleSwgcGFyZW50KSA9PiBrZXkgPT09IHRydWUgPyBwYXJlbnRcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gYWRkU2NvcGVzKHNldCwgcGFyZW50U2NvcGVzLCBrZXksIHBhcmVudEZhbGxiYWNrKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgc2NvcGUpO1xuICAgICAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiBkZWZpbmVkKHBhcmVudEZhbGxiYWNrKSAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIocGFyZW50U2NvcGVzLCByZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IHByb3ApIHtcbiAgICBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBmYWxsYmFjaywga2V5KTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbJyddLCByb290U2NvcGVzLCBmYWxsYmFjayxcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2spO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IHBhcmVudCA9IHJlc29sdmVyLl9nZXRUYXJnZXQoKTtcbiAgaWYgKCEocHJvcCBpbiBwYXJlbnQpKSB7XG4gICAgcGFyZW50W3Byb3BdID0ge307XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gcGFyZW50W3Byb3BdO1xuICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgcHJveHkpIHtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpXG4gICAgICAgID8gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBwcm94eSwgcHJvcCwgdmFsdWUpXG4gICAgICAgIDogdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfcmVzb2x2ZShrZXksIHNjb3Blcykge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpIHtcbiAgbGV0IGtleXMgPSB0YXJnZXQuX2tleXM7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSB0YXJnZXQuX2tleXMgPSByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXModGFyZ2V0Ll9zY29wZXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3Blcykge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzLCBpKSA9PiBpIDwgcG9pbnRzLmxlbmd0aCAmJiAhcG9pbnRzW2ldLnNraXAgJiYgcG9pbnRzW2ldO1xuY29uc3QgZ2V0VmFsdWVBeGlzID0gKGluZGV4QXhpcykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5mdW5jdGlvbiBzcGxpbmVDdXJ2ZShmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG4gIGxldCBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcbiAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG4gIGNvbnN0IGZhID0gdCAqIHMwMTtcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiB7XG4gICAgICB4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKSB7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbG1vc3RFcXVhbHMoZGVsdGFLW2ldLCAwLCBFUFNJTE9OKSkge1xuICAgICAgbUtbaV0gPSBtS1tpICsgMV0gPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICBtS1tpXSA9IGFscGhhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgbUtbaSArIDFdID0gYmV0YUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICB9XG59XG5mdW5jdGlvbiBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgZGVsdGEsIHBvaW50QmVmb3JlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaVBpeGVsID0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgY29uc3QgdlBpeGVsID0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc107XG4gICAgaWYgKHBvaW50QmVmb3JlKSB7XG4gICAgICBkZWx0YSA9IChpUGl4ZWwgLSBwb2ludEJlZm9yZVtpbmRleEF4aXNdKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7aW5kZXhBeGlzfWBdID0gaVBpeGVsIC0gZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7dmFsdWVBeGlzfWBdID0gdlBpeGVsIC0gZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGRlbHRhID0gKHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIGlQaXhlbCkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke2luZGV4QXhpc31gXSA9IGlQaXhlbCArIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCArIGRlbHRhICogbUtbaV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUsgPSBBcnJheShwb2ludHNMZW4pLmZpbGwoMCk7XG4gIGNvbnN0IG1LID0gQXJyYXkocG9pbnRzTGVuKTtcbiAgbGV0IGksIHBvaW50QmVmb3JlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgICAgZGVsdGFLW2ldID0gc2xvcGVEZWx0YSAhPT0gMCA/IChwb2ludEFmdGVyW3ZhbHVlQXhpc10gLSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXSkgLyBzbG9wZURlbHRhIDogMDtcbiAgICB9XG4gICAgbUtbaV0gPSAhcG9pbnRCZWZvcmUgPyBkZWx0YUtbaV1cbiAgICAgIDogIXBvaW50QWZ0ZXIgPyBkZWx0YUtbaSAtIDFdXG4gICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgOiAoZGVsdGFLW2kgLSAxXSArIGRlbHRhS1tpXSkgLyAyO1xuICB9XG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG4gIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMpO1xufVxuZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG59XG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICBsZXQgaW5BcmVhTmV4dCA9IF9pc1BvaW50SW5BcmVhKHBvaW50c1swXSwgYXJlYSk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICBpbkFyZWEgPSBpbkFyZWFOZXh0O1xuICAgIGluQXJlYU5leHQgPSBpIDwgaWxlbiAtIDEgJiYgX2lzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXSwgYXJlYSk7XG4gICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgICBpZiAoaW5BcmVhTmV4dCkge1xuICAgICAgcG9pbnQuY3AyeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AyeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMocG9pbnRzLCBvcHRpb25zLCBhcmVhLCBsb29wLCBpbmRleEF4aXMpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBjb250cm9sUG9pbnRzO1xuICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgIHBvaW50cyA9IHBvaW50cy5maWx0ZXIoKHB0KSA9PiAhcHQuc2tpcCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwcmV2ID0gbG9vcCA/IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gOiBwb2ludHNbMF07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29udHJvbFBvaW50cyA9IHNwbGluZUN1cnZlKFxuICAgICAgICBwcmV2LFxuICAgICAgICBwb2ludCxcbiAgICAgICAgcG9pbnRzW01hdGgubWluKGkgKyAxLCBpbGVuIC0gKGxvb3AgPyAwIDogMSkpICUgaWxlbl0sXG4gICAgICAgIG9wdGlvbnMudGVuc2lvblxuICAgICAgKTtcbiAgICAgIHBvaW50LmNwMXggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG4gICAgICBwb2ludC5jcDF5ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuICAgICAgcG9pbnQuY3AyeCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuICAgICAgcG9pbnQuY3AyeSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuICAgICAgcHJldiA9IHBvaW50O1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuXG5jb25zdCBhdEVkZ2UgPSAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQsIHMsIHApID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0LCBzLCBwKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5jb25zdCBlZmZlY3RzID0ge1xuICBsaW5lYXI6IHQgPT4gdCxcbiAgZWFzZUluUXVhZDogdCA9PiB0ICogdCxcbiAgZWFzZU91dFF1YWQ6IHQgPT4gLXQgKiAodCAtIDIpLFxuICBlYXNlSW5PdXRRdWFkOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuICBlYXNlSW5DdWJpYzogdCA9PiB0ICogdCAqIHQsXG4gIGVhc2VPdXRDdWJpYzogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0Q3ViaWM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuICBlYXNlSW5RdWFydDogdCA9PiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVhcnQ6IHQgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuICBlYXNlSW5PdXRRdWFydDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG4gIGVhc2VJblF1aW50OiB0ID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVpbnQ6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0UXVpbnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcbiAgZWFzZUluU2luZTogdCA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcbiAgZWFzZU91dFNpbmU6IHQgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuICBlYXNlSW5PdXRTaW5lOiB0ID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuICBlYXNlSW5FeHBvOiB0ID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuICBlYXNlT3V0RXhwbzogdCA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcbiAgZWFzZUluT3V0RXhwbzogdCA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG4gIGVhc2VJbkNpcmM6IHQgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuICBlYXNlT3V0Q2lyYzogdCA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG4gIGVhc2VJbk91dENpcmM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG4gIGVhc2VJbkVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZU91dEVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG4gIGVhc2VJbk91dEVsYXN0aWModCkge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG4gIGVhc2VJbkJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9LFxuICBlYXNlT3V0QmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcbiAgZWFzZUluT3V0QmFjayh0KSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG4gIGVhc2VJbkJvdW5jZTogdCA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcbiAgZWFzZU91dEJvdW5jZSh0KSB7XG4gICAgY29uc3QgbSA9IDcuNTYyNTtcbiAgICBjb25zdCBkID0gMi43NTtcbiAgICBpZiAodCA8ICgxIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgKDIgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMS41IC8gZCkpICogdCArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgKDIuNSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgyLjI1IC8gZCkpICogdCArIDAuOTM3NTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiAodCAtPSAoMi42MjUgLyBkKSkgKiB0ICsgMC45ODQzNzU7XG4gIH0sXG4gIGVhc2VJbk91dEJvdW5jZTogdCA9PiAodCA8IDAuNSlcbiAgICA/IGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNVxuICAgIDogZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjUsXG59O1xuXG5mdW5jdGlvbiBfcG9pbnRJbkxpbmUocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsLCByZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBkaXJlY3Rpb24pIHtcbiAgbGV0IHN0eWxlLCBvcmlnaW5hbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgY3R4LnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3JpZ2luYWwpIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgc3RhcnQgJT0gY291bnQ7XG4gIGlmIChsb29wKSB7XG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuICBlbmQgJT0gY291bnQ7XG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgcmV0dXJuIHByZXZTdHlsZSAmJiBKU09OLnN0cmluZ2lmeShzdHlsZSkgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSk7XG59XG5cbnZhciBoZWxwZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuZWFzaW5nRWZmZWN0czogZWZmZWN0cyxcbmNvbG9yOiBjb2xvcixcbmdldEhvdmVyQ29sb3I6IGdldEhvdmVyQ29sb3IsXG5ub29wOiBub29wLFxudWlkOiB1aWQsXG5pc051bGxPclVuZGVmOiBpc051bGxPclVuZGVmLFxuaXNBcnJheTogaXNBcnJheSxcbmlzT2JqZWN0OiBpc09iamVjdCxcbmlzRmluaXRlOiBpc051bWJlckZpbml0ZSxcbmZpbml0ZU9yRGVmYXVsdDogZmluaXRlT3JEZWZhdWx0LFxudmFsdWVPckRlZmF1bHQ6IHZhbHVlT3JEZWZhdWx0LFxudG9QZXJjZW50YWdlOiB0b1BlcmNlbnRhZ2UsXG50b0RpbWVuc2lvbjogdG9EaW1lbnNpb24sXG5jYWxsYmFjazogY2FsbGJhY2ssXG5lYWNoOiBlYWNoLFxuX2VsZW1lbnRzRXF1YWw6IF9lbGVtZW50c0VxdWFsLFxuY2xvbmU6IGNsb25lLFxuX21lcmdlcjogX21lcmdlcixcbm1lcmdlOiBtZXJnZSxcbm1lcmdlSWY6IG1lcmdlSWYsXG5fbWVyZ2VySWY6IF9tZXJnZXJJZixcbl9kZXByZWNhdGVkOiBfZGVwcmVjYXRlZCxcbnJlc29sdmVPYmplY3RLZXk6IHJlc29sdmVPYmplY3RLZXksXG5fY2FwaXRhbGl6ZTogX2NhcGl0YWxpemUsXG5kZWZpbmVkOiBkZWZpbmVkLFxuaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbnNldHNFcXVhbDogc2V0c0VxdWFsLFxudG9Gb250U3RyaW5nOiB0b0ZvbnRTdHJpbmcsXG5fbWVhc3VyZVRleHQ6IF9tZWFzdXJlVGV4dCxcbl9sb25nZXN0VGV4dDogX2xvbmdlc3RUZXh0LFxuX2FsaWduUGl4ZWw6IF9hbGlnblBpeGVsLFxuY2xlYXJDYW52YXM6IGNsZWFyQ2FudmFzLFxuZHJhd1BvaW50OiBkcmF3UG9pbnQsXG5faXNQb2ludEluQXJlYTogX2lzUG9pbnRJbkFyZWEsXG5jbGlwQXJlYTogY2xpcEFyZWEsXG51bmNsaXBBcmVhOiB1bmNsaXBBcmVhLFxuX3N0ZXBwZWRMaW5lVG86IF9zdGVwcGVkTGluZVRvLFxuX2JlemllckN1cnZlVG86IF9iZXppZXJDdXJ2ZVRvLFxucmVuZGVyVGV4dDogcmVuZGVyVGV4dCxcbmFkZFJvdW5kZWRSZWN0UGF0aDogYWRkUm91bmRlZFJlY3RQYXRoLFxuX2xvb2t1cDogX2xvb2t1cCxcbl9sb29rdXBCeUtleTogX2xvb2t1cEJ5S2V5LFxuX3Jsb29rdXBCeUtleTogX3Jsb29rdXBCeUtleSxcbl9maWx0ZXJCZXR3ZWVuOiBfZmlsdGVyQmV0d2Vlbixcbmxpc3RlbkFycmF5RXZlbnRzOiBsaXN0ZW5BcnJheUV2ZW50cyxcbnVubGlzdGVuQXJyYXlFdmVudHM6IHVubGlzdGVuQXJyYXlFdmVudHMsXG5fYXJyYXlVbmlxdWU6IF9hcnJheVVuaXF1ZSxcbl9jcmVhdGVSZXNvbHZlcjogX2NyZWF0ZVJlc29sdmVyLFxuX2F0dGFjaENvbnRleHQ6IF9hdHRhY2hDb250ZXh0LFxuX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMsXG5zcGxpbmVDdXJ2ZTogc3BsaW5lQ3VydmUsXG5zcGxpbmVDdXJ2ZU1vbm90b25lOiBzcGxpbmVDdXJ2ZU1vbm90b25lLFxuX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLFxuX2lzRG9tU3VwcG9ydGVkOiBfaXNEb21TdXBwb3J0ZWQsXG5fZ2V0UGFyZW50Tm9kZTogX2dldFBhcmVudE5vZGUsXG5nZXRTdHlsZTogZ2V0U3R5bGUsXG5nZXRSZWxhdGl2ZVBvc2l0aW9uOiBnZXRSZWxhdGl2ZVBvc2l0aW9uJDEsXG5nZXRNYXhpbXVtU2l6ZTogZ2V0TWF4aW11bVNpemUsXG5yZXRpbmFTY2FsZTogcmV0aW5hU2NhbGUsXG5zdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zOiBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLFxucmVhZFVzZWRTaXplOiByZWFkVXNlZFNpemUsXG5mb250U3RyaW5nOiBmb250U3RyaW5nLFxucmVxdWVzdEFuaW1GcmFtZTogcmVxdWVzdEFuaW1GcmFtZSxcbnRocm90dGxlZDogdGhyb3R0bGVkLFxuZGVib3VuY2U6IGRlYm91bmNlLFxuX3RvTGVmdFJpZ2h0Q2VudGVyOiBfdG9MZWZ0UmlnaHRDZW50ZXIsXG5fYWxpZ25TdGFydEVuZDogX2FsaWduU3RhcnRFbmQsXG5fdGV4dFg6IF90ZXh0WCxcbl9wb2ludEluTGluZTogX3BvaW50SW5MaW5lLFxuX3N0ZXBwZWRJbnRlcnBvbGF0aW9uOiBfc3RlcHBlZEludGVycG9sYXRpb24sXG5fYmV6aWVySW50ZXJwb2xhdGlvbjogX2JlemllckludGVycG9sYXRpb24sXG5mb3JtYXROdW1iZXI6IGZvcm1hdE51bWJlcixcbnRvTGluZUhlaWdodDogdG9MaW5lSGVpZ2h0LFxuX3JlYWRWYWx1ZVRvUHJvcHM6IF9yZWFkVmFsdWVUb1Byb3BzLFxudG9UUkJMOiB0b1RSQkwsXG50b1RSQkxDb3JuZXJzOiB0b1RSQkxDb3JuZXJzLFxudG9QYWRkaW5nOiB0b1BhZGRpbmcsXG50b0ZvbnQ6IHRvRm9udCxcbnJlc29sdmU6IHJlc29sdmUsXG5fYWRkR3JhY2U6IF9hZGRHcmFjZSxcbmNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXG5QSTogUEksXG5UQVU6IFRBVSxcblBJVEFVOiBQSVRBVSxcbklORklOSVRZOiBJTkZJTklUWSxcblJBRF9QRVJfREVHOiBSQURfUEVSX0RFRyxcbkhBTEZfUEk6IEhBTEZfUEksXG5RVUFSVEVSX1BJOiBRVUFSVEVSX1BJLFxuVFdPX1RISVJEU19QSTogVFdPX1RISVJEU19QSSxcbmxvZzEwOiBsb2cxMCxcbnNpZ246IHNpZ24sXG5uaWNlTnVtOiBuaWNlTnVtLFxuX2ZhY3Rvcml6ZTogX2ZhY3Rvcml6ZSxcbmlzTnVtYmVyOiBpc051bWJlcixcbmFsbW9zdEVxdWFsczogYWxtb3N0RXF1YWxzLFxuYWxtb3N0V2hvbGU6IGFsbW9zdFdob2xlLFxuX3NldE1pbkFuZE1heEJ5S2V5OiBfc2V0TWluQW5kTWF4QnlLZXksXG50b1JhZGlhbnM6IHRvUmFkaWFucyxcbnRvRGVncmVlczogdG9EZWdyZWVzLFxuX2RlY2ltYWxQbGFjZXM6IF9kZWNpbWFsUGxhY2VzLFxuZ2V0QW5nbGVGcm9tUG9pbnQ6IGdldEFuZ2xlRnJvbVBvaW50LFxuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzOiBkaXN0YW5jZUJldHdlZW5Qb2ludHMsXG5fYW5nbGVEaWZmOiBfYW5nbGVEaWZmLFxuX25vcm1hbGl6ZUFuZ2xlOiBfbm9ybWFsaXplQW5nbGUsXG5fYW5nbGVCZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuX2xpbWl0VmFsdWU6IF9saW1pdFZhbHVlLFxuX2ludDE2UmFuZ2U6IF9pbnQxNlJhbmdlLFxuX2lzQmV0d2VlbjogX2lzQmV0d2VlbixcbmdldFJ0bEFkYXB0ZXI6IGdldFJ0bEFkYXB0ZXIsXG5vdmVycmlkZVRleHREaXJlY3Rpb246IG92ZXJyaWRlVGV4dERpcmVjdGlvbixcbnJlc3RvcmVUZXh0RGlyZWN0aW9uOiByZXN0b3JlVGV4dERpcmVjdGlvbixcbl9ib3VuZFNlZ21lbnQ6IF9ib3VuZFNlZ21lbnQsXG5fYm91bmRTZWdtZW50czogX2JvdW5kU2VnbWVudHMsXG5fY29tcHV0ZVNlZ21lbnRzOiBfY29tcHV0ZVNlZ21lbnRzXG59KTtcblxuY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge31cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICB9XG59XG5cbmNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcbmNvbnN0IGlzTnVsbE9yRW1wdHkgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJyc7XG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gIGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICBpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChhc3BlY3RSYXRpbyB8fCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICBjb25zdCB7eCwgeX0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uJDEoZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMaXN0KSB7XG4gICAgaWYgKG5vZGUgPT09IGNhbnZhcyB8fCBub2RlLmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5jb25zdCBkcnBMaXN0ZW5pbmdDaGFydHMgPSBuZXcgTWFwKCk7XG5sZXQgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IDA7XG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpIHtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0eXBlID09PSAncmVzaXplJykge1xuICAgIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCwgKGFyZ3MpID0+IHtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIFtldmVudCwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gIH0pO1xuICBhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuY2xhc3MgRG9tUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcbiAgICBbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcbiAgICBpZiAoIXByb3h5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgcmV0dXJuICEhKGNvbnRhaW5lciAmJiBjb250YWluZXIuaXNDb25uZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxudmFyIHBsYXRmb3JtcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbl9kZXRlY3RQbGF0Zm9ybTogX2RldGVjdFBsYXRmb3JtLFxuQmFzZVBsYXRmb3JtOiBCYXNlUGxhdGZvcm0sXG5CYXNpY1BsYXRmb3JtOiBCYXNpY1BsYXRmb3JtLFxuRG9tUGxhdGZvcm06IERvbVBsYXRmb3JtXG59KTtcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gY29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBjb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICB0aGlzLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcbiAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCAoZWxhcHNlZCA8IGR1cmF0aW9uKSk7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICBkZWxheTogdW5kZWZpbmVkLFxuICBkdXJhdGlvbjogMTAwMCxcbiAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgZm46IHVuZGVmaW5lZCxcbiAgZnJvbTogdW5kZWZpbmVkLFxuICBsb29wOiB1bmRlZmluZWQsXG4gIHRvOiB1bmRlZmluZWQsXG4gIHR5cGU6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG59KTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgfSxcbiAgbnVtYmVyczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgfSxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG59KTtcbmRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gIGFjdGl2ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMFxuICAgIH1cbiAgfSxcbiAgcmVzaXplOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogMFxuICAgIH1cbiAgfSxcbiAgc2hvdzoge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9LFxuICAgIH1cbiAgfSxcbiAgaGlkZToge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBmbjogdiA9PiB2IHwgMFxuICAgICAgfSxcbiAgICB9XG4gIH1cbn0pO1xuY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzTnVtYmVyRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTtcbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgfVxufVxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcbmNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xuICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgIHVubGlzdGVuQXJyYXlFdmVudHMoX2RhdGEsIHRoaXMpO1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgIGNvbnN0IG9sZFN0YWNrZWQgPSBtZXRhLl9zdGFja2VkO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0U2NvcGVLZXlzKHRoaXMuX3R5cGUpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cywgdHJ1ZSk7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuX3BhcnNpbmcgPSB0aGlzLm9wdGlvbnMucGFyc2luZztcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICB9XG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YTogbWV0YSwgX2RhdGE6IGRhdGF9ID0gdGhpcztcbiAgICBjb25zdCB7aVNjYWxlLCBfc3RhY2tlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiA9ICgpID0+IGN1cltpQXhpc10gPT09IG51bGwgfHwgKHByZXYgJiYgY3VyW2lBeGlzXSA8IHByZXZbaUF4aXNdKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpICsgc3RhcnRdID0gY3VyID0gcGFyc2VkW2ldO1xuICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgaWYgKGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2KCkpIHtcbiAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXRhLl9zb3J0ZWQgPSBzb3J0ZWQ7XG4gICAgfVxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgW2lBeGlzXTogc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpbmRleF0sIGluZGV4KSxcbiAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKGl0ZW1bMF0sIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKGl0ZW1bMV0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHhBeGlzS2V5KSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB5QXhpc0tleSksIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRQYXJzZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW2luZGV4XTtcbiAgfVxuICBnZXREYXRhRWxlbWVudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICB9XG4gIGFwcGx5U3RhY2soc2NhbGUsIHBhcnNlZCwgbW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBjb25zdCBzdGFjayA9IHtcbiAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcbiAgICAgIHZhbHVlczogcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc11cbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNOdW1iZXJGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBpU2NhbGUgPyAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pIDogJycsXG4gICAgICB2YWx1ZTogdlNjYWxlID8gJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKSA6ICcnXG4gICAgfTtcbiAgfVxuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHt9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fZHJhd1N0YXJ0IHx8IDA7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kcmF3Q291bnQgfHwgKGVsZW1lbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBsZXQgaTtcbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUpIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7ICsraSkge1xuICAgICAgYWN0aXZlW2ldLmRyYXcoY3R4LCBhcmVhKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIG1vZGUpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XG4gIH1cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMuJHNoYXJlZCA9IHNoYXJpbmc7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcbiAgICBpZiAoaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSkudXBkYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcbiAgICBlbGVtZW50LmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRTdHlsZShpbmRleCwgYWN0aXZlKTtcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCBmYWxzZSk7XG4gIH1cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuICBfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgZm9yIChjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSBvZiB0aGlzLl9zeW5jTGlzdCkge1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG4gICAgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSwgcmVzZXROZXdFbGVtZW50cyk7XG4gICAgfSBlbHNlIGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgfVxuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBtb3ZlID0gKGFycikgPT4ge1xuICAgICAgYXJyLmxlbmd0aCArPSBjb3VudDtcbiAgICAgIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycltpIC0gY291bnRdO1xuICAgICAgfVxuICAgIH07XG4gICAgbW92ZShkYXRhKTtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcbiAgICBpZiAocmVzZXROZXdFbGVtZW50cykge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhkYXRhLCBzdGFydCwgY291bnQsICdyZXNldCcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9XG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgX3N5bmMoYXJncykge1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICB0aGlzLl9zeW5jTGlzdC5wdXNoKGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSA9IGFyZ3M7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuX2RhdGFDaGFuZ2VzLnB1c2goW3RoaXMuaW5kZXgsIC4uLmFyZ3NdKTtcbiAgfVxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuICBfb25EYXRhU2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIDAsIDFdKTtcbiAgfVxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG5EYXRhc2V0Q29udHJvbGxlci5kZWZhdWx0cyA9IHt9O1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG4gIGdldFByb3BzKHByb3BzLCBmaW5hbCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuRWxlbWVudC5kZWZhdWx0cyA9IHt9O1xuRWxlbWVudC5kZWZhdWx0Um91dGVzID0gdW5kZWZpbmVkO1xuXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG4gIH0sXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodGlja1ZhbHVlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9LFxuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpO1xuICAgIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cbnZhciBUaWNrcyA9IHtmb3JtYXR0ZXJzfTtcblxuZGVmYXVsdHMuc2V0KCdzY2FsZScsIHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgb2Zmc2V0OiBmYWxzZSxcbiAgcmV2ZXJzZTogZmFsc2UsXG4gIGJlZ2luQXRaZXJvOiBmYWxzZSxcbiAgYm91bmRzOiAndGlja3MnLFxuICBncmFjZTogMCxcbiAgZ3JpZDoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGRyYXdCb3JkZXI6IHRydWUsXG4gICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICB0aWNrTGVuZ3RoOiA4LFxuICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgIHRpY2tDb2xvcjogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMuY29sb3IsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG4gICAgYm9yZGVyV2lkdGg6IDFcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICB0ZXh0OiAnJyxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDQsXG4gICAgICBib3R0b206IDRcbiAgICB9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgbWluUm90YXRpb246IDAsXG4gICAgbWF4Um90YXRpb246IDUwLFxuICAgIG1pcnJvcjogZmFsc2UsXG4gICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgIHRleHRTdHJva2VDb2xvcjogJycsXG4gICAgcGFkZGluZzogMyxcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICBsYWJlbE9mZnNldDogMCxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgbWlub3I6IHt9LFxuICAgIG1ham9yOiB7fSxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICBiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICB9XG59KTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnYm9yZGVyQ29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnYmVmb3JlJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYWZ0ZXInKSAmJiBuYW1lICE9PSAnY2FsbGJhY2snICYmIG5hbWUgIT09ICdwYXJzZXInLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZXMnLCB7XG4gIF9mYWxsYmFjazogJ3NjYWxlJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnICYmIG5hbWUgIT09ICdjYWxsYmFjaycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcbn0pO1xuXG5mdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgY29uc3QgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XG4gIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBsZXQgaTtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG4gIG5leHQgPSBzdGFydDtcbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICByZXN1bHQucHVzaChhcnJbTWF0aC5mbG9vcihpKV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjtcbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9mZnNldEdyaWRMaW5lcykge1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gKGxpbmVWYWx1ZSAtIHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4IC0gMSkpIC8gMjtcbiAgICB9XG4gICAgbGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XG4gICAgaWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lVmFsdWU7XG59XG5mdW5jdGlvbiBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCkge1xuICBlYWNoKGNhY2hlcywgKGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZ2MgPSBjYWNoZS5nYztcbiAgICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gICAgbGV0IGk7XG4gICAgaWYgKGdjTGVuID4gbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xuICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG4gICAgICB9XG4gICAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcbiAgcmV0dXJuIChsaW5lcyAqIGZvbnQubGluZUhlaWdodCkgKyBwYWRkaW5nLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuZnVuY3Rpb24gdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpIHtcbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0aXRsZUFyZ3Moc2NhbGUsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKSB7XG4gIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGNoYXJ0fSA9IHNjYWxlO1xuICBjb25zdCB7Y2hhcnRBcmVhLCBzY2FsZXN9ID0gY2hhcnQ7XG4gIGxldCByb3RhdGlvbiA9IDA7XG4gIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cbmNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICByZXR1cm4gcmF3O1xuICB9XG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICB9XG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpO1xuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGxiYWNrKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCBudW1UaWNrcyA9IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKVxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIHRoaXMuYXhpcyA9PT0gJ3gnO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgaWYgKHRoaXMuX21hcmdpbnMpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApO1xuICAgICAgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gICAgfVxuICB9XG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG4gIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoKSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gbGFiZWxbal07XG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge31cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb259ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmJvdHRvbSk7XG4gICAgICB0eTEgPSB0aGlzLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5sZWZ0KTtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0aGlzLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aWNrc0xlbmd0aCAvIGxpbWl0KSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBncmlkLmJvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBsZXQgYmFja2Ryb3A7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYWJlbFNpemVzLndpZHRoc1tpXTtcbiAgICAgICAgbGV0IHRvcCA9IHkgKyB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSB4IC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgIGJhY2tkcm9wLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcbiAgICBpZiAodGlja3MuYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiBhbGlnbjtcbiAgfVxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHR9O1xuICAgIH0gaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2dyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gZ3JpZC5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCB4MSwgeDIsIHkxLCB5MjtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLmJvcmRlcldpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2NvbXB1dGVMYWJlbEFyZWEoKTtcbiAgICBpZiAoYXJlYSkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBpZiAoaXRlbS5iYWNrZHJvcCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gaXRlbS5iYWNrZHJvcC5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGl0ZW0uYmFja2Ryb3AubGVmdCwgaXRlbS5iYWNrZHJvcC50b3AsIGl0ZW0uYmFja2Ryb3Aud2lkdGgsIGl0ZW0uYmFja2Ryb3AuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGxldCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgaXRlbSk7XG4gICAgfVxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0gdG9Gb250KHRpdGxlLmZvbnQpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGUucGFkZGluZyk7XG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICBsZXQgb2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC8gMjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZS50ZXh0LCAwLCAwLCBmb250LCB7XG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdHogPSBvcHRzLnRpY2tzICYmIG9wdHMudGlja3MueiB8fCAwO1xuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGd6ICsgMSxcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgIGlmIChtZXRhW2F4aXNJRF0gPT09IHRoaXMuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG5cbmNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cblxuY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICBhZGRTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG4gIGdldEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICB9XG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XG4gICAgWy4uLmFyZ3NdLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGNvbnN0IHJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGFyZyk7XG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gdGhpcy5wbHVnaW5zICYmIGFyZy5pZCkpIHtcbiAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIHJlZywgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goYXJnLCBpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtUmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoaXRlbSk7XG4gICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydhZnRlcicgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICB9XG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XG4gICAgICBpZiAocmVnLmlzRm9yVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG4gIF9nZXQoaWQsIHR5cGVkUmVnaXN0cnksIHR5cGUpIHtcbiAgICBjb25zdCBpdGVtID0gdHlwZWRSZWdpc3RyeS5nZXQoaWQpO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG59XG52YXIgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcblxuY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuICAgIGlmIChob29rID09PSAnZGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBwbHVnaW5zO1xufVxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywgcGx1Z2luLCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywgcGx1Z2luLCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7c2NyaXB0YWJsZTogZmFsc2UsIGluZGV4YWJsZTogZmFsc2UsIGFsbEtleXM6IHRydWV9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgcmV0dXJuIHNjYWxlT3B0aW9ucy5heGlzIHx8IGF4aXNGcm9tUG9zaXRpb24oc2NhbGVPcHRpb25zLnBvc2l0aW9uKSB8fCBpZC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3QgZmlyc3RJRHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZik7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIGZpcnN0SURzW2F4aXNdID0gZmlyc3RJRHNbYXhpc10gfHwgaWQ7XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGZpcnN0SURzW2F4aXNdIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG4gIHJldHVybiBzY2FsZXM7XG59XG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LFxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjYyB8fCBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pLCBmYWxzZSk7XG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgY29uc3Qgc2NyaXB0YWJsZSA9IGlzU2NyaXB0YWJsZShwcm9wKTtcbiAgICBjb25zdCBpbmRleGFibGUgPSBpc0luZGV4YWJsZShwcm9wKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgaWYgKChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpKVxuICAgICAgfHwgKGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIzLjYuMlwiO1xuXG5jb25zdCBLTk9XTl9QT1NJVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjaGFydEFyZWEnXTtcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IChLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jyk7XG59XG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJSZW5kZXInKTtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25Qcm9ncmVzcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmNvbnN0IGluc3RhbmNlcyA9IHt9O1xuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcyhrZXkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYykgPT4gYy5jYW52YXMgPT09IGNhbnZhcykucG9wKCk7XG59O1xuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICtcblx0XHRcdFx0JyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xuICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG4gICAgdGhpcy5pZCA9IHVpZCgpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW107XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICB0aGlzLiRwcm94aWVzID0ge307XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKG1vZGUgPT4gdGhpcy51cGRhdGUobW9kZSksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiB7YXNwZWN0UmF0aW8sIG1haW50YWluQXNwZWN0UmF0aW99LCB3aWR0aCwgaGVpZ2h0LCBfYXNwZWN0UmF0aW99ID0gdGhpcztcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYXNwZWN0UmF0aW8pKSB7XG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmIChtYWludGFpbkFzcGVjdFJhdGlvICYmIF9hc3BlY3RSYXRpbykge1xuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGNsZWFyQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLmN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XG4gICAgfVxuICB9XG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG4gICAgdGhpcy53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgaWYgKCFyZXRpbmFTY2FsZSh0aGlzLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuICAgIGNhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFt0aGlzLCBuZXdTaXplXSwgdGhpcyk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpID0+IHtcbiAgICAgIGF4aXNPcHRpb25zLmlkID0gYXhpc0lEO1xuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuICAgIGlmIChzY2FsZU9wdHMpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBzY2FsZU9wdHNbaWRdO1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IGlzUmFkaWFsID0gYXhpcyA9PT0gJ3InO1xuICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGF4aXMgPT09ICd4JztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxuICAgICAgICAgICAgZHBvc2l0aW9uOiBpc1JhZGlhbCA/ICdjaGFydEFyZWEnIDogaXNIb3Jpem9udGFsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICAgICAgICBkdHlwZTogaXNSYWRpYWwgPyAncmFkaWFsTGluZWFyJyA6IGlzSG9yaXpvbnRhbCA/ICdjYXRlZ29yeScgOiAnbGluZWFyJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBlYWNoKGl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG4gICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XG4gICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgaWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlc1tpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY2FsZUNsYXNzID0gcmVnaXN0cnkuZ2V0U2NhbGUoc2NhbGVUeXBlKTtcbiAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHlwZTogc2NhbGVUeXBlLFxuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcbiAgICAgIH1cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCkgPT4ge1xuICAgICAgaWYgKCFoYXNVcGRhdGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBjb25zdCBudW1EYXRhID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gbWV0YXNldHMuc2xpY2UoMCkuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcbiAgfVxuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgY29uc3Qge19tZXRhc2V0czogbWV0YXNldHMsIGRhdGE6IHtkYXRhc2V0c319ID0gdGhpcztcbiAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xuICAgIH1cbiAgICBtZXRhc2V0cy5mb3JFYWNoKChtZXRhLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcih4ID0+IHggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xuICAgICAgbWV0YS5sYWJlbCA9ICcnICsgZGF0YXNldC5sYWJlbDtcbiAgICAgIG1ldGEudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKTtcbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGRhdGFzZXRFbGVtZW50VHlwZSAmJiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFzZXRFbGVtZW50VHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgaSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy51cGRhdGUoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFuaW1zRGlzYWJsZWQgPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhb3B0aW9ucy5hbmltYXRpb247XG4gICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xuICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG4gICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gIWFuaW1zRGlzYWJsZWQgJiYgbmV3Q29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSA9PT0gLTE7XG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG4gICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHttb2RlfSk7XG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuICAgIGlmICh0aGlzLl9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcih0aGlzLl9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe2RhdGFzZXRJbmRleDogaX0pIDogbW9kZSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgY29uc3QgYXJncyA9IHttZXRhLCBpbmRleCwgbW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cbiAgZHJhdygpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAodGhpcy5fcmVzaXplQmVmb3JlRHJhdykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNsaXAgPSBtZXRhLl9jbGlwO1xuICAgIGNvbnN0IHVzZUNsaXAgPSAhY2xpcC5kaXNhYmxlZDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge2NoYXJ0OiB0aGlzLCB0eXBlOiAnY2hhcnQnfSkpO1xuICB9XG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cbiAgX3N0b3AoKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2Rlc3Ryb3knKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuICB9XG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuICAgIGVhY2godGhpcy5vcHRpb25zLmV2ZW50cywgKHR5cGUpID0+IF9hZGQodHlwZSwgbGlzdGVuZXIpKTtcbiAgfVxuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IF9yZW1vdmUgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgcGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgZGV0YWNoZWQ7XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIF9yZW1vdmUoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcbiAgICAgIF9hZGQoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIGVhY2godGhpcy5fbGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG4gICAgaWYgKG1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcbiAgICAgIG1ldGEuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIGhvb2ssIGFyZ3MsIGZpbHRlcik7XG4gIH1cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZhdGVkLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7ZXZlbnQ6IGUsIHJlcGxheSwgY2FuY2VsYWJsZTogdHJ1ZX07XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKSA9PiAocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUubmF0aXZlLnR5cGUpO1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5KTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5KSB7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IG9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBsZXQgYWN0aXZlID0gW107XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgbGFzdEV2ZW50ID0gbnVsbDtcbiAgICBpZiAoZS50eXBlICE9PSAnbW91c2VvdXQnKSB7XG4gICAgICBhY3RpdmUgPSB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICBsYXN0RXZlbnQgPSBlLnR5cGUgPT09ICdjbGljaycgPyB0aGlzLl9sYXN0RXZlbnQgOiBlO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgIGlmIChfaXNQb2ludEluQXJlYShlLCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZykpIHtcbiAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcbiAgICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG59XG5jb25zdCBpbnZhbGlkYXRlUGx1Z2lucyA9ICgpID0+IGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG5jb25zdCBlbnVtZXJhYmxlID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYXJ0LCB7XG4gIGRlZmF1bHRzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZGVmYXVsdHNcbiAgfSxcbiAgaW5zdGFuY2VzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogaW5zdGFuY2VzXG4gIH0sXG4gIG92ZXJyaWRlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IG92ZXJyaWRlc1xuICB9LFxuICByZWdpc3RyeToge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHJlZ2lzdHJ5XG4gIH0sXG4gIHZlcnNpb246IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiB2ZXJzaW9uXG4gIH0sXG4gIGdldENoYXJ0OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZ2V0Q2hhcnRcbiAgfSxcbiAgcmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuY2xhc3MgRGF0ZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuICBmb3JtYXRzKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHBhcnNlKHZhbHVlLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBmb3JtYXQodGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBhZGQodGltZXN0YW1wLCBhbW91bnQsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBkaWZmKGEsIGIsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBzdGFydE9mKHRpbWVzdGFtcCwgdW5pdCwgd2Vla2RheSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGVuZE9mKHRpbWVzdGFtcCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcbiAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcbnZhciBfYWRhcHRlcnMgPSB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlclxufTtcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IHZpc2libGVNZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywge2luZmxhdGVBbW91bnR9LCByYXRpbykge1xuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcbiAgICA/IHJhdGlvID09PSAxID8gMC4zMyA6IDBcbiAgICA6IGluZmxhdGVBbW91bnQ7XG59XG5jbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb2JqID0gZGF0YVtpXTtcbiAgICAgIGl0ZW0gPSB7fTtcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgdkF4aXNLZXkpLCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgaWYgKGN1c3RvbSAmJiBzY2FsZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUpIHtcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICBjb25zdCBpbGVuID0gbWV0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgIGxldCBpLCBpdGVtO1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghaXRlbS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB2YWwgPSBpdGVtLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleClbXG4gICAgICAgICAgaXRlbS5jb250cm9sbGVyLl9jYWNoZWRNZXRhLnZTY2FsZS5heGlzXG4gICAgICAgIF07XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbCkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YoaXRlbS5zdGFjaykgPT09IC0xIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgaXRlbS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzdGFja3MucHVzaChpdGVtLnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLmluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cbiAgX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHVuZGVmaW5lZCwgaW5kZXgpLmxlbmd0aDtcbiAgfVxuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTtcbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcbiAgICAgID8gc3RhY2tzLmxlbmd0aCAtIDFcbiAgICAgIDogaW5kZXg7XG4gIH1cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBpeGVscy5wdXNoKGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cbiAgICBjb25zdCBiYXJUaGlja25lc3MgPSBvcHRzLmJhclRoaWNrbmVzcztcbiAgICBjb25zdCBtaW4gPSBiYXJUaGlja25lc3MgfHwgY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcbiAgICBpZiAoTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcbiAgICAgIHNpemUgPSBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkgKiBtaW5CYXJMZW5ndGg7XG4gICAgICBpZiAodmFsdWUgPT09IGFjdHVhbEJhc2UpIHtcbiAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGhlYWQgPSBiYXNlICsgc2l6ZTtcbiAgICB9XG4gICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzaXplLFxuICAgICAgYmFzZSxcbiAgICAgIGhlYWQsXG4gICAgICBjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGluZGV4LCBydWxlcikge1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyB0aGlzLl9nZXRTdGFja0NvdW50KGluZGV4KSA6IHJ1bGVyLnN0YWNrQ291bnQ7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcbiAgICAgICAgPyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudClcbiAgICAgICAgOiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KTtcbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIHNraXBOdWxsID8gaW5kZXggOiB1bmRlZmluZWQpO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCByZWN0cyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5CYXJDb250cm9sbGVyLmlkID0gJ2Jhcic7XG5CYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgYmFyUGVyY2VudGFnZTogMC45LFxuICBncm91cGVkOiB0cnVlLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgfVxuICB9XG59O1xuQmFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBtZXRhLmxhYmVsLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuQnViYmxlQ29udHJvbGxlci5pZCA9ICdidWJibGUnO1xuQnViYmxlQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgIH1cbiAgfVxufTtcbkJ1YmJsZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge31cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbkRvdWdobnV0Q29udHJvbGxlci5pZCA9ICdkb3VnaG51dCc7XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgIH0sXG4gIH0sXG4gIGN1dG91dDogJzUwJScsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnLFxuICBzcGFjaW5nOiAwLFxuICBpbmRleEF4aXM6ICdyJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgICAgbGV0IGRhdGFMYWJlbCA9IHRvb2x0aXBJdGVtLmxhYmVsO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgIGlmIChpc0FycmF5KGRhdGFMYWJlbCkpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuICAgICAgICAgICAgZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgKz0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhTGFiZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG5MaW5lQ29udHJvbGxlci5pZCA9ICdsaW5lJztcbkxpbmVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxufTtcbkxpbmVDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgIH0sXG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbihcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtaW4pLmxvLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pLFxuICAgICAgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heChcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCkpLmhpICsgMSksXG4gICAgICBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbmZ1bmN0aW9uIHNjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbmNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpXSkgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cblBvbGFyQXJlYUNvbnRyb2xsZXIuaWQgPSAncG9sYXJBcmVhJztcblBvbGFyQXJlYUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgIH0sXG4gIH0sXG4gIGluZGV4QXhpczogJ3InLFxuICBzdGFydEFuZ2xlOiAwLFxufTtcblBvbGFyQXJlYUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY2hhcnQuZGF0YS5sYWJlbHNbY29udGV4dC5kYXRhSW5kZXhdICsgJzogJyArIGNvbnRleHQuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc3RhcnRBbmdsZTogMFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG59XG5QaWVDb250cm9sbGVyLmlkID0gJ3BpZSc7XG5QaWVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBjdXRvdXQ6IDAsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnXG59O1xuXG5jbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCBkYXRhc2V0LmRhdGFbaV0pO1xuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuUmFkYXJDb250cm9sbGVyLmlkID0gJ3JhZGFyJztcblJhZGFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBlbGVtZW50czoge1xuICAgIGxpbmU6IHtcbiAgICAgIGZpbGw6ICdzdGFydCdcbiAgICB9XG4gIH0sXG59O1xuUmFkYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBMaW5lQ29udHJvbGxlciB7XG59XG5TY2F0dGVyQ29udHJvbGxlci5pZCA9ICdzY2F0dGVyJztcblNjYXR0ZXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBzaG93TGluZTogZmFsc2UsXG4gIGZpbGw6IGZhbHNlXG59O1xuU2NhdHRlckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBpbnRlcmFjdGlvbjoge1xuICAgIG1vZGU6ICdwb2ludCdcbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gJygnICsgaXRlbS5sYWJlbCArICcsICcgKyBpdGVtLmZvcm1hdHRlZFZhbHVlICsgJyknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb250cm9sbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkJhckNvbnRyb2xsZXI6IEJhckNvbnRyb2xsZXIsXG5CdWJibGVDb250cm9sbGVyOiBCdWJibGVDb250cm9sbGVyLFxuRG91Z2hudXRDb250cm9sbGVyOiBEb3VnaG51dENvbnRyb2xsZXIsXG5MaW5lQ29udHJvbGxlcjogTGluZUNvbnRyb2xsZXIsXG5Qb2xhckFyZWFDb250cm9sbGVyOiBQb2xhckFyZWFDb250cm9sbGVyLFxuUGllQ29udHJvbGxlcjogUGllQ29udHJvbGxlcixcblJhZGFyQ29udHJvbGxlcjogUmFkYXJDb250cm9sbGVyLFxuU2NhdHRlckNvbnRyb2xsZXI6IFNjYXR0ZXJDb250cm9sbGVyXG59KTtcblxuZnVuY3Rpb24gY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzJDEoYXJjLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGFuZ2xlRGVsdGEpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5mdW5jdGlvbiByVGhldGFUb1hZKHIsIHRoZXRhLCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5mdW5jdGlvbiBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmQpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzcGFjaW5nKSB7XG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyQxKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICB9XG4gIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG4gIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICB9XG4gIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcbiAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5mdW5jdGlvbiBkcmF3QXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UgJSBUQVU7XG4gICAgICBpZiAoY2lyY3VtZmVyZW5jZSAlIFRBVSA9PT0gMCkge1xuICAgICAgICBlbmRBbmdsZSArPSBUQVU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCBmdWxsQ2lyY2xlc30gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gZWxlbWVudC5pbm5lclJhZGl1cyArIHBpeGVsTWFyZ2luO1xuICBsZXQgaTtcbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgc3RhcnRBbmdsZSArIFRBVSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3Qm9yZGVyKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSkge1xuICBjb25zdCB7b3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG4gIGlmICghb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSAnYmV2ZWwnO1xuICB9XG4gIGlmIChlbGVtZW50LmZ1bGxDaXJjbGVzKSB7XG4gICAgZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpO1xuICBjdHguc3Ryb2tlKCk7XG59XG5jbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKGNoYXJ0WCwgY2hhcnRZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9IHRoaXMub3B0aW9ucy5zcGFjaW5nIC8gMjtcbiAgICBjb25zdCBfY2lyY3VtZmVyZW5jZSA9IHZhbHVlT3JEZWZhdWx0KGNpcmN1bWZlcmVuY2UsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJyxcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDI7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgbGV0IHJhZGl1c09mZnNldCA9IDA7XG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0IC8gMjtcbiAgICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQpO1xuICAgICAgaWYgKHRoaXMuY2lyY3VtZmVyZW5jZSA+PSBQSSkge1xuICAgICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZyk7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbkFyY0VsZW1lbnQuaWQgPSAnYXJjJztcbkFyY0VsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMixcbiAgb2Zmc2V0OiAwLFxuICBzcGFjaW5nOiAwLFxuICBhbmdsZTogdW5kZWZpbmVkLFxufTtcbkFyY0VsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xufTtcblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cbiAgcmV0dXJuIGxpbmVUbztcbn1cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG4gICAgcHJldiA9IHBvaW50O1xuICB9XG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuICByZXR1cm4gISFsb29wO1xufVxuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICBkZWxldGUgdGhpcy5fcGF0aDtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMgfHwgW107XG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5MaW5lRWxlbWVudC5pZCA9ICdsaW5lJztcbkxpbmVFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICBib3JkZXJXaWR0aDogMyxcbiAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gIGZpbGw6IGZhbHNlLFxuICBzcGFuR2FwczogZmFsc2UsXG4gIHN0ZXBwZWQ6IGZhbHNlLFxuICB0ZW5zaW9uOiAwLFxufTtcbkxpbmVFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuTGluZUVsZW1lbnQuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiB0cnVlLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbn07XG5cbmZ1bmN0aW9uIGluUmFuZ2UkMShlbCwgcG9zLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gKE1hdGguYWJzKHBvcyAtIHZhbHVlKSA8IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXMpO1xufVxuY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgc2l6ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuICBkcmF3KGN0eCwgYXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgdGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XG4gIH1cbn1cblBvaW50RWxlbWVudC5pZCA9ICdwb2ludCc7XG5Qb2ludEVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlcldpZHRoOiAxLFxuICBoaXRSYWRpdXM6IDEsXG4gIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gIGhvdmVyUmFkaXVzOiA0LFxuICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgcmFkaXVzOiAzLFxuICByb3RhdGlvbjogMFxufTtcblBvaW50RWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcblxuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSBiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cbmNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG5CYXJFbGVtZW50LmlkID0gJ2Jhcic7XG5CYXJFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICBib3JkZXJXaWR0aDogMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxufTtcbkJhckVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbnZhciBlbGVtZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkFyY0VsZW1lbnQ6IEFyY0VsZW1lbnQsXG5MaW5lRWxlbWVudDogTGluZUVsZW1lbnQsXG5Qb2ludEVsZW1lbnQ6IFBvaW50RWxlbWVudCxcbkJhckVsZW1lbnQ6IEJhckVsZW1lbnRcbn0pO1xuXG5mdW5jdGlvbiBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGxldCBhID0gc3RhcnQ7XG4gIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcbiAgICBmb3IgKGogPSBhdmdSYW5nZVN0YXJ0OyBqIDwgYXZnUmFuZ2VFbmQ7IGorKykge1xuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICB9XG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xuICAgICAgYXJlYSA9IDAuNSAqIE1hdGguYWJzKFxuICAgICAgICAocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC1cbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxuICAgICAgKTtcbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpIHtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCB4LCB5LCBwcmV2WCwgbWluSW5kZXgsIG1heEluZGV4LCBzdGFydEluZGV4LCBtaW5ZLCBtYXhZO1xuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7dmFsdWU6IGRhdGF9KTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBwb2ludHMpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQpIHtcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxudmFyIHBsdWdpbl9kZWNpbWF0aW9uID0ge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICB9LFxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG4gICAgICBpZiAocmVzb2x2ZShbaW5kZXhBeGlzLCBjaGFydC5vcHRpb25zLmluZGV4QXhpc10pID09PSAneScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEudHlwZSAhPT0gJ2xpbmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICBkZWxldGUgZGF0YXNldC5kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KGNoYXJ0KSB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG5mdW5jdGlvbiBkZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gIH1cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG4gIGlmIChpc051bWJlckZpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgaWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcbiAgICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBsZXQgdGFyZ2V0ID0gbnVsbDtcbiAgbGV0IGhvcml6b250YWw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUuYm90dG9tO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICB0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSkge1xuICAgIGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHRhcmdldCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBzaW1wbGVBcmMge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy54ID0gb3B0cy54O1xuICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCBlbmQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gIGxldCBpLCBjZW50ZXIsIHZhbHVlO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IGVuZDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuZnVuY3Rpb24gZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKGNyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5lbmRdW3Byb3BlcnR5XTtcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgIHJldHVybiBidWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG4gIHJldHVybiBjcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuZnVuY3Rpb24gY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG4gIGlmIChpc0FycmF5KGJvdW5kYXJ5KSkge1xuICAgIF9sb29wID0gdHJ1ZTtcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBwb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuICB3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuICAgIGlmICghaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHZpc2l0ZWQucHVzaChmaWxsKTtcbiAgICBmaWxsID0gdGFyZ2V0LmZpbGw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX2NsaXAoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgdGFyZ2V0LnBhdGgoY3R4KTtcbiAgY3R4LmxpbmVUbyh0YXJnZXQubGFzdCgpLngsIGNsaXBZKTtcbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIGdldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IGZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG4gICAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBib3VuZHMpIHtcbiAgY29uc3Qge3RvcCwgYm90dG9tfSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydCwgZW5kfSA9IGJvdW5kcyB8fCB7fTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3Qoc3RhcnQsIHRvcCwgZW5kIC0gc3RhcnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuZnVuY3Rpb24gX2ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuICBmb3IgKGNvbnN0IHtzb3VyY2U6IHNyYywgdGFyZ2V0OiB0Z3QsIHN0YXJ0LCBlbmR9IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0eWxlOiB7YmFja2dyb3VuZENvbG9yID0gY29sb3J9ID0ge319ID0gc3JjO1xuICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIG5vdFNoYXBlICYmIGdldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcbiAgY3R4LnNhdmUoKTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcgJiYgYmVsb3cgIT09IGFib3ZlKSB7XG4gICAgX2NsaXAoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICBfZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBhYm92ZSwgc2NhbGUsIHByb3BlcnR5fSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIF9jbGlwKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gIH1cbiAgX2ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYmVsb3csIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IHtsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGlmICh0YXJnZXQgJiYgbGluZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICBkb0ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBheGlzfSk7XG4gICAgdW5jbGlwQXJlYShjdHgpO1xuICB9XG59XG52YXIgcGx1Z2luX2ZpbGxlciA9IHtcbiAgaWQ6ICdmaWxsZXInLFxuICBhZnRlckRhdGFzZXRzVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgbGV0IG1ldGEsIGksIGxpbmUsIHNvdXJjZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IGRlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5maWxsID0gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGRyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcbiAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcblxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKSA9PiB7XG4gIGxldCB7Ym94SGVpZ2h0ID0gZm9udFNpemUsIGJveFdpZHRoID0gZm9udFNpemV9ID0gbGFiZWxPcHRzO1xuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBib3hXaWR0aCxcbiAgICBib3hIZWlnaHQsXG4gICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcbiAgfTtcbn07XG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcbmNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcbiAgICB0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYnVpbGRMYWJlbHMoKTtcbiAgICB0aGlzLmZpdCgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgbGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGxldCByb3cgPSAtMTtcbiAgICBsZXQgdG9wID0gLWxpbmVIZWlnaHQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gaXRlbVdpZHRoICsgcGFkZGluZztcbiAgICB9KTtcbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heEhlaWdodCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG4gIGFkanVzdEhpdEJveGVzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IHRoaXM7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGxldCByb3cgPSAwO1xuICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcbiAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wICs9IHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb2wgPSAwO1xuICAgICAgbGV0IHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChoaXRib3guY29sICE9PSBjb2wpIHtcbiAgICAgICAgICBjb2wgPSBoaXRib3guY29sO1xuICAgICAgICAgIHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wID0gdG9wO1xuICAgICAgICBoaXRib3gubGVmdCArPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgdG9wICs9IGhpdGJveC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuICAgICAgdGhpcy5fZHJhdygpO1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBfZHJhdygpIHtcbiAgICBjb25zdCB7b3B0aW9uczogb3B0cywgY29sdW1uU2l6ZXMsIGxpbmVXaWR0aHMsIGN0eH0gPSB0aGlzO1xuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3Qge2NvbG9yOiBmb250Q29sb3IsIHBhZGRpbmd9ID0gbGFiZWxPcHRzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgIGxldCBjdXJzb3I7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgIHJhZGl1czogYm94V2lkdGggKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuICAgICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB5Qm94VG9wID0geSArIE1hdGgubWF4KChmb250U2l6ZSAtIGJveEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuICAgICAgcnRsSGVscGVyLnNldFdpZHRoKHRoaXMud2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG4gICAgICBkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcbiAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN0b3JlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcbiAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcbiAgICBsZXQgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gIH1cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG4gICAgaWYgKF9pc0JldHdlZW4oeCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KVxuICAgICAgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHgsIGhpdEJveC5sZWZ0LCBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aClcbiAgICAgICAgICAmJiBfaXNCZXR3ZWVuKHksIGhpdEJveC50b3AsIGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsYmFjayhvcHRzLm9uQ2xpY2ssIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJyAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5vbkNsaWNrICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdtb3VzZXVwJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcbiAgaWQ6ICdsZWdlbmQnLFxuICBfZWxlbWVudDogTGVnZW5kLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgIGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuXG5jbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG4gIGlkOiAndGl0bGUnLFxuICBfZWxlbWVudDogVGl0bGUsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHBsdWdpbl9zdWJ0aXRsZSA9IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpLCBsZW47XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeCArPSBwb3MueDtcbiAgICAgICAgeSArPSBwb3MueTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggLyBjb3VudCxcbiAgICAgIHk6IHkgLyBjb3VudFxuICAgIH07XG4gIH0sXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcbiAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgY29uc3Qge2xhYmVsLCB2YWx1ZX0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcbiAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHR9ID0gb3B0aW9ucztcbiAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gIGNvbnN0IGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gIGNvbnN0IGJvZHlMaW5lSXRlbUNvdW50ID0gYm9keS5sZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gIH07XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG4gIHdpZHRoUGFkZGluZyA9IDA7XG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5yZXN0b3JlKCk7XG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH0gZWxzZSBpZiAoeSA+IChjaGFydC5oZWlnaHQgLSBoZWlnaHQgLyAyKSkge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfVxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XG4gIGxldCB4QWxpZ24gPSAnY2VudGVyJztcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG4gIHJldHVybiB4QWxpZ247XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3QgeUFsaWduID0gb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxuICAgIHk6IF9saW1pdFZhbHVlKHksIDAsIGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdG9vbHRpcCxcbiAgICB0b29sdGlwSXRlbXMsXG4gICAgdHlwZTogJ3Rvb2x0aXAnXG4gIH0pO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fY2hhcnQgPSBjb25maWcuX2NoYXJ0O1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuX2NoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuX2NoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVUb29sdGlwQ29udGV4dCh0aGlzLl9jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5iZWZvcmVMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIHNjb3BlZC5sYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhzY29wZWQuYWZ0ZXJMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvZHlJdGVtcztcbiAgfVxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSkpO1xuICB9XG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIF9jcmVhdGVJdGVtcyhvcHRpb25zKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5fY2hhcnQsIGFjdGl2ZVtpXSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLml0ZW1Tb3J0KSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydCgoYSwgYikgPT4gb3B0aW9ucy5pdGVtU29ydChhLCBiLCBkYXRhKSk7XG4gICAgfVxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChzY29wZWQubGFiZWxDb2xvci5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsUG9pbnRTdHlsZXMucHVzaChzY29wZWQubGFiZWxQb2ludFN0eWxlLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goc2NvcGVkLmxhYmVsVGV4dENvbG9yLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuICAgIHRoaXMubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBsYWJlbFBvaW50U3R5bGVzO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcbiAgICByZXR1cm4gdG9vbHRpcEl0ZW1zO1xuICB9XG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuX2NoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLl9jaGFydCk7XG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLl9jaGFydCwgdG9vbHRpcDogdGhpcywgcmVwbGF5fSk7XG4gICAgfVxuICB9XG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuICBnZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHtjYXJldFNpemUsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICAgIGNvbnN0IHt4OiBwdFgsIHk6IHB0WX0gPSB0b29sdGlwUG9pbnQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcbiAgICBsZXQgeDEsIHgyLCB4MywgeTEsIHkyLCB5MztcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgKyBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHB0WCArIHdpZHRoO1xuICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSBwdFkgKyBoZWlnaHQ7XG4gICAgICAgIHkyID0geTEgKyBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgKyBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgLSBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB5MyA9IHkxO1xuICAgIH1cbiAgICByZXR1cm4ge3gxLCB4MiwgeDMsIHkxLCB5MiwgeTN9O1xuICB9XG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLnRpdGxlQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLnRpdGxlQ29sb3I7XG4gICAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7XG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuICAgIGlmIChvcHRpb25zLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICByYWRpdXM6IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpIC8gMixcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoIHx8IDE7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9ycy5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3JzLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IG91dGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGggLSBib3hQYWRkaW5nKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIGJveFBhZGRpbmcgLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvcnMuYm9yZGVyUmFkaXVzKTtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYm9keUNvbG9yO1xuICAgIGVhY2godGhpcy5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuICAgICAgbGluZXMgPSBib2R5SXRlbS5saW5lcztcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7XG4gIH1cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHt4LCB5fSA9IHB0O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRvb2x0aXBTaXplO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhvcHRpb25zLmNvcm5lclJhZGl1cyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuX2NoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG4gICAgICB0aGlzLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG4gICAgaWYgKGNoYW5nZWQgfHwgcG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gZXZlbnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFdmVudChlLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgYWN0aXZlID0gW107XG4gICAgaWYgKGUudHlwZSAhPT0gJ21vdXNlb3V0Jykge1xuICAgICAgYWN0aXZlID0gdGhpcy5fY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG4gICAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuICAgIGNoYW5nZWQgPSByZXBsYXkgfHwgIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSkgfHwgcG9zaXRpb25DaGFuZ2VkO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUsIHJlcGxheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblRvb2x0aXAucG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcbnZhciBwbHVnaW5fdG9vbHRpcCA9IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuICBhZnRlckluaXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcCh7X2NoYXJ0OiBjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIHRvb2x0aXBcbiAgICB9O1xuICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodG9vbHRpcCkge1xuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG4gICAgfVxuICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gYXJncy5yZXBsYXk7XG4gICAgICBpZiAoY2hhcnQudG9vbHRpcC5oYW5kbGVFdmVudChhcmdzLmV2ZW50LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGV4dGVybmFsOiBudWxsLFxuICAgIHBvc2l0aW9uOiAnYXZlcmFnZScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICB0aXRsZUNvbG9yOiAnI2ZmZicsXG4gICAgdGl0bGVGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIHRpdGxlU3BhY2luZzogMixcbiAgICB0aXRsZU1hcmdpbkJvdHRvbTogNixcbiAgICB0aXRsZUFsaWduOiAnbGVmdCcsXG4gICAgYm9keUNvbG9yOiAnI2ZmZicsXG4gICAgYm9keVNwYWNpbmc6IDIsXG4gICAgYm9keUZvbnQ6IHtcbiAgICB9LFxuICAgIGJvZHlBbGlnbjogJ2xlZnQnLFxuICAgIGZvb3RlckNvbG9yOiAnI2ZmZicsXG4gICAgZm9vdGVyU3BhY2luZzogMixcbiAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgZm9vdGVyRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmb290ZXJBbGlnbjogJ2xlZnQnLFxuICAgIHBhZGRpbmc6IDYsXG4gICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgIGNhcmV0U2l6ZTogNSxcbiAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgYm94SGVpZ2h0OiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgYm94V2lkdGg6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBkaXNwbGF5Q29sb3JzOiB0cnVlLFxuICAgIGJveFBhZGRpbmc6IDAsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NhcmV0WCcsICdjYXJldFknXSxcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gICAgICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSxcbiAgICAgIGFmdGVyVGl0bGU6IG5vb3AsXG4gICAgICBiZWZvcmVCb2R5OiBub29wLFxuICAgICAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICBsYWJlbCArPSAnOiAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuICAgICAgbGFiZWxDb2xvcih0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICAgICAgfSxcbiAgICAgIGxhYmVsUG9pbnRTdHlsZSh0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhZnRlckxhYmVsOiBub29wLFxuICAgICAgYWZ0ZXJCb2R5OiBub29wLFxuICAgICAgYmVmb3JlRm9vdGVyOiBub29wLFxuICAgICAgZm9vdGVyOiBub29wLFxuICAgICAgYWZ0ZXJGb290ZXI6IG5vb3BcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogJ2ZvbnQnLFxuICAgIGZvb3RlckZvbnQ6ICdmb250JyxcbiAgICB0aXRsZUZvbnQ6ICdmb250J1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFsnaW50ZXJhY3Rpb24nXVxufTtcblxudmFyIHBsdWdpbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5EZWNpbWF0aW9uOiBwbHVnaW5fZGVjaW1hdGlvbixcbkZpbGxlcjogcGx1Z2luX2ZpbGxlcixcbkxlZ2VuZDogcGx1Z2luX2xlZ2VuZCxcblN1YlRpdGxlOiBwbHVnaW5fc3VidGl0bGUsXG5UaXRsZTogcGx1Z2luX3RpdGxlLFxuVG9vbHRpcDogcGx1Z2luX3Rvb2x0aXBcbn0pO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcbiAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XG59XG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cbiAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBhZGRlZCA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHtpbmRleCwgbGFiZWx9IG9mIGFkZGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xuICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbkNhdGVnb3J5U2NhbGUuaWQgPSAnY2F0ZWdvcnknO1xuQ2F0ZWdvcnlTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogQ2F0ZWdvcnlTY2FsZS5wcm90b3R5cGUuZ2V0TGFiZWxGb3JWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG4gIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xuICB9XG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIHNwYWNpbmcgPSBuaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIH1cbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcbiAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICB9XG4gIGlmIChib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgfSBlbHNlIHtcbiAgICBuaWNlTWluID0gcm1pbjtcbiAgICBuaWNlTWF4ID0gcm1heDtcbiAgfVxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBudW1TcGFjZXM7XG4gICAgbmljZU1pbiA9IG1pbjtcbiAgICBuaWNlTWF4ID0gbWF4O1xuICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgIG5pY2VNaW4gPSBtaW5EZWZpbmVkID8gbWluIDogbmljZU1pbjtcbiAgICBuaWNlTWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IG5pY2VNYXg7XG4gICAgbnVtU3BhY2VzID0gY291bnQgLSAxO1xuICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gbnVtU3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuICAgIGlmIChhbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBsZXQgaiA9IDA7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgaWYgKGluY2x1ZGVCb3VuZHMgJiYgbmljZU1pbiAhPT0gbWluKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWlufSk7XG4gICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICBpZiAoYWxtb3N0RXF1YWxzKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yLCBtaW4sIHJlbGF0aXZlTGFiZWxTaXplKG1pbiwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG4gIGZvciAoOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3J9KTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCAmJiBpbmNsdWRlQm91bmRzICYmIG5pY2VNYXggIT09IG1heCkge1xuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiByZWxhdGl2ZUxhYmVsU2l6ZSh2YWx1ZSwgbWluU3BhY2luZywge2hvcml6b250YWwsIG1pblJvdGF0aW9ufSkge1xuICBjb25zdCByYWQgPSB0b1JhZGlhbnMobWluUm90YXRpb24pO1xuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbihtaW5TcGFjaW5nIC8gcmF0aW8sIGxlbmd0aCk7XG59XG5jbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiArcmF3O1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcbiAgICBpZiAoYmVnaW5BdFplcm8pIHtcbiAgICAgIGNvbnN0IG1pblNpZ24gPSBzaWduKG1pbik7XG4gICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xuICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgIHNldE1heCgwKTtcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcbiAgICAgICAgc2V0TWluKDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSAxO1xuICAgICAgaWYgKG1heCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBtaW4gPD0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5hYnMobWF4ICogMC4wNSk7XG4gICAgICB9XG4gICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcbiAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgc2V0TWluKG1pbiAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG4gICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgbGV0IG1heFRpY2tzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcbiAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MkMShudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuXG5jbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gbWF4IDogMTtcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuTGluZWFyU2NhbGUuaWQgPSAnbGluZWFyJztcbkxpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpKSk7XG4gIHJldHVybiByZW1haW4gPT09IDE7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgZW5kRXhwID0gTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWF4KSk7XG4gIGNvbnN0IGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGxldCB0aWNrVmFsID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1pbikpKSk7XG4gIGxldCBleHAgPSBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKTtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih0aWNrVmFsIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGRvIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogdGlja1ZhbCwgbWFqb3I6IGlzTWFqb3IodGlja1ZhbCl9KTtcbiAgICArK3NpZ25pZmljYW5kO1xuICAgIGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gMTtcbiAgICAgICsrZXhwO1xuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgIH1cbiAgICB0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG4gIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XG4gIHRpY2tzLnB1c2goe3ZhbHVlOiBsYXN0VGljaywgbWFqb3I6IGlzTWFqb3IodGlja1ZhbCl9KTtcbiAgcmV0dXJuIHRpY2tzO1xufVxuY2xhc3MgTG9nYXJpdGhtaWNTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbcmF3LCBpbmRleF0pO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgY29uc3QgZXhwID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHYpKSArIG0pO1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoZXhwKG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oZXhwKG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG4gICAgICBzZXRNYXgoZXhwKG1pbiwgKzEpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiBtaW4gPT09IGV4cCh0aGlzLm1pbiwgMCkpIHtcbiAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICB9O1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbkxvZ2FyaXRobWljU2NhbGUuaWQgPSAnbG9nYXJpdGhtaWMnO1xuTG9nYXJpdGhtaWNTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgbGFiZWwgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsIDogW2xhYmVsXTtcbiAgcmV0dXJuIHtcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuICBjb25zdCBmdXJ0aGVzdExpbWl0cyA9IHtcbiAgICBsOiAwLFxuICAgIHI6IHNjYWxlLndpZHRoLFxuICAgIHQ6IDAsXG4gICAgYjogc2NhbGUuaGVpZ2h0IC0gc2NhbGUucGFkZGluZ1RvcFxuICB9O1xuICBjb25zdCBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9EZWdyZWVzKGFuZ2xlUmFkaWFucyk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgaWYgKGhMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy5sKSB7XG4gICAgICBmdXJ0aGVzdExpbWl0cy5sID0gaExpbWl0cy5zdGFydDtcbiAgICAgIGZ1cnRoZXN0QW5nbGVzLmwgPSBhbmdsZVJhZGlhbnM7XG4gICAgfVxuICAgIGlmIChoTGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLnIpIHtcbiAgICAgIGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcbiAgICAgIGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XG4gICAgfVxuICAgIGlmICh2TGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMudCkge1xuICAgICAgZnVydGhlc3RMaW1pdHMudCA9IHZMaW1pdHMuc3RhcnQ7XG4gICAgICBmdXJ0aGVzdEFuZ2xlcy50ID0gYW5nbGVSYWRpYW5zO1xuICAgIH1cbiAgICBpZiAodkxpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5iKSB7XG4gICAgICBmdXJ0aGVzdExpbWl0cy5iID0gdkxpbWl0cy5lbmQ7XG4gICAgICBmdXJ0aGVzdEFuZ2xlcy5iID0gYW5nbGVSYWRpYW5zO1xuICAgIH1cbiAgfVxuICBzY2FsZS5fc2V0UmVkdWN0aW9ucyhzY2FsZS5kcmF3aW5nQXJlYSwgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKTtcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCB0aWNrQmFja2Ryb3BIZWlnaHQgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cyk7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IGV4dHJhID0gKGkgPT09IDAgPyB0aWNrQmFja2Ryb3BIZWlnaHQgLyAyIDogMCk7XG4gICAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nW2ldKTtcbiAgICBjb25zdCBhbmdsZSA9IHRvRGVncmVlcyhzY2FsZS5nZXRJbmRleEFuZ2xlKGkpKTtcbiAgICBjb25zdCBzaXplID0gbGFiZWxTaXplc1tpXTtcbiAgICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gICAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgICBpdGVtcy5wdXNoKHtcbiAgICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgICAgeSxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIGxlZnQsXG4gICAgICB0b3A6IHksXG4gICAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICAgIGJvdHRvbTogeSArIHNpemUuaFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbiwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0c0F0SW5kZXg7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0IC0gcGFkZGluZy5sZWZ0LCB0b3AgLSBwYWRkaW5nLnRvcCwgcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aCwgYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQpO1xuICAgIH1cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuICByZXR1cm4gaXNOdW1iZXIocGFyYW0pID8gcGFyYW0gOiAwO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDI7XG4gICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLndpZHRoIC8gMik7XG4gICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcigodGhpcy5oZWlnaHQgLSB0aGlzLnBhZGRpbmdUb3ApIC8gMik7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGgubWluKHRoaXMuaGVpZ2h0IC0gdGhpcy5wYWRkaW5nVG9wLCB0aGlzLndpZHRoKSAvIDI7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgoZmFsc2UpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCkubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gY2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XG4gICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgIH0pO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9XG4gIF9zZXRSZWR1Y3Rpb25zKGxhcmdlc3RQb3NzaWJsZVJhZGl1cywgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKSB7XG4gICAgbGV0IHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XG4gICAgbGV0IHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIHRoaXMud2lkdGgsIDApIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMucik7XG4gICAgbGV0IHJhZGl1c1JlZHVjdGlvblRvcCA9IC1mdXJ0aGVzdExpbWl0cy50IC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMudCk7XG4gICAgbGV0IHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IC1NYXRoLm1heChmdXJ0aGVzdExpbWl0cy5iIC0gKHRoaXMuaGVpZ2h0IC0gdGhpcy5wYWRkaW5nVG9wKSwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcbiAgICByYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkxlZnQpO1xuICAgIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblJpZ2h0KTtcbiAgICByYWRpdXNSZWR1Y3Rpb25Ub3AgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uVG9wKTtcbiAgICByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5tYXgobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC8gMiwgTWF0aC5taW4oXG4gICAgICBNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25MZWZ0ICsgcmFkaXVzUmVkdWN0aW9uUmlnaHQpIC8gMiksXG4gICAgICBNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25Ub3AgKyByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pIC8gMikpKTtcbiAgICB0aGlzLnNldENlbnRlclBvaW50KHJhZGl1c1JlZHVjdGlvbkxlZnQsIHJhZGl1c1JlZHVjdGlvblJpZ2h0LCByYWRpdXNSZWR1Y3Rpb25Ub3AsIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSk7XG4gIH1cbiAgc2V0Q2VudGVyUG9pbnQobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcbiAgICBjb25zdCBtYXhSaWdodCA9IHRoaXMud2lkdGggLSByaWdodE1vdmVtZW50IC0gdGhpcy5kcmF3aW5nQXJlYTtcbiAgICBjb25zdCBtYXhMZWZ0ID0gbGVmdE1vdmVtZW50ICsgdGhpcy5kcmF3aW5nQXJlYTtcbiAgICBjb25zdCBtYXhUb3AgPSB0b3BNb3ZlbWVudCArIHRoaXMuZHJhd2luZ0FyZWE7XG4gICAgY29uc3QgbWF4Qm90dG9tID0gKHRoaXMuaGVpZ2h0IC0gdGhpcy5wYWRkaW5nVG9wKSAtIGJvdHRvbU1vdmVtZW50IC0gdGhpcy5kcmF3aW5nQXJlYTtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4TGVmdCArIG1heFJpZ2h0KSAvIDIpICsgdGhpcy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgdGhpcy50b3AgKyB0aGlzLnBhZGRpbmdUb3ApO1xuICB9XG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyB0aGlzLmdldExhYmVscygpLmxlbmd0aDtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcbiAgICByZXR1cm4gX25vcm1hbGl6ZUFuZ2xlKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgdG9SYWRpYW5zKHN0YXJ0QW5nbGUpKTtcbiAgfVxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZERpc3RhbmNlID0gZGlzdGFuY2UgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBzY2FsZWREaXN0YW5jZSA6IHRoaXMubWluICsgc2NhbGVkRGlzdGFuY2U7XG4gIH1cbiAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG4gIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlcikge1xuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIEhBTEZfUEk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcbiAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueUNlbnRlcixcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICB9O1xuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGhSYWRpdXNMaW5lKHRoaXMsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5fZW5kVmFsdWUpLCBjaXJjdWxhciwgdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCAtIDEpKTtcbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBmb3IgKGkgPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHt9XG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdUaXRsZSgpIHt9XG59XG5SYWRpYWxMaW5lYXJTY2FsZS5pZCA9ICdyYWRpYWxMaW5lYXInO1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIGFuaW1hdGU6IHRydWUsXG4gIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcbiAgYW5nbGVMaW5lczoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICB9LFxuICBncmlkOiB7XG4gICAgY2lyY3VsYXI6IGZhbHNlXG4gIH0sXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIHRpY2tzOiB7XG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9LFxuICBwb2ludExhYmVsczoge1xuICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBmb250OiB7XG4gICAgICBzaXplOiAxMFxuICAgIH0sXG4gICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuICAgIHBhZGRpbmc6IDVcbiAgfVxufTtcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRSb3V0ZXMgPSB7XG4gICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xufTtcblJhZGlhbExpbmVhclNjYWxlLmRlc2NyaXB0b3JzID0ge1xuICBhbmdsZUxpbmVzOiB7XG4gICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgfVxufTtcblxuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcbmNvbnN0IFVOSVRTID0gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgbGV0IHZhbHVlID0gaW5wdXQ7XG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG4gIGlmICghaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG4gIHJldHVybiArdmFsdWU7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMpIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IF9hZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMpIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGxldCBmaXJzdCwgbGFzdDtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0KHRpbWVPcHRzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG4gICAgaWYgKGFkYXB0ZXIuZGlmZihtYXgsIG1pbiwgbWlub3IpID4gMTAwMDAwICogc3RlcFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoKGEsIGIpID0+IGEgLSBiKS5tYXAoeCA9PiAreCk7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCB8fCAobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KSk7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcbiAgICByZXR1cm4gZm9ybWF0dGVyID8gY2FsbGJhY2soZm9ybWF0dGVyLCBbbGFiZWwsIGluZGV4LCB0aWNrc10sIHRoaXMpIDogbGFiZWw7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIHRoaXMubWluICsgcG9zICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICBjb25zdCB0aWNrc09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIHJldHVybiBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoc29ydGVyKSk7XG4gIH1cbn1cblRpbWVTY2FsZS5pZCA9ICd0aW1lJztcblRpbWVTY2FsZS5kZWZhdWx0cyA9IHtcbiAgYm91bmRzOiAnZGF0YScsXG4gIGFkYXB0ZXJzOiB7fSxcbiAgdGltZToge1xuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdW5pdDogZmFsc2UsXG4gICAgcm91bmQ6IGZhbHNlLFxuICAgIGlzb1dlZWtkYXk6IGZhbHNlLFxuICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgc291cmNlOiAnYXV0bycsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICByZXR1cm4gc3BhbiA/IHByZXZUYXJnZXQgKyAobmV4dFRhcmdldCAtIHByZXZUYXJnZXQpICogKHZhbCAtIHByZXZTb3VyY2UpIC8gc3BhbiA6IHByZXZUYXJnZXQ7XG59XG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIHRoaXMuX21pblBvcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIHRoaXMuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1pbik7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3M7XG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gIH1cbiAgYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXG4gICAgICAgIHt0aW1lOiBtYXgsIHBvczogMX1cbiAgICAgIF07XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICB9XG59XG5UaW1lU2VyaWVzU2NhbGUuaWQgPSAndGltZXNlcmllcyc7XG5UaW1lU2VyaWVzU2NhbGUuZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbnZhciBzY2FsZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5DYXRlZ29yeVNjYWxlOiBDYXRlZ29yeVNjYWxlLFxuTGluZWFyU2NhbGU6IExpbmVhclNjYWxlLFxuTG9nYXJpdGhtaWNTY2FsZTogTG9nYXJpdGhtaWNTY2FsZSxcblJhZGlhbExpbmVhclNjYWxlOiBSYWRpYWxMaW5lYXJTY2FsZSxcblRpbWVTY2FsZTogVGltZVNjYWxlLFxuVGltZVNlcmllc1NjYWxlOiBUaW1lU2VyaWVzU2NhbGVcbn0pO1xuXG5DaGFydC5yZWdpc3Rlcihjb250cm9sbGVycywgc2NhbGVzLCBlbGVtZW50cywgcGx1Z2lucyk7XG5DaGFydC5oZWxwZXJzID0gey4uLmhlbHBlcnN9O1xuQ2hhcnQuX2FkYXB0ZXJzID0gX2FkYXB0ZXJzO1xuQ2hhcnQuQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuQ2hhcnQuQW5pbWF0aW9ucyA9IEFuaW1hdGlvbnM7XG5DaGFydC5hbmltYXRvciA9IGFuaW1hdG9yO1xuQ2hhcnQuY29udHJvbGxlcnMgPSByZWdpc3RyeS5jb250cm9sbGVycy5pdGVtcztcbkNoYXJ0LkRhdGFzZXRDb250cm9sbGVyID0gRGF0YXNldENvbnRyb2xsZXI7XG5DaGFydC5FbGVtZW50ID0gRWxlbWVudDtcbkNoYXJ0LmVsZW1lbnRzID0gZWxlbWVudHM7XG5DaGFydC5JbnRlcmFjdGlvbiA9IEludGVyYWN0aW9uO1xuQ2hhcnQubGF5b3V0cyA9IGxheW91dHM7XG5DaGFydC5wbGF0Zm9ybXMgPSBwbGF0Zm9ybXM7XG5DaGFydC5TY2FsZSA9IFNjYWxlO1xuQ2hhcnQuVGlja3MgPSBUaWNrcztcbk9iamVjdC5hc3NpZ24oQ2hhcnQsIGNvbnRyb2xsZXJzLCBzY2FsZXMsIGVsZW1lbnRzLCBwbHVnaW5zLCBwbGF0Zm9ybXMpO1xuQ2hhcnQuQ2hhcnQgPSBDaGFydDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuQ2hhcnQgPSBDaGFydDtcbn1cblxucmV0dXJuIENoYXJ0O1xuXG59KSkpO1xuIiwiaW1wb3J0IHsgJCB9IGZyb20gXCIuL3V0aWxzXCI7XHJcbmltcG9ydCB7IENoYXJ0fSBmcm9tICdjaGFydC5qcyc7XHJcbmltcG9ydCB7IFNjcmVlbkNvbnRyb2xsZXIgfSBmcm9tIFwiLi9TY3JlZW5Db250cm9sbGVyXCI7XHJcbmltcG9ydCB7IEFwcE1hbmFnZW1lbnQgfSBmcm9tIFwiLi9BcHBNYW5hZ2VtZW50XCI7XHJcbmltcG9ydCB7IFNlcmlhbGl6ZUNvbnRleHQgfSBmcm9tIFwiLi9mbG93Y2hhcnQvU2VyaWFsaXplQ29udGV4dFwiO1xyXG5cclxuZXhwb3J0IGxldCBERV9kZSA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZGUtREUnKTtcclxuZXhwb3J0IGNvbnN0IENIQVJUX0VBQ0hfSU5URVJWQUwgPSAyO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFEQ0V4cGVyaW1lbnRDb250cm9sbGVyIGV4dGVuZHMgU2NyZWVuQ29udHJvbGxlciB7XHJcbiAgICBwcml2YXRlIGJ1dFJlY29yZDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGJ1dFN0b3A6IEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBidXREZWxldGU6IEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgcHJpdmF0ZSB0Ym9keTogSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIHRmaXJzdFJvdzogSFRNTFRhYmxlUm93RWxlbWVudDtcclxuICAgIHByaXZhdGUgdGltZXI6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgY2hhcnQ6IENoYXJ0O1xyXG4gICAgcHJpdmF0ZSBjb3VudGVyID0gMTAgXiA2O1xyXG4gICAgcHJpdmF0ZSBzZWNvbmRzID0gMDtcclxuXHJcbiAgICBwcml2YXRlIHJlY29yZGluZyA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBvbkZpcnN0U3RhcnQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7IHRoaXMuc2VuZEFuZFJlY2VpdmUoKTsgfSwgMTAwMCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25SZXN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnNlbmRBbmRSZWNlaXZlKCk7IH0sIDEwMDApO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uU3RvcCgpOiB2b2lkIHtcclxuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgICB0aGlzLmJ1dFN0b3AuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmJ1dFJlY29yZC5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvdW50ZXIgPSAxMCBeIDY7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25DcmVhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldERhdGEoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0RGF0YSgpIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEhLmxhYmVscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YSEuZGF0YXNldHMhLmZvckVhY2goKGRhdGFzZXQpID0+IHtcclxuICAgICAgICAgICAgZGF0YXNldCEuZGF0YSA9IFtdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy50Ym9keS5pbm5lclRleHQgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZW5kQW5kUmVjZWl2ZSgpIHtcclxuXHJcbiAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcclxuICAgICAgICB4aHIub25lcnJvciA9IChlKSA9PiB7IGNvbnNvbGUubG9nKFwiRmVobGVyIGJlaW0gWE1MSHR0cFJlcXVlc3QhXCIpOyB9O1xyXG4gICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIFwiL2FkY2V4cGVyaW1lbnRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICB4aHIub25sb2FkID0gKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IFZhbHVlczogbnVtYmVyW109WzAsMCwwLDBdO1xyXG4gICAgICAgICAgICBsZXQgYXJyYXlCdWZmZXIgPSB4aHIucmVzcG9uc2U7IC8vIE5vdGU6IG5vdCBvUmVxLnJlc3BvbnNlVGV4dFxyXG4gICAgICAgICAgICBpZiAoYXJyYXlCdWZmZXIgfHwgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCA9PSA0ICsgNCArIDQgKyA0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3R4ID0gbmV3IFNlcmlhbGl6ZUNvbnRleHQoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgVmFsdWVzWzBdID0gY3R4LnJlYWRGMzIoKTtcclxuICAgICAgICAgICAgICAgIFZhbHVlc1sxXSA9IGN0eC5yZWFkRjMyKCk7XHJcbiAgICAgICAgICAgICAgICBWYWx1ZXNbMl0gPSBjdHgucmVhZEYzMigpO1xyXG4gICAgICAgICAgICAgICAgVmFsdWVzWzNdID0gY3R4LnJlYWRGMzIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbm93ID0gbmV3IERhdGUoRGF0ZS5ub3coKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWNvcmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ciA9ICQuSHRtbEFzRmlyc3RDaGlsZCh0aGlzLnRib2R5LCBcInRyXCIsIFtdKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJC5IdG1sKHRyLCBcInRkXCIsIFtdLCBbXSwgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5baV0udGV4dENvbnRlbnQhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPj0gQ0hBUlRfRUFDSF9JTlRFUlZBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYXJ0LmRhdGEhLmxhYmVscyEubGVuZ3RoID4gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YSEubGFiZWxzPy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEhLmRhdGFzZXRzIS5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhc2V0IS5kYXRhIS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhIS5sYWJlbHMhLnB1c2gobm93LnRvTG9jYWxlVGltZVN0cmluZyhcImRlLURFXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGE/LmRhdGFzZXRzIVswXS5kYXRhPy5wdXNoKFZhbHVlc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhPy5kYXRhc2V0cyFbMV0uZGF0YT8ucHVzaChWYWx1ZXNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YT8uZGF0YXNldHMhWzJdLmRhdGE/LnB1c2goVmFsdWVzWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGE/LmRhdGFzZXRzIVszXS5kYXRhPy5wdXNoKFZhbHVlc1szXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudGVyKys7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRmaXJzdFJvdy5jaGlsZHJlblswXS50ZXh0Q29udGVudCA9IG5vdy50b0xvY2FsZVRpbWVTdHJpbmcoXCJkZS1ERVwiKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bMV0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQodGhpcy5zZWNvbmRzKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bMl0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoVmFsdWVzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bM10udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoVmFsdWVzWzFdKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bNF0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoVmFsdWVzWzJdKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bNV0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoVmFsdWVzWzNdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5zZW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwTWFuYWdlbWVudDpBcHBNYW5hZ2VtZW50LCBkaXY6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwTWFuYWdlbWVudCwgZGl2KTtcclxuICAgICAgICB0aGlzLmJ1dFJlY29yZCA9IDxIVE1MQnV0dG9uRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFkY2V4cGVyaW1lbnRfYnV0UmVjb3JkXCIpITtcclxuICAgICAgICB0aGlzLmJ1dFN0b3AgPSA8SFRNTEJ1dHRvbkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZGNleHBlcmltZW50X2J1dFN0b3BcIikhO1xyXG4gICAgICAgIHRoaXMuYnV0U3RvcC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYnV0RGVsZXRlID0gPEhUTUxCdXR0b25FbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRjZXhwZXJpbWVudF9idXREZWxldGVcIikhO1xyXG4gICAgICAgIHRoaXMudGJvZHkgPSA8SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZGNleHBlcmltZW50X3RhYkJvZHlcIikhO1xyXG4gICAgICAgIHRoaXMudGZpcnN0Um93ID0gPEhUTUxUYWJsZVJvd0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZGNleHBlcmltZW50X3RhYkZpcnN0Um93XCIpITtcclxuXHJcbiAgICAgICAgbGV0IGN0eCA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWRjZXhwZXJpbWVudF9jaGFydCcpITtcclxuICAgICAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCx7XHJcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxzOiBbXSxcclxuICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJJbnB1dCAwIFtWXVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIklucHV0IDEgW1ZdXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiZ3JlZW5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiZ3JlZW5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIklucHV0IDIgW1ZdXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJibHVlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJJbnB1dCAzIFtWXVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImdyZXlcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiZ3JleVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBob3Zlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6ICduZWFyZXN0JyxcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Q6IHRydWVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzY2FsZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICB5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmJ1dFN0b3Aub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0U3RvcC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dFJlY29yZC5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmJ1dFJlY29yZC5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idXRSZWNvcmQuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXRTdG9wLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZGluZyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5idXREZWxldGUub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXREYXRhKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyAkIH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuaW1wb3J0IHsgQ2hhcnR9IGZyb20gJ2NoYXJ0LmpzJztcclxuaW1wb3J0IHsgU2NyZWVuQ29udHJvbGxlciB9IGZyb20gXCIuL1NjcmVlbkNvbnRyb2xsZXJcIjtcclxuaW1wb3J0IHsgQXBwTWFuYWdlbWVudCB9IGZyb20gXCIuL0FwcE1hbmFnZW1lbnRcIjtcclxuaW1wb3J0IHsgU2VyaWFsaXplQ29udGV4dCB9IGZyb20gXCIuL2Zsb3djaGFydC9TZXJpYWxpemVDb250ZXh0XCI7XHJcblxyXG5jb25zdCBERV9kZSA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZGUtREUnKTtcclxuY29uc3QgQ0hBUlRfRUFDSF9JTlRFUlZBTCA9IDI7XHJcblxyXG5leHBvcnQgY2xhc3MgQWlyc3BlZWRFeHBlcmltZW50Q29udHJvbGxlciBleHRlbmRzIFNjcmVlbkNvbnRyb2xsZXIge1xyXG4gICAgcHJpdmF0ZSBidXRSZWNvcmQ6IEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBidXRTdG9wOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgIHByaXZhdGUgYnV0RGVsZXRlOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgIHByaXZhdGUgdGJvZHk6IEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50O1xyXG4gICAgcHJpdmF0ZSB0Zmlyc3RSb3c6IEhUTUxUYWJsZVJvd0VsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0U2V0cG9pbnRGYW46IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0U2V0cG9pbnRBaXJzcGVlZDogSFRNTElucHV0RWxlbWVudDtcclxuICAgIHByaXZhdGUgaW5wdXRTZXJ2b0NMOiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBpbnB1dFNlcnZvT0w6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0S1A6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0S0k6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0S0Q6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIHRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIGNoYXJ0OiBDaGFydDtcclxuICAgIHByaXZhdGUgY291bnRlciA9IDEwIF4gNjtcclxuICAgIHByaXZhdGUgbW9kZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc2Vjb25kcyA9IDA7XHJcblxyXG4gICAgcHJpdmF0ZSByZWNvcmRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBwdWJsaWMgb25GaXJzdFN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnNlbmRBbmRSZWNlaXZlKCk7IH0sIDEwMDApO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uUmVzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnRpbWVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHsgdGhpcy5zZW5kQW5kUmVjZWl2ZSgpOyB9LCAxMDAwKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvblN0b3AoKTogdm9pZCB7XHJcbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgICAgdGhpcy5idXRTdG9wLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5idXRSZWNvcmQuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMTAgXiA2O1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ3JlYXRlKCkge1xyXG4gICAgICAgIHRoaXMucmVzZXREYXRhKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVzZXREYXRhKCkge1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YSEubGFiZWxzID0gW107XHJcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhIS5kYXRhc2V0cyEuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xyXG4gICAgICAgICAgICBkYXRhc2V0IS5kYXRhID0gW107XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLnRib2R5LmlubmVyVGV4dCA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRzID0gMDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBvbk1vZGVDaGFuZ2UobmV3TW9kZTogbnVtYmVyKSB7XHJcbiAgICAgICAgc3dpdGNoIChuZXdNb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5haXJzcGVlZGV4cGVyaW1lbnRfY2xvc2VkbG9vcGN0cmwnKS5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxIVE1MRWxlbWVudD52KS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5haXJzcGVlZGV4cGVyaW1lbnRfb3Blbmxvb3BjdHJsJykuZm9yRWFjaCgodiwgaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICg8SFRNTEVsZW1lbnQ+dikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFpcnNwZWVkZXhwZXJpbWVudF9jbG9zZWRsb29wY3RybCcpLmZvckVhY2goKHYsIGspID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAoPEhUTUxFbGVtZW50PnYpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFpcnNwZWVkZXhwZXJpbWVudF9vcGVubG9vcGN0cmwnKS5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxIVE1MRWxlbWVudD52KS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5haXJzcGVlZGV4cGVyaW1lbnRfY2xvc2VkbG9vcGN0cmwnKS5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxIVE1MRWxlbWVudD52KS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFpcnNwZWVkZXhwZXJpbWVudF9vcGVubG9vcGN0cmwnKS5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxIVE1MRWxlbWVudD52KS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2VuZEFuZFJlY2VpdmUoKSB7XHJcbiAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigyNTYpO1xyXG4gICAgICAgIGxldCBjdHggPSBuZXcgU2VyaWFsaXplQ29udGV4dChidWZmZXIpO1xyXG4gICAgICAgIGN0eC53cml0ZVUzMih0aGlzLm1vZGUpO1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT0gMCkge1xyXG4gICAgICAgICAgICBjdHgud3JpdGVGMzIoMCk7XHJcbiAgICAgICAgICAgIGN0eC53cml0ZUYzMigwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PSAxKSB7XHJcbiAgICAgICAgICAgIGN0eC53cml0ZUYzMih0aGlzLmlucHV0U2V0cG9pbnRGYW4udmFsdWVBc051bWJlcik7XHJcbiAgICAgICAgICAgIGN0eC53cml0ZUYzMih0aGlzLmlucHV0U2Vydm9PTC52YWx1ZUFzTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN0eC53cml0ZUYzMih0aGlzLmlucHV0U2V0cG9pbnRBaXJzcGVlZC52YWx1ZUFzTnVtYmVyKTtcclxuICAgICAgICAgICAgY3R4LndyaXRlRjMyKHRoaXMuaW5wdXRTZXJ2b0NMLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgud3JpdGVGMzIodGhpcy5pbnB1dEtQLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgIGN0eC53cml0ZUYzMih0aGlzLmlucHV0S0kudmFsdWVBc051bWJlcik7XHJcbiAgICAgICAgY3R4LndyaXRlRjMyKHRoaXMuaW5wdXRLRC52YWx1ZUFzTnVtYmVyKTtcclxuXHJcbiAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcclxuICAgICAgICB4aHIub25lcnJvciA9IChlKSA9PiB7IGNvbnNvbGUubG9nKFwiRmVobGVyIGJlaW0gWE1MSHR0cFJlcXVlc3QhXCIpOyB9O1xyXG4gICAgICAgIHhoci5vcGVuKFwiUFVUXCIsIFwiL2FpcnNwZWVkZXhwZXJpbWVudFwiLCB0cnVlKTtcclxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgIHhoci5vbmxvYWQgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgU2V0cG9pbnRBaXJzcGVlZDogbnVtYmVyLCBGYW46IG51bWJlciwgU2Vydm86IG51bWJlciwgQWN0dWFsQWlyc3BlZWQ6IG51bWJlcjtcclxuICAgICAgICAgICAgbGV0IGFycmF5QnVmZmVyID0geGhyLnJlc3BvbnNlOyAvLyBOb3RlOiBub3Qgb1JlcS5yZXNwb25zZVRleHRcclxuICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlciB8fCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoICE9IDQgKyA0ICsgNCArIDQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIhIGFycmF5QnVmZmVyIHx8IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGghPTQrNCs0KzRcIik7XHJcbiAgICAgICAgICAgICAgICBTZXRwb2ludEFpcnNwZWVkID0gMDtcclxuICAgICAgICAgICAgICAgIEZhbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBTZXJ2byA9IDA7XHJcbiAgICAgICAgICAgICAgICBBY3R1YWxBaXJzcGVlZCA9IDIwICsgKC01ICsgMTAgKiBNYXRoLnJhbmRvbSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdHggPSBuZXcgU2VyaWFsaXplQ29udGV4dChhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBTZXRwb2ludEFpcnNwZWVkID0gY3R4LnJlYWRGMzIoKTtcclxuICAgICAgICAgICAgICAgIEZhbiA9IGN0eC5yZWFkRjMyKCk7XHJcbiAgICAgICAgICAgICAgICBTZXJ2byA9IGN0eC5yZWFkRjMyKCk7XHJcbiAgICAgICAgICAgICAgICBBY3R1YWxBaXJzcGVlZCA9IGN0eC5yZWFkRjMyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG5vdyA9IG5ldyBEYXRlKERhdGUubm93KCkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucmVjb3JkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSAkLkh0bWxBc0ZpcnN0Q2hpbGQodGhpcy50Ym9keSwgXCJ0clwiLCBbXSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICQuSHRtbCh0ciwgXCJ0ZFwiLCBbXSwgW10sIHRoaXMudGZpcnN0Um93LmNoaWxkcmVuW2ldLnRleHRDb250ZW50ISk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudGVyID49IENIQVJUX0VBQ0hfSU5URVJWQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFydC5kYXRhIS5sYWJlbHMhLmxlbmd0aCA+IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEhLmxhYmVscz8uc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhIS5kYXRhc2V0cyEuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldCEuZGF0YSEuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YSEubGFiZWxzIS5wdXNoKG5vdy50b0xvY2FsZVRpbWVTdHJpbmcoXCJkZS1ERVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhPy5kYXRhc2V0cyFbMF0uZGF0YT8ucHVzaChTZXRwb2ludEFpcnNwZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGE/LmRhdGFzZXRzIVsxXS5kYXRhPy5wdXNoKEFjdHVhbEFpcnNwZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGE/LmRhdGFzZXRzIVsyXS5kYXRhPy5wdXNoKEZhbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhPy5kYXRhc2V0cyFbM10uZGF0YT8ucHVzaChTZXJ2byk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudGVyKys7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRmaXJzdFJvdy5jaGlsZHJlblswXS50ZXh0Q29udGVudCA9IG5vdy50b0xvY2FsZVRpbWVTdHJpbmcoXCJkZS1ERVwiKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bMV0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQodGhpcy5zZWNvbmRzKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bMl0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoU2V0cG9pbnRBaXJzcGVlZCk7XHJcbiAgICAgICAgICAgIHRoaXMudGZpcnN0Um93LmNoaWxkcmVuWzNdLnRleHRDb250ZW50ID0gREVfZGUuZm9ybWF0KEFjdHVhbEFpcnNwZWVkKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bNF0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoRmFuKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bNV0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoU2Vydm8pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgeGhyLnNlbmQoY3R4LmdldFJlc3VsdCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHBNYW5hZ2VtZW50OkFwcE1hbmFnZW1lbnQsIGRpdjogSFRNTERpdkVsZW1lbnQpIHtcclxuICAgICAgICBzdXBlcihhcHBNYW5hZ2VtZW50LCBkaXYpO1xyXG4gICAgICAgIHRoaXMuYnV0UmVjb3JkID0gPEhUTUxCdXR0b25FbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWlyc3BlZWRleHBlcmltZW50X2J1dFJlY29yZFwiKSE7XHJcbiAgICAgICAgdGhpcy5idXRTdG9wID0gPEhUTUxCdXR0b25FbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWlyc3BlZWRleHBlcmltZW50X2J1dFN0b3BcIikhO1xyXG4gICAgICAgIHRoaXMuYnV0U3RvcC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYnV0RGVsZXRlID0gPEhUTUxCdXR0b25FbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWlyc3BlZWRleHBlcmltZW50X2J1dERlbGV0ZVwiKSE7XHJcbiAgICAgICAgdGhpcy50Ym9keSA9IDxIVE1MVGFibGVTZWN0aW9uRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFpcnNwZWVkZXhwZXJpbWVudF90YWJCb2R5XCIpITtcclxuICAgICAgICB0aGlzLnRmaXJzdFJvdyA9IDxIVE1MVGFibGVSb3dFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWlyc3BlZWRleHBlcmltZW50X3RhYkZpcnN0Um93XCIpITtcclxuICAgICAgICB0aGlzLmlucHV0U2V0cG9pbnRGYW4gPSA8SFRNTElucHV0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFpcnNwZWVkZXhwZXJpbWVudF9pbnBTZXRwb2ludEZhblwiKTtcclxuICAgICAgICB0aGlzLmlucHV0U2Vydm9PTCA9IDxIVE1MSW5wdXRFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWlyc3BlZWRleHBlcmltZW50X2lucEZhbk9MXCIpITtcclxuICAgICAgICB0aGlzLmlucHV0U2V0cG9pbnRBaXJzcGVlZCA9IDxIVE1MSW5wdXRFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWlyc3BlZWRleHBlcmltZW50X2lucFNldHBvaW50QWlyc3BlZWRcIik7XHJcbiAgICAgICAgdGhpcy5pbnB1dFNlcnZvQ0wgPSA8SFRNTElucHV0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFpcnNwZWVkZXhwZXJpbWVudF9pbnBGYW5DTFwiKSE7XHJcblxyXG4gICAgICAgIHRoaXMuaW5wdXRLUCA9IDxIVE1MSW5wdXRFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWlyc3BlZWRleHBlcmltZW50X2lucEtQXCIpITtcclxuICAgICAgICB0aGlzLmlucHV0S0kgPSA8SFRNTElucHV0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFpcnNwZWVkZXhwZXJpbWVudF9pbnBLSVwiKSE7XHJcbiAgICAgICAgdGhpcy5pbnB1dEtEID0gPEhUTUxJbnB1dEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhaXJzcGVlZGV4cGVyaW1lbnRfaW5wS0RcIikhO1xyXG5cclxuICAgICAgICB0aGlzLm9uTW9kZUNoYW5nZSgwKTtcclxuXHJcbiAgICAgICAgbGV0IGN0eCA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWlyc3BlZWRleHBlcmltZW50X2NoYXJ0JykhO1xyXG4gICAgICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxzOiBbXSxcclxuICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJTZXRwb2ludCBBaXJzcGVlZCBbbS9zXVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIkFjdHVhbCBBaXJzcGVlZCBbbS9zXVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImdyZWVuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcImdyZWVuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJGYW4gUG93ZXIgWyVdXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJibHVlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJTZXJ2byBQb3NpdGlvbiBbZGVnXVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImdyZXlcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiZ3JleVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBob3Zlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6ICduZWFyZXN0JyxcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Q6IHRydWVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzY2FsZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICB5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT1cImFpcnNwZWVkZXhwZXJpbWVudF9tb2RlXCJdJykuZm9yRWFjaCgodiwgaykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5wID0gPEhUTUxJbnB1dEVsZW1lbnQ+djtcclxuICAgICAgICAgICAgaW5wLm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG51bSA9IHBhcnNlSW50KGlucC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2RlICE9IG51bSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZUNoYW5nZShudW0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgc2V0QnViYmxlID0gKHJhbmdlOiBIVE1MSW5wdXRFbGVtZW50LCBidWJibGU6IEhUTUxPdXRwdXRFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB2YWwgPSByYW5nZS52YWx1ZUFzTnVtYmVyO1xyXG4gICAgICAgICAgICBsZXQgbWluID0gcmFuZ2UubWluID8gcGFyc2VJbnQocmFuZ2UubWluKSA6IDA7XHJcbiAgICAgICAgICAgIGxldCBtYXggPSByYW5nZS5tYXggPyBwYXJzZUludChyYW5nZS5tYXgpIDogMTAwO1xyXG4gICAgICAgICAgICBsZXQgbmV3VmFsID0gKCh2YWwgLSBtaW4pICogMTAwKSAvIChtYXggLSBtaW4pO1xyXG4gICAgICAgICAgICBidWJibGUuaW5uZXJIVE1MID0gXCJcIiArIHZhbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvcnRhIG1hZ2ljIG51bWJlcnMgYmFzZWQgb24gc2l6ZSBvZiB0aGUgbmF0aXZlIFVJIHRodW1iXHJcbiAgICAgICAgICAgIGJ1YmJsZS5zdHlsZS5sZWZ0ID0gYGNhbGMoJHtuZXdWYWx9JSArICgkezggLSBuZXdWYWwgKiAwLjE1fXB4KSlgO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIucmFuZ2Utd3JhcC5haXJzcGVlZGV4cGVyaW1lbnRcIikuZm9yRWFjaCh3cmFwID0+IHtcclxuICAgICAgICAgICAgbGV0IHJhbmdlID0gPEhUTUxJbnB1dEVsZW1lbnQ+d3JhcC5xdWVyeVNlbGVjdG9yKFwiaW5wdXRbdHlwZT0ncmFuZ2UnXVwiKSE7XHJcbiAgICAgICAgICAgIGxldCBidWJibGUgPSA8SFRNTE91dHB1dEVsZW1lbnQ+d3JhcC5xdWVyeVNlbGVjdG9yKFwib3V0cHV0LmJ1YmJsZVwiKSE7XHJcbiAgICAgICAgICAgIHJhbmdlLm9uaW5wdXQgPSAoZSkgPT4gc2V0QnViYmxlKHJhbmdlLCBidWJibGUpO1xyXG4gICAgICAgICAgICBzZXRCdWJibGUocmFuZ2UsIGJ1YmJsZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmJ1dFN0b3Aub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0U3RvcC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dFJlY29yZC5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmJ1dFJlY29yZC5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idXRSZWNvcmQuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXRTdG9wLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZGluZyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5idXREZWxldGUub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXREYXRhKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBIZWF0ZXJFeHBlcmltZW50Q29udHJvbGxlciB9IGZyb20gXCIuL0hlYXRlckV4cGVyaW1lbnRDb250cm9sbGVyXCI7XHJcbmltcG9ydCB7IFNjcmVlbkNvbnRyb2xsZXIsIENvbnRyb2xsZXJTdGF0ZSB9IGZyb20gXCIuL1NjcmVlbkNvbnRyb2xsZXJcIjtcclxuaW1wb3J0IHsgRGV2ZWxvcENGQ0NvbnRyb2xsZXIgfSBmcm9tIFwiLi9EZXZlbG9wQ0ZDQ29udHJvbGxlclwiO1xyXG5pbXBvcnQgeyBEaWFsb2dDb250cm9sbGVyIH0gZnJvbSBcIi4vRGlhbG9nQ29udHJvbGxlclwiO1xyXG5pbXBvcnQgeyBBcHBNYW5hZ2VtZW50IH0gZnJvbSBcIi4vQXBwTWFuYWdlbWVudFwiO1xyXG5pbXBvcnQgeyBBRENFeHBlcmltZW50Q29udHJvbGxlciB9IGZyb20gXCIuL0FEQ0V4cGVyaW1lbnRDb250cm9sbGVyXCI7XHJcbmltcG9ydCB7IEFpcnNwZWVkRXhwZXJpbWVudENvbnRyb2xsZXIgfSBmcm9tIFwiLi9BaXJzcGVlZEV4cGVyaW1lbnRDb250cm9sbGVyXCI7XHJcbmltcG9ydCB7RkZURXhwZXJpbWVudENvbnRyb2xsZXJ9IGZyb20gXCIuL0ZGVEV4cGVyaW1lbnRDb250cm9sbGVyXCI7XHJcblxyXG5jbGFzcyBEYXNoYm9hcmRDb250cm9sbGVyIGV4dGVuZHMgU2NyZWVuQ29udHJvbGxlciB7XHJcbiAgICBwdWJsaWMgb25GaXJzdFN0YXJ0KCk6IHZvaWQgeyB9XHJcbiAgICBwdWJsaWMgb25SZXN0YXJ0KCk6IHZvaWQgeyB9XHJcbiAgICBwdWJsaWMgb25TdG9wKCk6IHZvaWQgeyB9XHJcbiAgICBwdWJsaWMgb25DcmVhdGUoKSB7IH1cclxuICAgIGNvbnN0cnVjdG9yKGFwcE1hbmFnZW1lbnQ6QXBwTWFuYWdlbWVudCwgZGl2OiBIVE1MRGl2RWxlbWVudCkge1xyXG4gICAgICAgIHN1cGVyKGFwcE1hbmFnZW1lbnQsIGRpdik7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBSZXBvcnRzQ29udHJvbGxlciBleHRlbmRzIFNjcmVlbkNvbnRyb2xsZXIge1xyXG4gICAgcHVibGljIG9uRmlyc3RTdGFydCgpOiB2b2lkIHsgfVxyXG4gICAgcHVibGljIG9uUmVzdGFydCgpOiB2b2lkIHsgfVxyXG4gICAgcHVibGljIG9uU3RvcCgpOiB2b2lkIHsgfVxyXG4gICAgY29uc3RydWN0b3IoYXBwTWFuYWdlbWVudDpBcHBNYW5hZ2VtZW50LCBkaXY6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwTWFuYWdlbWVudCwgZGl2KTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNyZWF0ZSgpIHtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIEFwcENvbnRyb2xsZXIgaW1wbGVtZW50cyBBcHBNYW5hZ2VtZW50IHtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRlRGl2OiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHByaXZhdGUgYWN0aXZlQ29udHJvbGxlckluZGV4OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHNjcmVlbkNvbnRyb2xsZXJzOiBTY3JlZW5Db250cm9sbGVyW107XHJcbiAgICBwcml2YXRlIGRpYWxvZ0NvbnRyb2xsZXI6RGlhbG9nQ29udHJvbGxlcjtcclxuXHJcbiAgICBwdWJsaWMgRGlhbG9nQ29udHJvbGxlcigpIHsgcmV0dXJuIHRoaXMuZGlhbG9nQ29udHJvbGxlcjsgfTtcclxuXHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc3RhdGVEaXYgPSA8SFRNTERpdkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcG5Db25uZWN0aW9uU3RhdGVcIikhO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuQ29udHJvbGxlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5kaWFsb2dDb250cm9sbGVyPW5ldyBEaWFsb2dDb250cm9sbGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgU2V0QXBwbGljYXRpb25TdGF0ZShzdGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZURpdi5pbm5lckhUTUwgPSBzdGF0ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZXRBY3RpdmVTY3JlZW4obmV3SW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuc2NyZWVuQ29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlciwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSBuZXdJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5zaG93RElWKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5TdGF0ZSA9PSBDb250cm9sbGVyU3RhdGUuQ1JFQVRFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIub25GaXJzdFN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5TdGF0ZSA9IENvbnRyb2xsZXJTdGF0ZS5TVEFSVEVEO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5vblJlc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLlN0YXRlID0gQ29udHJvbGxlclN0YXRlLlNUQVJURUQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmhpZGVESVYoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLlN0YXRlID09IENvbnRyb2xsZXJTdGF0ZS5TVEFSVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5vblN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLlN0YXRlID0gQ29udHJvbGxlclN0YXRlLlNUT1BQRUQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJJbmRleCA9IG5ld0luZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGFydHVwKCkge1xyXG4gICAgICAgIHRoaXMuZGlhbG9nQ29udHJvbGxlci5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5Db250cm9sbGVycy5wdXNoKG5ldyBEYXNoYm9hcmRDb250cm9sbGVyKHRoaXMsIDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNjcmVlbl9kYXNoYm9hcmRcIikpKTtcclxuICAgICAgICB0aGlzLnNjcmVlbkNvbnRyb2xsZXJzLnB1c2gobmV3IERldmVsb3BDRkNDb250cm9sbGVyKHRoaXMsIDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNjcmVlbl9kZXZlbG9wXCIpKSk7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5Db250cm9sbGVycy5wdXNoKG5ldyBSZXBvcnRzQ29udHJvbGxlcih0aGlzLCA8SFRNTERpdkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzY3JlZW5fcmVwb3J0c1wiKSkpO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuQ29udHJvbGxlcnMucHVzaChuZXcgSGVhdGVyRXhwZXJpbWVudENvbnRyb2xsZXIodGhpcywgPEhUTUxEaXZFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2NyZWVuX2hlYXRlcmV4cGVyaW1lbnRcIikpKTtcclxuICAgICAgICB0aGlzLnNjcmVlbkNvbnRyb2xsZXJzLnB1c2gobmV3IEFpcnNwZWVkRXhwZXJpbWVudENvbnRyb2xsZXIodGhpcywgPEhUTUxEaXZFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2NyZWVuX2FpcnNwZWVkZXhwZXJpbWVudFwiKSkpO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuQ29udHJvbGxlcnMucHVzaChuZXcgQURDRXhwZXJpbWVudENvbnRyb2xsZXIodGhpcywgPEhUTUxEaXZFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2NyZWVuX2FkY2V4cGVyaW1lbnRcIikpKTtcclxuICAgICAgICB0aGlzLnNjcmVlbkNvbnRyb2xsZXJzLnB1c2gobmV3IEZGVEV4cGVyaW1lbnRDb250cm9sbGVyKHRoaXMsIDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNjcmVlbl9mZnRleHBlcmltZW50XCIpKSk7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5Db250cm9sbGVycy5mb3JFYWNoKChzYykgPT4gc2Mub25DcmVhdGUoKSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU2NyZWVuKDEpO1xyXG4gICAgICAgIGxldCBpZDJpbmRleCA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5Db250cm9sbGVycy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHsgaWQyaW5kZXguc2V0KFwic2hvd19cIiArIHZhbHVlLkVsZW1lbnRJZCwgaW5kZXgpIH0pXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MQW5jaG9yRWxlbWVudD4oXCJuYXYgYVwiKS5mb3JFYWNoKChhOiBIVE1MQW5jaG9yRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaWQgPSBhLmlkO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBpZDJpbmRleC5nZXQoYS5pZCkgfHwgMDtcclxuICAgICAgICAgICAgYS5vbmNsaWNrID0gKGUpID0+IHRoaXMuc2V0QWN0aXZlU2NyZWVuKGluZGV4KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIHRoaXMuU2V0QXBwbGljYXRpb25TdGF0ZShcIldlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkXCIpO1xyXG4gICAgICAgIGxldCB3ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KCd3czovLycgKyBsb2NhdGlvbi5ob3N0bmFtZSArICcvdycpO1xyXG4gICAgICAgIHdlYnNvY2tldC5vbm9wZW4gPSBlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5TZXRBcHBsaWNhdGlvblN0YXRlKCdXZWJTb2NrZXQgY29ubmVjdGlvbiBvcGVuZWQnKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXN0XCIpIS5pbm5lckhUTUwgPSBcIldlYlNvY2tldCBpcyBjb25uZWN0ZWQhXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdlYnNvY2tldC5vbm1lc3NhZ2UgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBldnQuZGF0YTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlOiBzdHJpbmc7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobXNnLmNoYXJBdCgwKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1zZy5yZXBsYWNlKC9bXjAtOVxcLl0vZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjBcIjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWQxXCIpIS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImJsYWNrXCI7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiMVwiOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlZDFcIikhLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiZ3JlZW5cIjsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIyXCI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGVkMlwiKSEuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJibGFja1wiOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjNcIjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWQyXCIpIS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImdyZWVuXCI7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxlZCA9IFwiICsgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGRfbXlOYW1lXCIpIS5pbm5lclRleHQgPSBwLmQubXlOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGRfdGVtcGVyYXR1cmVcIikhLmlubmVyVGV4dCA9IHAuZC50ZW1wZXJhdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRkX2h1bWlkaXR5XCIpIS5pbm5lclRleHQgPSBwLmQuaHVtaWRpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZF9oZWFwXCIpIS5pbm5lclRleHQgPSBwLmluZm8uaGVhcDtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRkX3RpbWVcIikhLmlubmVyVGV4dCA9IHAuaW5mby50aW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3ZWJzb2NrZXQub25jbG9zZSA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgZHVlIHRvICcrZS5yZWFzb24pO1xyXG4gICAgICAgICAgICB0aGlzLlNldEFwcGxpY2F0aW9uU3RhdGUoJ1dlYnNvY2tldCBjb25uZWN0aW9uIGNsb3NlZCBkdWUgdG8gJytlLnJlYXNvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3ZWJzb2NrZXQub25lcnJvciA9IChldnQpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dlYnNvY2tldCBlcnJvcjogJyArIGV2dC5yZXR1cm5WYWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuU2V0QXBwbGljYXRpb25TdGF0ZShcIldlYlNvY2tldCBlcnJvciFcIiArIGV2dC5yZXR1cm5WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxCdXR0b25FbGVtZW50PihcIiNwQnV0dG9ucyBidXR0b25cIikuZm9yRWFjaCgoYjogSFRNTEJ1dHRvbkVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgYi5vbmNsaWNrID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5zZW5kKFwiTFwiICsgYi5kYXRhc2V0LnJlbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiovXHJcbiAgICB9XHJcbn1cclxuXHJcbmxldCBhcHA6IEFwcENvbnRyb2xsZXI7XHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIChlKSA9PiB7XHJcbiAgICBhcHAgPSBuZXcgQXBwQ29udHJvbGxlcigpO1xyXG4gICAgYXBwLnN0YXJ0dXAoKTtcclxufSk7XHJcblxyXG5cclxuIiwiaW1wb3J0IHsgQXBwTWFuYWdlbWVudCB9IGZyb20gXCIuL0FwcE1hbmFnZW1lbnRcIjtcclxuaW1wb3J0IHsgRmxvd2NoYXJ0LCBGbG93Y2hhcnREYXRhLCBGbG93Y2hhcnRPcHRpb25zIH0gZnJvbSBcIi4vZmxvd2NoYXJ0L0Zsb3djaGFydFwiO1xyXG5pbXBvcnQgeyBTY3JlZW5Db250cm9sbGVyIH0gZnJvbSBcIi4vU2NyZWVuQ29udHJvbGxlclwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBEZXZlbG9wQ0ZDQ29udHJvbGxlciBleHRlbmRzIFNjcmVlbkNvbnRyb2xsZXIge1xyXG4gICAgcHJpdmF0ZSBmYzogRmxvd2NoYXJ0O1xyXG4gICAgcHJpdmF0ZSB0aW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgb25GaXJzdFN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLmZjLnRyaWdnZXJEZWJ1ZygpOyB9LCAxMDAwKTtcclxuICAgICAgICB0aGlzLmZjLm9uRmlyc3RTdGFydCgpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uUmVzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnRpbWVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHsgdGhpcy5mYy50cmlnZ2VyRGVidWcoKTsgfSwgMTAwMCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25TdG9wKCk6IHZvaWQge1xyXG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ3JlYXRlKCkgeyB9XHJcbiAgICBjb25zdHJ1Y3RvcihhcHBNYW5hZ2VtZW50OkFwcE1hbmFnZW1lbnQsIGRpdjogSFRNTERpdkVsZW1lbnQpIHtcclxuICAgICAgICBzdXBlcihhcHBNYW5hZ2VtZW50LCBkaXYpO1xyXG4gICAgICAgIGxldCBkYXRhOiBGbG93Y2hhcnREYXRhID0ge1xyXG4gICAgICAgICAgICBvcGVyYXRvcnM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogMCxcclxuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uOiBcIlJlZEJ1dHRvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFR5cGVJbmRleDogMzAsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zWDogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zWTogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbkRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb246IFwiR3JlZW5CdXR0b25cIixcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxUeXBlSW5kZXg6IDMzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc1g6IDEwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc1k6IDE1MCxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uRGF0YTogbnVsbCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FwdGlvbjogXCJBTkRcIixcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxUeXBlSW5kZXg6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zWDogMjUwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc1k6IDEwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25EYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogMyxcclxuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uOiBcIlJlZExlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFR5cGVJbmRleDogNDYsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zWDogNTAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc1k6IDEwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25EYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgbGlua3M6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21PcGVyYXRvckluZGV4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21PdXRwdXQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9PcGVyYXRvckluZGV4OiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvSW5wdXQ6IDBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgICAgICAgICBmcm9tT3BlcmF0b3JJbmRleDogMSxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tT3V0cHV0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvT3BlcmF0b3JJbmRleDogMixcclxuICAgICAgICAgICAgICAgICAgICB0b0lucHV0OiAxXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcImJsYWNrXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbU9wZXJhdG9ySW5kZXg6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbU91dHB1dDogMCxcclxuICAgICAgICAgICAgICAgICAgICB0b09wZXJhdG9ySW5kZXg6IDMsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9JbnB1dDogMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBuZXcgRmxvd2NoYXJ0T3B0aW9ucygpO1xyXG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5mYyA9IG5ldyBGbG93Y2hhcnQodGhpcy5hcHBNYW5hZ2VtZW50LCB0aGlzLmRpdiwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBBcHBNYW5hZ2VtZW50IH0gZnJvbSBcIi4vQXBwTWFuYWdlbWVudFwiO1xyXG5pbXBvcnQgeyR9IGZyb20gXCIuL3V0aWxzXCJcclxuZXhwb3J0IGNsYXNzIERpYWxvZ0NvbnRyb2xsZXIge1xyXG4gICAgXHJcblxyXG4gICAgcHJpdmF0ZSBkaWFsb2cgPSA8SFRNTERpYWxvZ0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpYWxvZycpITtcclxuICAgIHByaXZhdGUgZGlhbG9nSGVhZGluZyA9IDxIVE1MSGVhZGluZ0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpYWxvZy1oZWFkaW5nJykhO1xyXG4gICAgcHJpdmF0ZSBkaWFsb2dCb2R5ID0gPEhUTUxEaXZFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaWFsb2ctYm9keScpITtcclxuICAgIHByaXZhdGUgZGlhbG9nRm9vdGVyID0gPEhUTUxFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaWFsb2ctZm9vdGVyJykhO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYXBwTWFuYWdlbWVudDpBcHBNYW5hZ2VtZW50KSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyBpbml0KCkge1xyXG5cclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nLWNsb3NlJykhLm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAvL3RoaXMuZGlhbG9nLmNsb3NlKFwiY2FuY2VsbGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3RoaXMuZGlhbG9nLm9uY2FuY2VsID0gKGUpID0+IHtcclxuICAgICAgICAgICAgLy90aGlzLmRpYWxvZy5jbG9zZShcImNhbmNlbGxlZFwiKTtcclxuICAgICAgICAvL31cclxuXHJcbiAgICAgICAgLy8gY2xvc2Ugd2hlbiBjbGlja2luZyBvbiBiYWNrZHJvcFxyXG4gICAgICAgIHRoaXMuZGlhbG9nLm9uY2xpY2sgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kaWFsb2cpIHtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5kaWFsb2cuY2xvc2UoJ2NhbmNlbGxlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93RW50ZXJGaWxlbmFtZURpYWxvZyhwcmlvcml0eTogbnVtYmVyLCBtZXNzYWdlVGV4dDogc3RyaW5nLCBoYW5kbGVyOiAoZmlsZW5hbWU6IHN0cmluZykgPT4gdm9pZCkge1xyXG4gICAgICAgIHRoaXMucHJlcGFyZURpYWxvZygpO1xyXG4gICAgICAgIHRoaXMuZGlhbG9nSGVhZGluZy5pbm5lclRleHQ9XCJFbnRlciBGaWxlbmFtZVwiO1xyXG4gICAgICAgICQuSHRtbCh0aGlzLmRpYWxvZ0JvZHksIFwicFwiLCBbXSwgW10sIG1lc3NhZ2VUZXh0KTtcclxuICAgICAgICBsZXQgZmlsZUlucHV0PSA8SFRNTElucHV0RWxlbWVudD4kLkh0bWwodGhpcy5kaWFsb2dCb2R5LCBcImlucHV0XCIsIFtcInBhdHRlcm5cIiwgXCJeW0EtWmEtejAtOV17MSwxMH0kXCJdLCBbXSk7XHJcbiAgICAgICAgdGhpcy5kaWFsb2dGb290ZXIuaW5uZXJUZXh0PVwiXCI7XHJcbiAgICAgICAgJC5IdG1sKHRoaXMuZGlhbG9nRm9vdGVyLCBcImJ1dHRvblwiLCBbXSwgW10sIFwiT0tcIikub25jbGljaz0oZSk9PntcclxuICAgICAgICAgICAgLy90aGlzLmRpYWxvZy5jbG9zZSgnT0snKTtcclxuICAgICAgICAgICAgaWYoaGFuZGxlciE9bnVsbCkgaGFuZGxlcihmaWxlSW5wdXQudmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAvLyB0aGlzLmRpYWxvZy5zaG93TW9kYWwoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvd09LRGlhbG9nKHByaW9yaXR5OiBudW1iZXIsIG1lc3NhZ2VUZXh0OnN0cmluZywgaGFuZGxlcjogKChhOnN0cmluZyk9PmFueSl8bnVsbCkge1xyXG4gICAgICAgIHRoaXMucHJlcGFyZURpYWxvZygpO1xyXG4gICAgICAgIHRoaXMuZGlhbG9nSGVhZGluZy5pbm5lclRleHQ9XCJNZXNzYWdlXCI7XHJcbiAgICAgICAgdGhpcy5kaWFsb2dCb2R5LmlubmVyVGV4dD1tZXNzYWdlVGV4dDtcclxuICAgICAgICB0aGlzLmRpYWxvZ0Zvb3Rlci5pbm5lclRleHQ9XCJcIjtcclxuICAgICAgICAkLkh0bWwodGhpcy5kaWFsb2dGb290ZXIsIFwiYnV0dG9uXCIsIFtcInR5cGVcIiwgXCJidXR0b25cIl0sIFtdLCBcIk9LXCIpLm9uY2xpY2s9KGUpPT57XHJcbiAgICAgICAgICAgIC8vdGhpcy5kaWFsb2cuY2xvc2UoJ2NhbmNlbGxlZCcpO1xyXG4gICAgICAgICAgICBpZihoYW5kbGVyIT1udWxsKSBoYW5kbGVyKFwiT0tcIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL3RoaXMuZGlhbG9nLnNob3dNb2RhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcHJlcGFyZURpYWxvZygpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kaWFsb2dIZWFkaW5nLmlubmVyVGV4dD1cIlwiO1xyXG4gICAgICAgIHRoaXMuZGlhbG9nQm9keS5pbm5lclRleHQ9XCJcIjtcclxuICAgICAgICB0aGlzLmRpYWxvZ0Zvb3Rlci5pbm5lclRleHQ9XCJcIjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvd0ZpbGVsaXN0KHByaW9yaXR5OiBudW1iZXIsIGZpbGVzOnN0cmluZ1tdLCBvcGVuaGFuZGxlcjogKGZpbGVuYW1lOnN0cmluZyk9PmFueSwgZGVsZXRlaGFuZGxlcjogKGZpbGVuYW1lOnN0cmluZyk9PmFueSkge1xyXG5cclxuICAgICAgICB0aGlzLnByZXBhcmVEaWFsb2coKTtcclxuICAgICAgICB0aGlzLmRpYWxvZ0hlYWRpbmcuaW5uZXJUZXh0PVwiUGxlYXNlIHNlbGVjdCBhIGZpbGUgdG8gbG9hZFwiXHJcbiAgICAgICAgJC5IdG1sKHRoaXMuZGlhbG9nRm9vdGVyLCBcImJ1dHRvblwiLCBbXCJ0eXBlXCIsIFwiYnV0dG9uXCJdLCBbXSwgXCJDYW5jZWxcIikub25jbGljaz0oZSk9PntcclxuICAgICAgICAgICAgLy90aGlzLmRpYWxvZy5jbG9zZShcImNhbmNlbGxlZFwiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCB0YWJsZSA9IDxIVE1MVGFibGVFbGVtZW50PiQuSHRtbCh0aGlzLmRpYWxvZ0JvZHksIFwidGFibGVcIiwgW10sIFtdKTtcclxuICAgICAgICBsZXQgdGhlYWQgPSA8SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ+JC5IdG1sKHRhYmxlLCBcInRoZWFkXCIsIFtdLFtdKTtcclxuICAgICAgICBsZXQgdHJfaGVhZCA9ICQuSHRtbCh0aGVhZCwgXCJ0clwiLCBbXSwgW10pO1xyXG4gICAgICAgICQuSHRtbCh0cl9oZWFkLCBcInRoXCIsIFtdLCBbXSwgXCJGaWxlIE5hbWVcIik7XHJcbiAgICAgICAgJC5IdG1sKHRyX2hlYWQsIFwidGhcIiwgW10sIFtdLCBcIkZpbGUgT3BlcmF0aW9uXCIpO1xyXG4gICAgICAgIGxldCB0Ym9keT0gPEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50PiQuSHRtbCh0YWJsZSwgXCJ0Ym9keVwiLCBbXSxbXSk7XHJcbiAgICAgICAgZm9yKGxldCBmaWxlbmFtZSBvZiBmaWxlcyl7XHJcbiAgICAgICAgICAgIGlmKCFmaWxlbmFtZS5lbmRzV2l0aChcIi5qc29uXCIpKSBjb250aW51ZTtcclxuICAgICAgICAgICAgZmlsZW5hbWU9ZmlsZW5hbWUuc3Vic3RyaW5nKDAsIGZpbGVuYW1lLmxlbmd0aC01KTtcclxuICAgICAgICAgICAgbGV0IHRyID0gJC5IdG1sKHRib2R5LCBcInRyXCIsIFtdLCBbXSk7XHJcbiAgICAgICAgICAgICQuSHRtbCh0ciwgXCJ0ZFwiLCBbXSwgW10sIGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgbGV0IG9wZXJhdGlvblRkPSAkLkh0bWwodHIsIFwidGRcIiwgW10sIFtdKTtcclxuICAgICAgICAgICAgbGV0IG9wZW5CdXR0b24gPSAkLkh0bWwob3BlcmF0aW9uVGQsIFwiYnV0dG9uXCIsIFtcInR5cGVcIiwgXCJidXR0b25cIl0sIFtdKTtcclxuICAgICAgICAgICAgJC5TdmdJY29uKG9wZW5CdXR0b24sIFwiZm9sZGVyLW9wZW5cIik7XHJcbiAgICAgICAgICAgIG9wZW5CdXR0b24ub25jbGljaz0oZSk9PntcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5kaWFsb2cuY2xvc2UoXCJvcGVuZWRcIik7XHJcbiAgICAgICAgICAgICAgICBvcGVuaGFuZGxlcihmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IGRlbGV0ZUJ1dHRvbj0kLkh0bWwob3BlcmF0aW9uVGQsIFwiYnV0dG9uXCIsIFtcInR5cGVcIiwgXCJidXR0b25cIl0sIFtdLCApO1xyXG4gICAgICAgICAgICAkLlN2Z0ljb24oZGVsZXRlQnV0dG9uLCBcImJpbjJcIik7XHJcbiAgICAgICAgICAgIGRlbGV0ZUJ1dHRvbi5vbmNsaWNrPShlKT0+e1xyXG4gICAgICAgICAgICAgICAgLy90aGlzLmRpYWxvZy5jbG9zZShcImRlbGV0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVoYW5kbGVyKGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy90aGlzLmRpYWxvZy5zaG93TW9kYWwoKTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICBcclxufSIsImltcG9ydCB7ICQgfSBmcm9tIFwiLi91dGlsc1wiO1xyXG5pbXBvcnQgeyBDaGFydCwgQ2hhcnREYXRhc2V0fSBmcm9tICdjaGFydC5qcyc7XHJcbmltcG9ydCB7IFNjcmVlbkNvbnRyb2xsZXIgfSBmcm9tIFwiLi9TY3JlZW5Db250cm9sbGVyXCI7XHJcbmltcG9ydCB7IEFwcE1hbmFnZW1lbnQgfSBmcm9tIFwiLi9BcHBNYW5hZ2VtZW50XCI7XHJcbmltcG9ydCB7IFNlcmlhbGl6ZUNvbnRleHQgfSBmcm9tIFwiLi9mbG93Y2hhcnQvU2VyaWFsaXplQ29udGV4dFwiO1xyXG4vLyEhIUFwcGxpZWQgc29tZSBhZG9wdGlvbnMgb24gbG93ZXIgbnVtYmVycyB0byBhdm9pZCBzdHJhbmdlIHJvdW5kaW5nIGVmZmVjdHNcclxuY29uc3QgIEZSRVFVRU5DSUVTOm51bWJlcltdPVsxMSwyMSwzMSw0Miw1Myw2NCw3NSw5NywxMTgsMTM5LDE2MSwxODMsMjA1LDIyNywyNTgsMjkxLDMyMywzNTUsMzg4LDQzMSw0NzQsNTE3LDU2MCw2MTQsNjY4LDcyMSw3ODYsODUxLDkxNSw5OTEsMTA2NiwxMTUyLDEyMzgsMTMzNSwxNDQzLDE1NTAsMTY2OSwxNzk4LDE5MzgsMjA4OSwyMjM5LDI0MDEsMjU4NCwyNzc4LDI5ODIsMzE5OCwzNDM1LDM2ODIsMzk1MSw0MjMxLDQ1MzMsNDg1Niw1MjAwLDU1NjYsNTk2NSw2Mzg1LDY4MzcsNzMyMSw3ODM4LDgzOTgsODk5MCw5NjI1LDEwMzA0LDExMDI1XTtcclxuY29uc3QgSU5URVJWQUw9MjAwMDtcclxuY29uc3QgWkVST1MgPSBBcnJheS5mcm9tKEFycmF5KDY0KS5rZXlzKCkpO1xyXG5cclxuZXhwb3J0IGNsYXNzIEZGVEV4cGVyaW1lbnRDb250cm9sbGVyIGV4dGVuZHMgU2NyZWVuQ29udHJvbGxlciB7XHJcbiAgICBwcml2YXRlIGJ1dFJlY29yZDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGJ1dFN0b3A6IEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBidXRTYXZlOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgIHByaXZhdGUgYnV0RGVsZXRlOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgIHByaXZhdGUgaW5wdXRGYW46IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIHRib2R5OiBIVE1MVGFibGVTZWN0aW9uRWxlbWVudDtcclxuICAgIHByaXZhdGUgdGltZXI6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgY2hhcnQ6IENoYXJ0O1xyXG4gICAgcHJpdmF0ZSBDT0xPUlMgPSBbXHJcbiAgICAgICAgJyM0ZGM5ZjYnLFxyXG4gICAgICAgICcjZjY3MDE5JyxcclxuICAgICAgICAnI2Y1Mzc5NCcsXHJcbiAgICAgICAgJyM1MzdiYzQnLFxyXG4gICAgICAgICcjYWNjMjM2JyxcclxuICAgICAgICAnIzE2NmE4ZicsXHJcbiAgICAgICAgJyMwMGE5NTAnLFxyXG4gICAgICAgICcjNTg1OTViJyxcclxuICAgICAgICAnIzg1NDliYSdcclxuICAgICAgXTtcclxuXHJcbiAgICBwcml2YXRlIHJlY29yZGluZyA9IGZhbHNlO1xyXG4gICBcclxuXHJcbiAgICBwdWJsaWMgb25GaXJzdFN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnNlbmRBbmRSZWNlaXZlKCk7IH0sIElOVEVSVkFMKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvblJlc3RhcnQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7IHRoaXMuc2VuZEFuZFJlY2VpdmUoKTsgfSwgSU5URVJWQUwpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uU3RvcCgpOiB2b2lkIHtcclxuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgICB0aGlzLmJ1dFN0b3AuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmJ1dFJlY29yZC5oaWRkZW4gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNyZWF0ZSgpIHtcclxuICAgICAgICAvL3RoaXMucmVzZXREYXRhKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXNldERhdGEoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhIS5sYWJlbHMgPSBbXTtcclxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEhLmRhdGFzZXRzIS5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGRhdGFzZXQhLmRhdGEgPSBbXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMudGJvZHkuaW5uZXJUZXh0ID0gXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbG9yKGluZGV4Om51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLkNPTE9SU1tpbmRleCAlIHRoaXMuQ09MT1JTLmxlbmd0aF07XHJcbiAgICB9XHJcbiAgICAgIFxyXG5cclxuICAgIHByaXZhdGUgc2VuZEFuZFJlY2VpdmUoKSB7XHJcbiAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigyNTYpO1xyXG4gICAgICAgIGxldCBjdHggPSBuZXcgU2VyaWFsaXplQ29udGV4dChidWZmZXIpO1xyXG4gICAgICAgIGN0eC53cml0ZUYzMih0aGlzLmlucHV0RmFuLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgIGN0eC53cml0ZUYzMigwKTtcclxuICAgICAgICBjdHgud3JpdGVGMzIoMCk7XHJcbiAgICAgICAgY3R4LndyaXRlRjMyKDApO1xyXG4gICAgICAgIGN0eC53cml0ZUYzMigwKTtcclxuICAgICAgICBjdHgud3JpdGVGMzIoMCk7XHJcbiAgICAgICAgY3R4LndyaXRlRjMyKDApO1xyXG4gICAgICAgIGN0eC53cml0ZUYzMigwKTtcclxuXHJcbiAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcclxuICAgICAgICB4aHIub25lcnJvciA9IChlKSA9PiB7IGNvbnNvbGUubG9nKFwiRmVobGVyIGJlaW0gWE1MSHR0cFJlcXVlc3QhXCIpOyB9O1xyXG4gICAgICAgIHhoci5vcGVuKFwiUFVUXCIsIFwiL2ZmdGV4cGVyaW1lbnRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICBcclxuICAgICAgICB4aHIub25sb2FkID0gKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGE6bnVtYmVyW10gPSBbXTtcclxuICAgICAgICAgICAgbGV0IGFycmF5QnVmZmVyID0geGhyLnJlc3BvbnNlOyAvLyBOb3RlOiBub3Qgb1JlcS5yZXNwb25zZVRleHRcclxuICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlciB8fCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoICE9IDI1Nikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiFhcnJheUJ1ZmZlciB8fCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoICE9IDI1NiAtLT5wcm92aWRpbmcgZmFrZSBkYXRhXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0wO2k8NjQ7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goNSArIDUgKiBNYXRoLnJhbmRvbSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3R4ID0gbmV3IFNlcmlhbGl6ZUNvbnRleHQoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0wO2k8NjQ7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goTWF0aC5sb2cxMChjdHgucmVhZEYzMigpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucmVjb3JkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YT1kYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgeGhyLnNlbmQoY3R4LmdldFJlc3VsdCgpKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwTWFuYWdlbWVudDpBcHBNYW5hZ2VtZW50LCBkaXY6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwTWFuYWdlbWVudCwgZGl2KTtcclxuICAgICAgICB0aGlzLmJ1dFJlY29yZCA9IDxIVE1MQnV0dG9uRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZmdGV4cGVyaW1lbnRfYnV0UmVjb3JkXCIpITtcclxuICAgICAgICB0aGlzLmJ1dFN0b3AgPSA8SFRNTEJ1dHRvbkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmZnRleHBlcmltZW50X2J1dFN0b3BcIikhO1xyXG4gICAgICAgIHRoaXMuYnV0U2F2ZSA9IDxIVE1MQnV0dG9uRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZmdGV4cGVyaW1lbnRfYnV0U2F2ZVwiKSE7XHJcbiAgICAgICAgdGhpcy5idXREZWxldGUgPSA8SFRNTEJ1dHRvbkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmZnRleHBlcmltZW50X2J1dERlbGV0ZVwiKSE7XHJcbiAgICAgICAgdGhpcy5pbnB1dEZhbiA9IDxIVE1MSW5wdXRFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmZ0ZXhwZXJpbWVudF9pbnBGYW5cIikhO1xyXG4gICAgICAgIHRoaXMuYnV0U3RvcC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudGJvZHkgPSA8SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZGNleHBlcmltZW50X3RhYkJvZHlcIikhO1xyXG4gICAgICAgXHJcblxyXG4gICAgICAgIGxldCBjdHggPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZmdGV4cGVyaW1lbnRfY2hhcnQnKSE7XHJcbiAgICAgICAgdGhpcy5jaGFydCA9IG5ldyBDaGFydChjdHgsIHtcclxuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbHM6IEZSRVFVRU5DSUVTLFxyXG4gICAgICAgICAgICAgICAgZGF0YXNldHM6IFtdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGhvdmVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogJ25lYXJlc3QnLFxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNjYWxlczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHk6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDoxMFxyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICAgIGxldCBzZXRCdWJibGUgPSAocmFuZ2U6IEhUTUxJbnB1dEVsZW1lbnQsIGJ1YmJsZTogSFRNTE91dHB1dEVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHZhbCA9IHJhbmdlLnZhbHVlQXNOdW1iZXI7XHJcbiAgICAgICAgICAgIGxldCBtaW4gPSByYW5nZS5taW4gPyBwYXJzZUludChyYW5nZS5taW4pIDogMDtcclxuICAgICAgICAgICAgbGV0IG1heCA9IHJhbmdlLm1heCA/IHBhcnNlSW50KHJhbmdlLm1heCkgOiAxMDA7XHJcbiAgICAgICAgICAgIGxldCBuZXdWYWwgPSAoKHZhbCAtIG1pbikgKiAxMDApIC8gKG1heCAtIG1pbik7XHJcbiAgICAgICAgICAgIGJ1YmJsZS5pbm5lckhUTUwgPSBcIlwiICsgdmFsO1xyXG5cclxuICAgICAgICAgICAgLy8gU29ydGEgbWFnaWMgbnVtYmVycyBiYXNlZCBvbiBzaXplIG9mIHRoZSBuYXRpdmUgVUkgdGh1bWJcclxuICAgICAgICAgICAgYnViYmxlLnN0eWxlLmxlZnQgPSBgY2FsYygke25ld1ZhbH0lICsgKCR7OCAtIG5ld1ZhbCAqIDAuMTV9cHgpKWA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5yYW5nZS13cmFwLmZmdGV4cGVyaW1lbnRcIikuZm9yRWFjaCh3cmFwID0+IHtcclxuICAgICAgICAgICAgbGV0IHJhbmdlID0gPEhUTUxJbnB1dEVsZW1lbnQ+d3JhcC5xdWVyeVNlbGVjdG9yKFwiaW5wdXRbdHlwZT0ncmFuZ2UnXVwiKSE7XHJcbiAgICAgICAgICAgIGxldCBidWJibGUgPSA8SFRNTE91dHB1dEVsZW1lbnQ+d3JhcC5xdWVyeVNlbGVjdG9yKFwib3V0cHV0LmJ1YmJsZVwiKSE7XHJcbiAgICAgICAgICAgIHJhbmdlLm9uaW5wdXQgPSAoZSkgPT4gc2V0QnViYmxlKHJhbmdlLCBidWJibGUpO1xyXG4gICAgICAgICAgICBzZXRCdWJibGUocmFuZ2UsIGJ1YmJsZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYnV0U3RvcC5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dFN0b3AuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXRSZWNvcmQuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYnV0UmVjb3JkLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0UmVjb3JkLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0U3RvcC5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLnVuc2hpZnQoe1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IFwiTWFnbml0dWRlc1wiLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogWkVST1MsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5jb2xvcigwKSxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvcigwKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYnV0U2F2ZS5vbmNsaWNrID0gKCk9PntcclxuICAgICAgICAgICAgbGV0IG5vdyA9IG5ldyBEYXRlKERhdGUubm93KCkpO1xyXG4gICAgICAgICAgICBsZXQgbmV3RGF0YXNldDpDaGFydERhdGFzZXQ9e1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IFwiTWFnbml0dWRlcyBzYXZlZCBcIitub3cudG9Mb2NhbGVUaW1lU3RyaW5nKFwiZGUtREVcIiksXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YSxcclxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmNvbG9yKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmNvbG9yKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMuc3BsaWNlKDEsMCxuZXdEYXRhc2V0KTtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5idXREZWxldGUub25jbGljaz0oKT0+e1xyXG4gICAgICAgICAgICBpZih0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoPDIpIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLnBvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyAkIH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuaW1wb3J0IHsgQ2hhcnR9IGZyb20gJ2NoYXJ0LmpzJztcclxuaW1wb3J0IHsgU2NyZWVuQ29udHJvbGxlciB9IGZyb20gXCIuL1NjcmVlbkNvbnRyb2xsZXJcIjtcclxuaW1wb3J0IHsgQXBwTWFuYWdlbWVudCB9IGZyb20gXCIuL0FwcE1hbmFnZW1lbnRcIjtcclxuaW1wb3J0IHsgU2VyaWFsaXplQ29udGV4dCB9IGZyb20gXCIuL2Zsb3djaGFydC9TZXJpYWxpemVDb250ZXh0XCI7XHJcblxyXG5leHBvcnQgbGV0IERFX2RlID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KCdkZS1ERScpO1xyXG5leHBvcnQgY29uc3QgQ0hBUlRfRUFDSF9JTlRFUlZBTCA9IDI7XHJcblxyXG5leHBvcnQgY2xhc3MgSGVhdGVyRXhwZXJpbWVudENvbnRyb2xsZXIgZXh0ZW5kcyBTY3JlZW5Db250cm9sbGVyIHtcclxuICAgIHByaXZhdGUgYnV0UmVjb3JkOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgIHByaXZhdGUgYnV0U3RvcDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGJ1dERlbGV0ZTogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIHRib2R5OiBIVE1MVGFibGVTZWN0aW9uRWxlbWVudDtcclxuICAgIHByaXZhdGUgdGZpcnN0Um93OiBIVE1MVGFibGVSb3dFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBpbnB1dFNldHBvaW50SGVhdGVyOiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBpbnB1dFNldHBvaW50VGVtcGVyYXR1cmU6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0RmFuQ0w6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0RmFuT0w6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0S1A6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0VE46IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGlucHV0VFY6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIHRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIGNoYXJ0OiBDaGFydDtcclxuXHJcbiAgICBwcml2YXRlIGNvdW50ZXIgPSAxMCBeIDY7XHJcbiAgICBwcml2YXRlIG1vZGU6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHNlY29uZHMgPSAwO1xyXG5cclxuICAgIHByaXZhdGUgcmVjb3JkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgcHVibGljIG9uRmlyc3RTdGFydCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnRpbWVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHsgdGhpcy5zZW5kQW5kUmVjZWl2ZSgpOyB9LCAxMDAwKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvblJlc3RhcnQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7IHRoaXMuc2VuZEFuZFJlY2VpdmUoKTsgfSwgMTAwMCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25TdG9wKCk6IHZvaWQge1xyXG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgICAgIHRoaXMuYnV0U3RvcC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYnV0UmVjb3JkLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY291bnRlciA9IDEwIF4gNjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNyZWF0ZSgpIHtcclxuICAgICAgICB0aGlzLnJlc2V0RGF0YSgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0RGF0YSgpIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEhLmxhYmVscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YSEuZGF0YXNldHMhLmZvckVhY2goKGRhdGFzZXQpID0+IHtcclxuICAgICAgICAgICAgZGF0YXNldCEuZGF0YSA9IFtdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy50Ym9keS5pbm5lclRleHQgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IDA7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgb25Nb2RlQ2hhbmdlKG5ld01vZGU6IG51bWJlcikge1xyXG4gICAgICAgIHN3aXRjaCAobmV3TW9kZSkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaGVhdGVyZXhwZXJpbWVudF9jbG9zZWRsb29wY3RybCcpLmZvckVhY2goKHYsIGspID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAoPEhUTUxFbGVtZW50PnYpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhlYXRlcmV4cGVyaW1lbnRfb3Blbmxvb3BjdHJsJykuZm9yRWFjaCgodiwgaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICg8SFRNTEVsZW1lbnQ+dikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhlYXRlcmV4cGVyaW1lbnRfY2xvc2VkbG9vcGN0cmwnKS5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxIVE1MRWxlbWVudD52KS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5oZWF0ZXJleHBlcmltZW50X29wZW5sb29wY3RybCcpLmZvckVhY2goKHYsIGspID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAoPEhUTUxFbGVtZW50PnYpLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhlYXRlcmV4cGVyaW1lbnRfY2xvc2VkbG9vcGN0cmwnKS5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxIVE1MRWxlbWVudD52KS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhlYXRlcmV4cGVyaW1lbnRfb3Blbmxvb3BjdHJsJykuZm9yRWFjaCgodiwgaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICg8SFRNTEVsZW1lbnQ+dikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNlbmRBbmRSZWNlaXZlKCkge1xyXG4gICAgICAgIGxldCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMjU2KTtcclxuICAgICAgICBsZXQgY3R4ID0gbmV3IFNlcmlhbGl6ZUNvbnRleHQoYnVmZmVyKTtcclxuICAgICAgICBjdHgud3JpdGVVMzIodGhpcy5tb2RlKTtcclxuICAgICAgICBpZiAodGhpcy5tb2RlID09IDApIHtcclxuICAgICAgICAgICAgY3R4LndyaXRlRjMyKDApO1xyXG4gICAgICAgICAgICBjdHgud3JpdGVGMzIoMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT0gMSkge1xyXG4gICAgICAgICAgICBjdHgud3JpdGVGMzIodGhpcy5pbnB1dFNldHBvaW50SGVhdGVyLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgICAgICBjdHgud3JpdGVGMzIodGhpcy5pbnB1dEZhbk9MLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3R4LndyaXRlRjMyKHRoaXMuaW5wdXRTZXRwb2ludFRlbXBlcmF0dXJlLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgICAgICBjdHgud3JpdGVGMzIodGhpcy5pbnB1dEZhbkNMLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgud3JpdGVGMzIodGhpcy5pbnB1dEtQLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgIGN0eC53cml0ZUYzMih0aGlzLmlucHV0VE4udmFsdWVBc051bWJlcik7XHJcbiAgICAgICAgY3R4LndyaXRlRjMyKHRoaXMuaW5wdXRUVi52YWx1ZUFzTnVtYmVyKTtcclxuXHJcbiAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcclxuICAgICAgICB4aHIub25lcnJvciA9IChlKSA9PiB7IGNvbnNvbGUubG9nKFwiRmVobGVyIGJlaW0gWE1MSHR0cFJlcXVlc3QhXCIpOyB9O1xyXG4gICAgICAgIHhoci5vcGVuKFwiUFVUXCIsIFwiL2hlYXRlcmV4cGVyaW1lbnRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICB4aHIub25sb2FkID0gKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IFNldHBvaW50VGVtcGVyYXR1cmU6IG51bWJlciwgSGVhdGVyOiBudW1iZXIsIEZhbjogbnVtYmVyLCBBY3R1YWxUZW1wZXJhdHVyZTogbnVtYmVyO1xyXG4gICAgICAgICAgICBsZXQgYXJyYXlCdWZmZXIgPSB4aHIucmVzcG9uc2U7IC8vIE5vdGU6IG5vdCBvUmVxLnJlc3BvbnNlVGV4dFxyXG4gICAgICAgICAgICBpZiAoIWFycmF5QnVmZmVyIHx8IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggIT0gNCArIDQgKyA0ICsgNCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiEgYXJyYXlCdWZmZXIgfHwgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCE9NCs0KzQrNFwiKTtcclxuICAgICAgICAgICAgICAgIFNldHBvaW50VGVtcGVyYXR1cmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgSGVhdGVyID0gMDtcclxuICAgICAgICAgICAgICAgIEZhbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBBY3R1YWxUZW1wZXJhdHVyZSA9IDIwICsgKC01ICsgMTAgKiBNYXRoLnJhbmRvbSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdHggPSBuZXcgU2VyaWFsaXplQ29udGV4dChhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBTZXRwb2ludFRlbXBlcmF0dXJlID0gY3R4LnJlYWRGMzIoKTtcclxuICAgICAgICAgICAgICAgIEhlYXRlciA9IGN0eC5yZWFkRjMyKCk7XHJcbiAgICAgICAgICAgICAgICBGYW4gPSBjdHgucmVhZEYzMigpO1xyXG4gICAgICAgICAgICAgICAgQWN0dWFsVGVtcGVyYXR1cmUgPSBjdHgucmVhZEYzMigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBub3cgPSBuZXcgRGF0ZShEYXRlLm5vdygpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29yZGluZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRyID0gJC5IdG1sQXNGaXJzdENoaWxkKHRoaXMudGJvZHksIFwidHJcIiwgW10pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAkLkh0bWwodHIsIFwidGRcIiwgW10sIFtdLCB0aGlzLnRmaXJzdFJvdy5jaGlsZHJlbltpXS50ZXh0Q29udGVudCEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRlciA+PSBDSEFSVF9FQUNIX0lOVEVSVkFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnQuZGF0YSEubGFiZWxzIS5sZW5ndGggPiAxMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhIS5sYWJlbHM/LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YSEuZGF0YXNldHMhLmZvckVhY2goKGRhdGFzZXQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXQhLmRhdGEhLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0LmRhdGEhLmxhYmVscyEucHVzaChub3cudG9Mb2NhbGVUaW1lU3RyaW5nKFwiZGUtREVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YT8uZGF0YXNldHMhWzBdLmRhdGE/LnB1c2goU2V0cG9pbnRUZW1wZXJhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhPy5kYXRhc2V0cyFbMV0uZGF0YT8ucHVzaChBY3R1YWxUZW1wZXJhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhPy5kYXRhc2V0cyFbMl0uZGF0YT8ucHVzaChIZWF0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQuZGF0YT8uZGF0YXNldHMhWzNdLmRhdGE/LnB1c2goRmFuKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3RoaXMuc2V0cG9pbnRUZW1wZXJhdHVyZVZhbHVlcy5wdXNoKFNldHBvaW50VGVtcGVyYXR1cmUpXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmhlYXRlclZhbHVlcy5wdXNoKEhlYXRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmZhblZhbHVlcy5wdXNoKEZhbik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmFjdHVhbFRlbXBlcmF0dXJlVmFsdWVzLnB1c2goQWN0dWFsVGVtcGVyYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9GSVhNRSB0aGlzLmNoYXJ0RGF0YSA9IHtsYWJlbHM6dGhpcy5kYXRlVmFsdWVzLCBzZXJpZXM6IFt0aGlzLnNldHBvaW50VGVtcGVyYXR1cmVWYWx1ZXMsIHRoaXMuYWN0dWFsVGVtcGVyYXR1cmVWYWx1ZXMsIHRoaXMuaGVhdGVyVmFsdWVzLCB0aGlzLmZhblZhbHVlcyxdLH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9GSVhNRSB0aGlzLmNoYXJ0LnVwZGF0ZSh0aGlzLmNoYXJ0RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRzKys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB0aGlzLnRmaXJzdFJvdy5jaGlsZHJlblswXS50ZXh0Q29udGVudCA9IG5vdy50b0xvY2FsZVRpbWVTdHJpbmcoXCJkZS1ERVwiKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bMV0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQodGhpcy5zZWNvbmRzKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bMl0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoU2V0cG9pbnRUZW1wZXJhdHVyZSk7XHJcbiAgICAgICAgICAgIHRoaXMudGZpcnN0Um93LmNoaWxkcmVuWzNdLnRleHRDb250ZW50ID0gREVfZGUuZm9ybWF0KEFjdHVhbFRlbXBlcmF0dXJlKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bNF0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoSGVhdGVyKTtcclxuICAgICAgICAgICAgdGhpcy50Zmlyc3RSb3cuY2hpbGRyZW5bNV0udGV4dENvbnRlbnQgPSBERV9kZS5mb3JtYXQoRmFuKTtcclxuXHJcblxyXG5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5zZW5kKGN0eC5nZXRSZXN1bHQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwTWFuYWdlbWVudDpBcHBNYW5hZ2VtZW50LCBkaXY6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwTWFuYWdlbWVudCwgZGl2KTtcclxuICAgICAgICB0aGlzLmJ1dFJlY29yZCA9IDxIVE1MQnV0dG9uRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImhlYXRlcmV4cGVyaW1lbnRfYnV0UmVjb3JkXCIpITtcclxuICAgICAgICB0aGlzLmJ1dFN0b3AgPSA8SFRNTEJ1dHRvbkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWF0ZXJleHBlcmltZW50X2J1dFN0b3BcIikhO1xyXG4gICAgICAgIHRoaXMuYnV0U3RvcC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYnV0RGVsZXRlID0gPEhUTUxCdXR0b25FbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaGVhdGVyZXhwZXJpbWVudF9idXREZWxldGVcIikhO1xyXG4gICAgICAgIHRoaXMudGJvZHkgPSA8SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWF0ZXJleHBlcmltZW50X3RhYkJvZHlcIikhO1xyXG4gICAgICAgIHRoaXMudGZpcnN0Um93ID0gPEhUTUxUYWJsZVJvd0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWF0ZXJleHBlcmltZW50X3RhYkZpcnN0Um93XCIpITtcclxuICAgICAgICB0aGlzLmlucHV0U2V0cG9pbnRIZWF0ZXIgPSA8SFRNTElucHV0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImhlYXRlcmV4cGVyaW1lbnRfaW5wU2V0cG9pbnRIZWF0ZXJcIik7XHJcbiAgICAgICAgdGhpcy5pbnB1dEZhbk9MID0gPEhUTUxJbnB1dEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWF0ZXJleHBlcmltZW50X2lucEZhbk9MXCIpITtcclxuICAgICAgICB0aGlzLmlucHV0U2V0cG9pbnRUZW1wZXJhdHVyZSA9IDxIVE1MSW5wdXRFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaGVhdGVyZXhwZXJpbWVudF9pbnBTZXRwb2ludFRlbXBlcmF0dXJlXCIpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRGYW5DTCA9IDxIVE1MSW5wdXRFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaGVhdGVyZXhwZXJpbWVudF9pbnBGYW5DTFwiKSE7XHJcblxyXG4gICAgICAgIHRoaXMuaW5wdXRLUCA9IDxIVE1MSW5wdXRFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaGVhdGVyZXhwZXJpbWVudF9pbnBLUFwiKSE7XHJcbiAgICAgICAgdGhpcy5pbnB1dFROID0gPEhUTUxJbnB1dEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWF0ZXJleHBlcmltZW50X2lucFROXCIpITtcclxuICAgICAgICB0aGlzLmlucHV0VFYgPSA8SFRNTElucHV0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImhlYXRlcmV4cGVyaW1lbnRfaW5wVFZcIikhO1xyXG5cclxuICAgICAgICB0aGlzLm9uTW9kZUNoYW5nZSgwKTtcclxuXHJcbiAgICAgICAgbGV0IGN0eCA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVhdGVyZXhwZXJpbWVudF9jaGFydCcpITtcclxuICAgICAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCwge1xyXG4gICAgICAgICAgICB0eXBlOiAnbGluZScsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsczogW10sXHJcbiAgICAgICAgICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiU2V0cG9pbnQgVGVtcGVyYXR1cmUgW8KwQ11cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZWRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmVkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJBY3R1YWwgVGVtcGVyYXR1cmUgW8KwQ11cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJncmVlblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJncmVlblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiSGVhdGVyIFBvd2VyIFslXVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImJsdWVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiYmx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiRmFuIFBvd2VyIFslXVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImdyZXlcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiZ3JleVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBob3Zlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6ICduZWFyZXN0JyxcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Q6IHRydWVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzY2FsZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICB5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT1cImhlYXRlcmV4cGVyaW1lbnRfbW9kZVwiXScpLmZvckVhY2goKHYsIGspID0+IHtcclxuICAgICAgICAgICAgbGV0IGlucCA9IDxIVE1MSW5wdXRFbGVtZW50PnY7XHJcbiAgICAgICAgICAgIGlucC5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBudW0gPSBwYXJzZUludChpbnAudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZSAhPSBudW0pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1vZGVDaGFuZ2UobnVtKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHNldEJ1YmJsZSA9IChyYW5nZTogSFRNTElucHV0RWxlbWVudCwgYnViYmxlOiBIVE1MT3V0cHV0RWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gcmFuZ2UudmFsdWVBc051bWJlcjtcclxuICAgICAgICAgICAgbGV0IG1pbiA9IHJhbmdlLm1pbiA/IHBhcnNlSW50KHJhbmdlLm1pbikgOiAwO1xyXG4gICAgICAgICAgICBsZXQgbWF4ID0gcmFuZ2UubWF4ID8gcGFyc2VJbnQocmFuZ2UubWF4KSA6IDEwMDtcclxuICAgICAgICAgICAgbGV0IG5ld1ZhbCA9ICgodmFsIC0gbWluKSAqIDEwMCkgLyAobWF4IC0gbWluKTtcclxuICAgICAgICAgICAgYnViYmxlLmlubmVySFRNTCA9IFwiXCIgKyB2YWw7XHJcblxyXG4gICAgICAgICAgICAvLyBTb3J0YSBtYWdpYyBudW1iZXJzIGJhc2VkIG9uIHNpemUgb2YgdGhlIG5hdGl2ZSBVSSB0aHVtYlxyXG4gICAgICAgICAgICBidWJibGUuc3R5bGUubGVmdCA9IGBjYWxjKCR7bmV3VmFsfSUgKyAoJHs4IC0gbmV3VmFsICogMC4xNX1weCkpYDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnJhbmdlLXdyYXAuaGVhdGVyZXhwZXJpbWVudFwiKS5mb3JFYWNoKHdyYXAgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSA8SFRNTElucHV0RWxlbWVudD53cmFwLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFt0eXBlPSdyYW5nZSddXCIpITtcclxuICAgICAgICAgICAgbGV0IGJ1YmJsZSA9IDxIVE1MT3V0cHV0RWxlbWVudD53cmFwLnF1ZXJ5U2VsZWN0b3IoXCJvdXRwdXQuYnViYmxlXCIpITtcclxuICAgICAgICAgICAgcmFuZ2Uub25pbnB1dCA9IChlKSA9PiBzZXRCdWJibGUocmFuZ2UsIGJ1YmJsZSk7XHJcbiAgICAgICAgICAgIHNldEJ1YmJsZShyYW5nZSwgYnViYmxlKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuYnV0U3RvcC5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idXRTdG9wLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0UmVjb3JkLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYnV0UmVjb3JkLm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dFJlY29yZC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dFN0b3AuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmJ1dERlbGV0ZS5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldERhdGEoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEFwcE1hbmFnZW1lbnQgfSBmcm9tIFwiLi9BcHBNYW5hZ2VtZW50XCI7XHJcblxyXG5leHBvcnQgZW51bSBDb250cm9sbGVyU3RhdGUge1xyXG4gICAgQ1JFQVRFRCxcclxuICAgIFNUQVJURUQsXHJcbiAgICBTVE9QUEVELFxyXG59XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2NyZWVuQ29udHJvbGxlciB7XHJcbiAgICBwcml2YXRlIHN0YXRlOiBDb250cm9sbGVyU3RhdGU7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgYXBwTWFuYWdlbWVudDpBcHBNYW5hZ2VtZW50LCBwcm90ZWN0ZWQgZGl2OiBIVE1MRGl2RWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuaGlkZURJVigpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDb250cm9sbGVyU3RhdGUuQ1JFQVRFRDtcclxuICAgIH1cclxuICAgIGdldCBFbGVtZW50SWQoKSB7IHJldHVybiB0aGlzLmRpdi5pZDsgfVxyXG4gICAgZ2V0IFN0YXRlKCkgeyByZXR1cm4gdGhpcy5zdGF0ZTsgfVxyXG4gICAgc2V0IFN0YXRlKHZhbHVlOiBDb250cm9sbGVyU3RhdGUpIHsgdGhpcy5zdGF0ZSA9IHZhbHVlOyB9XHJcbiAgICBhYnN0cmFjdCBvbkNyZWF0ZSgpOiB2b2lkO1xyXG4gICAgYWJzdHJhY3Qgb25GaXJzdFN0YXJ0KCk6IHZvaWQ7XHJcbiAgICBhYnN0cmFjdCBvblJlc3RhcnQoKTogdm9pZDtcclxuICAgIGFic3RyYWN0IG9uU3RvcCgpOiB2b2lkO1xyXG4gICAgcHVibGljIHNob3dESVYoKSB7XHJcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBoaWRlRElWKCkge1xyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBDb25uZWN0b3JUeXBlLCBGbG93Y2hhcnRJbnB1dENvbm5lY3RvciwgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yIH0gZnJvbSBcIi4vRmxvd2NoYXJ0Q29ubmVjdG9yXCI7XHJcbmltcG9ydCB7IEZsb3djaGFydENvbXBpbGVyLCBIYXNoQW5kQnVmQW5kTWFwcywgU29ydGVkT3BlcmF0b3JzQW5kTWFwcyB9IGZyb20gXCIuL0Zsb3djaGFydENvbXBpbGVyXCI7XHJcbmltcG9ydCB7IEZsb3djaGFydExpbmsgfSBmcm9tIFwiLi9GbG93Y2hhcnRMaW5rXCI7XHJcbmltcG9ydCB7IEZsb3djaGFydE9wZXJhdG9yLCBQb3NpdGlvblR5cGUsIFR5cGVJbmZvIH0gZnJvbSBcIi4vRmxvd2NoYXJ0T3BlcmF0b3JcIjtcclxuaW1wb3J0ICogYXMgb3BlcmF0b3JpbXBsIGZyb20gXCIuL0Zsb3djaGFydE9wZXJhdG9ySW1wbFwiO1xyXG5pbXBvcnQgeyBOb2RlV3JhcHBlciwgVG9wb2xvZ2ljYWxTb3J0REZTIH0gZnJvbSBcIi4vVG9wb2xvZ2ljYWxTb3JmREZTXCI7XHJcbmltcG9ydCB7IFV0aWxzLCAkLCBLZXlWYWx1ZVR1cGxlIH0gZnJvbSBcIi4uL3V0aWxzXCI7XHJcbmltcG9ydCB7IEFwcE1hbmFnZW1lbnQgfSBmcm9tIFwiLi4vQXBwTWFuYWdlbWVudFwiO1xyXG5pbXBvcnQgeyBTZXJpYWxpemVDb250ZXh0IH0gZnJvbSBcIi4vU2VyaWFsaXplQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBTaW11bGF0aW9uTWFuYWdlciB9IGZyb20gXCIuL1NpbXVsYXRpb25NYW5hZ2VyXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgRmxvd2NoYXJ0T3B0aW9ucyB7XHJcbiAgICBjYW5Vc2VyRWRpdExpbmtzOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIGNhblVzZXJNb3ZlT3BlcmF0b3JzOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIGRhdGE/OiBGbG93Y2hhcnREYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgZGlzdGFuY2VGcm9tQXJyb3c6IG51bWJlciA9IDM7XHJcbiAgICBkZWZhdWx0T3BlcmF0b3JDbGFzczogc3RyaW5nID0gJ2Zsb3djaGFydC1kZWZhdWx0LW9wZXJhdG9yJztcclxuICAgIGRlZmF1bHRMaW5rQ29sb3I6IHN0cmluZyA9ICcjMzM2NmZmJztcclxuICAgIGRlZmF1bHRTZWxlY3RlZExpbmtDb2xvcjogc3RyaW5nID0gJ2JsYWNrJztcclxuICAgIGxpbmtXaWR0aDogbnVtYmVyID0gMTA7XHJcbiAgICBncmlkOiBudW1iZXIgPSAxMDtcclxuICAgIG11bHRpcGxlTGlua3NPbk91dHB1dDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBtdWx0aXBsZUxpbmtzT25JbnB1dDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgbGlua1ZlcnRpY2FsRGVjYWw6IG51bWJlciA9IDA7XHJcbiAgICBvbk9wZXJhdG9yU2VsZWN0PzogKG9wZXJhdG9ySWQ6IHN0cmluZykgPT4gYm9vbGVhbjtcclxuICAgIG9uT3BlcmF0b3JVbnNlbGVjdD86ICgpID0+IGJvb2xlYW47XHJcbiAgICBvbk9wZXJhdG9yTW91c2VPdmVyPzogKG9wZXJhdG9ySWQ6IHN0cmluZykgPT4gYm9vbGVhbjtcclxuICAgIG9uT3BlcmF0b3JNb3VzZU91dD86IChvcGVyYXRvcklkOiBzdHJpbmcpID0+IGJvb2xlYW47XHJcbiAgICBvbkxpbmtTZWxlY3Q/OiAobGluazogRmxvd2NoYXJ0TGluaykgPT4gYm9vbGVhbjtcclxuICAgIG9uTGlua1Vuc2VsZWN0PzogKGxpbms6IEZsb3djaGFydExpbmspID0+IGJvb2xlYW47XHJcbiAgICBvbk9wZXJhdG9yQ3JlYXRlPzogKG9wZXJhdG9ySWQ6IHN0cmluZywgb3BlcmF0b3JEYXRhOiBhbnksIGZ1bGxFbGVtZW50OiBib29sZWFuKSA9PiBib29sZWFuO1xyXG4gICAgb25MaW5rQ3JlYXRlPzogKGxpbmtJZDogc3RyaW5nLCBsaW5rRGF0YTogYW55KSA9PiBib29sZWFuO1xyXG4gICAgb25PcGVyYXRvckRlbGV0ZT86IChvcGVyYXRvcklkOiBzdHJpbmcpID0+IGJvb2xlYW47XHJcbiAgICBvbkxpbmtEZWxldGU/OiAobGlua0lkOiBzdHJpbmcsIGZvcmNlZDogYm9vbGVhbikgPT4gYm9vbGVhbjtcclxuICAgIG9uT3BlcmF0b3JNb3ZlZD86IChvcGVyYXRvcklkOiBzdHJpbmcsIHBvc2l0aW9uOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgICBvbkFmdGVyQ2hhbmdlPzogKGNoYW5nZVR5cGU6IGFueSkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGbG93Y2hhcnREYXRhIHtcclxuICAgIG9wZXJhdG9yczogT3BlcmF0b3JEYXRhW107XHJcbiAgICBsaW5rczogTGlua0RhdGFbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcGVyYXRvckRhdGEge1xyXG4gICAgZ2xvYmFsVHlwZUluZGV4OiBudW1iZXI7XHJcbiAgICBjYXB0aW9uOiBzdHJpbmc7XHJcbiAgICBpbmRleDogbnVtYmVyO1xyXG4gICAgcG9zWDogbnVtYmVyO1xyXG4gICAgcG9zWTogbnVtYmVyO1xyXG4gICAgY29uZmlndXJhdGlvbkRhdGE6IEtleVZhbHVlVHVwbGVbXSB8IG51bGw7XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaW5rRGF0YSB7XHJcbiAgICBjb2xvcjogc3RyaW5nO1xyXG4gICAgZnJvbU9wZXJhdG9ySW5kZXg6IG51bWJlcjtcclxuICAgIGZyb21PdXRwdXQ6IG51bWJlcjtcclxuICAgIHRvT3BlcmF0b3JJbmRleDogbnVtYmVyO1xyXG4gICAgdG9JbnB1dDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRmxvd2NoYXJ0IHtcclxuICAgIFxyXG4gICAgcHJpdmF0ZSBvcGVyYXRvclJlZ2lzdHJ5Om9wZXJhdG9yaW1wbC5PcGVyYXRvclJlZ2lzdHJ5O1xyXG4gICAgcHJpdmF0ZSBzaW11bGF0aW9uTWFuYWdlcj86U2ltdWxhdGlvbk1hbmFnZXJ8bnVsbDtcclxuICAgIHByaXZhdGUgb3BlcmF0b3JzID0gbmV3IE1hcDxudW1iZXIsIEZsb3djaGFydE9wZXJhdG9yPigpO1xyXG4gICAgcHJpdmF0ZSBsaW5rcyA9IG5ldyBNYXA8bnVtYmVyLCBGbG93Y2hhcnRMaW5rPigpO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEQVRBVFlQRTJDT0xPUiA9IG5ldyBNYXAoW1tDb25uZWN0b3JUeXBlLkJPT0xFQU4sIFwiUkVEXCJdLCBbQ29ubmVjdG9yVHlwZS5DT0xPUiwgXCJHUkVFTlwiXSwgW0Nvbm5lY3RvclR5cGUuRkxPQVQsIFwiQkxVRVwiXSwgW0Nvbm5lY3RvclR5cGUuSU5URUdFUiwgXCJZRUxMT1dcIl0sIFtDb25uZWN0b3JUeXBlLkNPTE9SLCBcIlBVUlBMRVwiXV0pO1xyXG4gICAgLy9NdXNzIGJlaW0gTMO2c2NoZW4rRXJ6ZXVnZW4gdm9uIE9wZXJhdG9yZW4rTGlua3MgdW5kIGJlaSBTcGVpY2hlcm4gdm9uIFByb3BlcnRpZXMgenVyw7xja2dlc2V0enQgd2VyZGVuXHJcbiAgICBwcml2YXRlIGN1cnJlbnREZWJ1Z0luZm86SGFzaEFuZEJ1ZkFuZE1hcHN8bnVsbD1udWxsO1xyXG4gICAgcHJpdmF0ZSBsYXN0T3V0cHV0Q29ubmVjdG9yQ2xpY2tlZDogRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIHNlbGVjdGVkT3BlcmF0b3I6IEZsb3djaGFydE9wZXJhdG9yIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIHNlbGVjdGVkTGluazogRmxvd2NoYXJ0TGluayB8IG51bGwgPSBudWxsO1xyXG4gICAgZ2V0IFNlbGVjdGVkTGluaygpIHsgcmV0dXJuIHRoaXMuc2VsZWN0ZWRMaW5rIH07XHJcbiAgICBnZXQgT3B0aW9ucygpIHsgcmV0dXJuIHRoaXMub3B0aW9uczsgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIHBvc2l0aW9uUmF0aW86IG51bWJlciA9IDE7XHJcbiAgICBnZXQgUG9zaXRpb25SYXRpbygpIHsgcmV0dXJuIHRoaXMucG9zaXRpb25SYXRpbzsgfVxyXG5cclxuICAgIHByaXZhdGUgZmxvd2NoYXJ0Q29udGFpbmVyU3ZnU3ZnOiBTVkdTVkdFbGVtZW50O1xyXG4gICAgZ2V0IEVsZW1lbnQoKSB7IHJldHVybiB0aGlzLmZsb3djaGFydENvbnRhaW5lclN2Z1N2ZzsgfVxyXG4gICAgcHJpdmF0ZSBsaW5rc0xheWVyOiBTVkdHRWxlbWVudDtcclxuICAgIGdldCBMaW5rTGF5ZXIoKSB7IHJldHVybiB0aGlzLmxpbmtzTGF5ZXI7IH1cclxuICAgIHByaXZhdGUgb3BlcmF0b3JzTGF5ZXI6IFNWR0dFbGVtZW50O1xyXG4gICAgZ2V0IE9wZXJhdG9yc0xheWVyKCkgeyByZXR1cm4gdGhpcy5vcGVyYXRvcnNMYXllcjsgfVxyXG4gICAgcHJpdmF0ZSBvcGVyYXRvckxpYkRpdjogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBnZXQgVG9vbHNMYXllcigpIHsgcmV0dXJuIHRoaXMub3BlcmF0b3JMaWJEaXY7IH1cclxuICAgIHByaXZhdGUgdGVtcExheWVyOiBTVkdHRWxlbWVudDtcclxuICAgIHByaXZhdGUgdGVtcG9yYXJ5TGluazogU1ZHTGluZUVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIHRlbXBvcmFyeUxpbmtTbmFwcGVkID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIHByb3BlcnR5R3JpZEh0bWxEaXY6IEhUTUxEaXZFbGVtZW50O1xyXG5cclxuICAgIHByaXZhdGUgbWFya2VyQXJyb3c6IFNWR1BhdGhFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBtYXJrZXJDaXJjbGU6IFNWR0NpcmNsZUVsZW1lbnQ7XHJcblxyXG4gICAgcHVibGljIHRyaWdnZXJEZWJ1ZygpIHtcclxuICAgICAgICBpZih0aGlzLmN1cnJlbnREZWJ1Z0luZm89PW51bGwpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcclxuICAgICAgICB4aHIub25lcnJvciA9IChlKSA9PiB7IGNvbnNvbGUubG9nKFwiRmVobGVyIGJlaW0gWE1MSHR0cFJlcXVlc3QhXCIpOyB9O1xyXG4gICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIFwiL2ZiZFwiLCB0cnVlKTtcclxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgIHhoci5vbmxvYWQgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZih0aGlzLmN1cnJlbnREZWJ1Z0luZm89PW51bGwpIHJldHVybjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBhcnJheUJ1ZmZlciA9IHhoci5yZXNwb25zZTsgLy8gTm90ZTogbm90IG9SZXEucmVzcG9uc2VUZXh0XHJcbiAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIgfHwgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCA8PTE2KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCIhIGFycmF5QnVmZmVyIHx8IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg8MTZcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREZWJ1Z0luZm89bnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY3R4ID0gbmV3IFNlcmlhbGl6ZUNvbnRleHQoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICBsZXQgaGFzaCA9IGN0eC5yZWFkVTMyKCk7XHJcbiAgICAgICAgICAgIGlmKGhhc2ghPXRoaXMuY3VycmVudERlYnVnSW5mby5oYXNoKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImhhc2ghPXRoaXMuY3VycmVudERlYnVnSW5mby5oYXNoXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RGVidWdJbmZvPW51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGJpbmFyeUNvdW50ID0gY3R4LnJlYWRVMzIoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBhZHJlc3NPZmZzZXQ9MDthZHJlc3NPZmZzZXQ8YmluYXJ5Q291bnQ7YWRyZXNzT2Zmc2V0KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGN0eC5yZWFkVTMyKCk7XHJcbiAgICAgICAgICAgICAgICBpZihhZHJlc3NPZmZzZXQ8MikgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdG9yVHlwZT1Db25uZWN0b3JUeXBlLkJPT0xFQU5cclxuICAgICAgICAgICAgICAgIGxldCBtYXAgPSB0aGlzLmN1cnJlbnREZWJ1Z0luZm8udHlwZUluZGV4MmFkcmVzc09mZnNldDJMaXN0T2ZMaW5rcy5nZXQoY29ubmVjdG9yVHlwZSkhO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmtzVG9DaGFuZ2UgPSBtYXAuZ2V0KGFkcmVzc09mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBpZihsaW5rc1RvQ2hhbmdlPT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBsaW5rc1RvQ29sb3JpemU9PT11bmRlZmluZWQgZm9yIGNvbm5lY3RvclR5cGUgJHtjb25uZWN0b3JUeXBlfSBhZGRyZXNzT2Zmc2V0ICR7YWRyZXNzT2Zmc2V0fSBhbmQgdmFsdWUgJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpbmtzVG9DaGFuZ2UuZm9yRWFjaCgoZSk9PntcclxuICAgICAgICAgICAgICAgICAgICBlLlNldENvbG9yKHZhbHVlPT0xP1wicmVkXCI6XCJncmV5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuU2V0Q2FwdGlvbihcIlwiK3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgaW50ZWdlckNvdW50ID0gY3R4LnJlYWRVMzIoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBhZHJlc3NPZmZzZXQ9MDthZHJlc3NPZmZzZXQ8aW50ZWdlckNvdW50O2FkcmVzc09mZnNldCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBjdHgucmVhZFMzMigpO1xyXG4gICAgICAgICAgICAgICAgaWYoYWRyZXNzT2Zmc2V0PDIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RvclR5cGU9Q29ubmVjdG9yVHlwZS5JTlRFR0VSXHJcbiAgICAgICAgICAgICAgICBsZXQgbWFwID0gdGhpcy5jdXJyZW50RGVidWdJbmZvLnR5cGVJbmRleDJhZHJlc3NPZmZzZXQyTGlzdE9mTGlua3MuZ2V0KGNvbm5lY3RvclR5cGUpITtcclxuICAgICAgICAgICAgICAgIGxldCBsaW5rc1RvQ2hhbmdlID0gbWFwLmdldChhZHJlc3NPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYobGlua3NUb0NoYW5nZT09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgbGlua3NUb0NvbG9yaXplPT09dW5kZWZpbmVkIGZvciBjb25uZWN0b3JUeXBlICR7Y29ubmVjdG9yVHlwZX0gYWRkcmVzc09mZnNldCAke2FkcmVzc09mZnNldH0gYW5kIHZhbHVlICR7dmFsdWV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaW5rc1RvQ2hhbmdlLmZvckVhY2goKGUpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgZS5TZXRDYXB0aW9uKFwiXCIrdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBmbG9hdHNDb3VudCA9IGN0eC5yZWFkVTMyKCk7XHJcbiAgICAgICAgICAgIGZvcihsZXQgYWRyZXNzT2Zmc2V0PTA7YWRyZXNzT2Zmc2V0PGZsb2F0c0NvdW50O2FkcmVzc09mZnNldCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBjdHgucmVhZEYzMigpO1xyXG4gICAgICAgICAgICAgICAgaWYoYWRyZXNzT2Zmc2V0PDIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RvclR5cGU9Q29ubmVjdG9yVHlwZS5GTE9BVFxyXG4gICAgICAgICAgICAgICAgbGV0IG1hcCA9IHRoaXMuY3VycmVudERlYnVnSW5mby50eXBlSW5kZXgyYWRyZXNzT2Zmc2V0Mkxpc3RPZkxpbmtzLmdldChjb25uZWN0b3JUeXBlKSE7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGlua3NUb0NoYW5nZSA9IG1hcC5nZXQoYWRyZXNzT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGlmKGxpbmtzVG9DaGFuZ2U9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGxpbmtzVG9Db2xvcml6ZT09PXVuZGVmaW5lZCBmb3IgY29ubmVjdG9yVHlwZSAke2Nvbm5lY3RvclR5cGV9IGFkZHJlc3NPZmZzZXQgJHthZHJlc3NPZmZzZXR9IGFuZCB2YWx1ZSAke3ZhbHVlfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlua3NUb0NoYW5nZS5mb3JFYWNoKChlKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGUuU2V0Q2FwdGlvbihcIlwiK3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgY29sb3JzQ291bnQgPSBjdHgucmVhZFUzMigpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGFkcmVzc09mZnNldD0wO2FkcmVzc09mZnNldDxjb2xvcnNDb3VudDthZHJlc3NPZmZzZXQrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gY3R4LnJlYWRVMzIoKTtcclxuICAgICAgICAgICAgICAgIGlmKGFkcmVzc09mZnNldDwyKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0b3JUeXBlPUNvbm5lY3RvclR5cGUuQ09MT1JcclxuICAgICAgICAgICAgICAgIGxldCBtYXAgPSB0aGlzLmN1cnJlbnREZWJ1Z0luZm8udHlwZUluZGV4MmFkcmVzc09mZnNldDJMaXN0T2ZMaW5rcy5nZXQoY29ubmVjdG9yVHlwZSkhO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmtzVG9DaGFuZ2UgPSBtYXAuZ2V0KGFkcmVzc09mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBpZihsaW5rc1RvQ2hhbmdlPT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBsaW5rc1RvQ29sb3JpemU9PT11bmRlZmluZWQgZm9yIGNvbm5lY3RvclR5cGUgJHtjb25uZWN0b3JUeXBlfSBhZGRyZXNzT2Zmc2V0ICR7YWRyZXNzT2Zmc2V0fSBhbmQgdmFsdWUgJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpbmtzVG9DaGFuZ2UuZm9yRWFjaCgoZSk9PntcclxuICAgICAgICAgICAgICAgICAgICBlLlNldENhcHRpb24oXCJcIit2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5TZXRDb2xvcigkLkNvbG9yTnVtQ29sb3IyQ29sb3JEb21TdHJpbmcodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHhoci5zZW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9ub3RpZnlHbG9iYWxNb3VzZW1vdmVXaXRoTGluayhlOiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdE91dHB1dENvbm5lY3RvckNsaWNrZWQgIT0gbnVsbCAmJiAhdGhpcy50ZW1wb3JhcnlMaW5rU25hcHBlZCkge1xyXG4gICAgICAgICAgICBsZXQgZW5kID0gVXRpbHMuRXZlbnRDb29yZGluYXRlc0luU1ZHKGUsIHRoaXMuZmxvd2NoYXJ0Q29udGFpbmVyU3ZnU3ZnLCB0aGlzLnBvc2l0aW9uUmF0aW8pO1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUxpbmsuc2V0QXR0cmlidXRlKCd4MicsIFwiXCIgKyBlbmQueCk7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5TGluay5zZXRBdHRyaWJ1dGUoJ3kyJywgXCJcIiArIGVuZC55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9ub3RpZnlHbG9iYWxNb3VzZXVwV2l0aExpbmsoZTogTW91c2VFdmVudCkge1xyXG4gICAgICAgIHRoaXMudW5zZXRUZW1wb3JhcnlMaW5rKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9ub3RpZnlPdXRwdXRDb25uZWN0b3JNb3VzZWRvd24oYzogRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yLCBlOiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlMaW5rU25hcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBzdGFydCA9IGMuR2V0TGlua3BvaW50KCk7XHJcbiAgICAgICAgbGV0IGVuZCA9IFV0aWxzLkV2ZW50Q29vcmRpbmF0ZXNJblNWRyhlLCB0aGlzLmZsb3djaGFydENvbnRhaW5lclN2Z1N2ZywgdGhpcy5wb3NpdGlvblJhdGlvKTtcclxuICAgICAgICB0aGlzLnRlbXBvcmFyeUxpbmsuc2V0QXR0cmlidXRlKCd4MScsIFwiXCIgKyBzdGFydC54KTtcclxuICAgICAgICB0aGlzLnRlbXBvcmFyeUxpbmsuc2V0QXR0cmlidXRlKCd5MScsIFwiXCIgKyBzdGFydC55KTtcclxuICAgICAgICB0aGlzLnRlbXBvcmFyeUxpbmsuc2V0QXR0cmlidXRlKCd4MicsIFwiXCIgKyBlbmQueCk7XHJcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlMaW5rLnNldEF0dHJpYnV0ZSgneTInLCBcIlwiICsgZW5kLnkpO1xyXG4gICAgICAgIHRoaXMuc2V0VGVtcG9yYXJ5TGluayhjKTtcclxuICAgICAgICBkb2N1bWVudC5vbm1vdXNldXAgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5vbm1vdXNldXAgPSBudWxsO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5vbm1vdXNlbW92ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeUdsb2JhbE1vdXNldXBXaXRoTGluayhlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5R2xvYmFsTW91c2Vtb3ZlV2l0aExpbmsoZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX25vdGlmeUlucHV0Q29ubmVjdG9yTW91c2V1cChjOiBGbG93Y2hhcnRJbnB1dENvbm5lY3RvciwgZTogTW91c2VFdmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RPdXRwdXRDb25uZWN0b3JDbGlja2VkID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aXBsZUxpbmtzT25JbnB1dCAmJiBjLkxpbmtzTGVuZ3RoID4gMCkgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RPdXRwdXRDb25uZWN0b3JDbGlja2VkLlR5cGUgPT0gYy5UeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTGluayhudWxsLCB0aGlzLmxhc3RPdXRwdXRDb25uZWN0b3JDbGlja2VkLCBjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51bnNldFRlbXBvcmFyeUxpbmsoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9ub3RpZnlPcGVyYXRvckNsaWNrZWQobzogRmxvd2NoYXJ0T3BlcmF0b3IsIGU6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICB0aGlzLlNlbGVjdE9wZXJhdG9yKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfbm90aWZ5TGlua0NsaWNrZWQobGluazogRmxvd2NoYXJ0TGluaywgZTogTW91c2VFdmVudCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0TGluayhsaW5rKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX25vdGlmeUlucHV0Q29ubmVjdG9yTW91c2VlbnRlcihjOiBGbG93Y2hhcnRJbnB1dENvbm5lY3RvciwgZTogTW91c2VFdmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RPdXRwdXRDb25uZWN0b3JDbGlja2VkID09IG51bGwgfHwgdGhpcy5sYXN0T3V0cHV0Q29ubmVjdG9yQ2xpY2tlZC5UeXBlICE9IGMuVHlwZSkgcmV0dXJuO1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlTGlua3NPbklucHV0ICYmIGMuTGlua3NMZW5ndGggPiAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5TGlua1NuYXBwZWQgPSB0cnVlO1xyXG4gICAgICAgIGxldCBlbmQgPSBjLkdldExpbmtwb2ludCgpO1xyXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5TGluay5zZXRBdHRyaWJ1dGUoXCJtYXJrZXItZW5kXCIsIFwidXJsKCNtYXJrZXItY2lyY2xlKVwiKTtcclxuICAgICAgICB0aGlzLnRlbXBvcmFyeUxpbmsuc2V0QXR0cmlidXRlKCd4MicsIFwiXCIgKyBlbmQueCk7XHJcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlMaW5rLnNldEF0dHJpYnV0ZSgneTInLCBcIlwiICsgZW5kLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfbm90aWZ5SW5wdXRDb25uZWN0b3JNb3VzZWxlYXZlKGM6IEZsb3djaGFydElucHV0Q29ubmVjdG9yLCBlOiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlMaW5rU25hcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5TGluay5zZXRBdHRyaWJ1dGUoXCJtYXJrZXItZW5kXCIsIFwidXJsKCNtYXJrZXItYXJyb3cpXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1bnNlbGVjdExpbmsoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRMaW5rICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkxpbmtVbnNlbGVjdCAmJiAhdGhpcy5vcHRpb25zLm9uTGlua1Vuc2VsZWN0KHRoaXMuc2VsZWN0ZWRMaW5rKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRMaW5rLlVuc2V0Q29sb3IoKTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZExpbmsgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0TGluayhsaW5rOiBGbG93Y2hhcnRMaW5rKSB7XHJcbiAgICAgICAgdGhpcy51bnNlbGVjdExpbmsoKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uTGlua1NlbGVjdCAmJiAhdGhpcy5vcHRpb25zLm9uTGlua1NlbGVjdChsaW5rKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudW5zZWxlY3RPcGVyYXRvcigpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMaW5rID0gbGluaztcclxuICAgICAgICBsaW5rLlNldENvbG9yKHRoaXMub3B0aW9ucy5kZWZhdWx0U2VsZWN0ZWRMaW5rQ29sb3IpO1xyXG4gICAgfVxyXG4gXHJcblxyXG4gICAgcHJpdmF0ZSBkZWxldGVTZWxlY3RlZFRoaW5nKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkT3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5EZWxldGVPcGVyYXRvcih0aGlzLnNlbGVjdGVkT3BlcmF0b3IuR2xvYmFsT3BlcmF0b3JJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRMaW5rKSB7XHJcbiAgICAgICAgICAgIHRoaXMuRGVsZXRlTGluayh0aGlzLnNlbGVjdGVkTGluay5HbG9iYWxMaW5rSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGZiZDJqc29uKCk6c3RyaW5ne1xyXG4gICAgICAgIGxldCBvcGVyYXRvcnM6IE9wZXJhdG9yRGF0YVtdID0gW107XHJcbiAgICAgICAgbGV0IGxpbmtzOiBMaW5rRGF0YVtdID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiB0aGlzLm9wZXJhdG9ycy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBvcGVyYXRvcnMucHVzaCh7IGdsb2JhbFR5cGVJbmRleDogb3AuVHlwZUluZm8uR2xvYmFsVHlwZUluZGV4LCBjYXB0aW9uOiBvcC5DYXB0aW9uLCBpbmRleDogb3AuR2xvYmFsT3BlcmF0b3JJbmRleCwgcG9zWDogb3AuWHBvcywgcG9zWTogb3AuWXBvcywgY29uZmlndXJhdGlvbkRhdGE6IG9wLkNvbmZpZ19Db3B5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2YgdGhpcy5saW5rcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcImJsdWVcIixcclxuICAgICAgICAgICAgICAgIGZyb21PcGVyYXRvckluZGV4OiBsaW5rLkZyb20uUGFyZW50Lkdsb2JhbE9wZXJhdG9ySW5kZXgsXHJcbiAgICAgICAgICAgICAgICBmcm9tT3V0cHV0OiBsaW5rLkZyb20uTG9jYWxDb25uZWN0b3JJbmRleCxcclxuICAgICAgICAgICAgICAgIHRvT3BlcmF0b3JJbmRleDogbGluay5Uby5QYXJlbnQuR2xvYmFsT3BlcmF0b3JJbmRleCxcclxuICAgICAgICAgICAgICAgIHRvSW5wdXQ6IGxpbmsuVG8uTG9jYWxDb25uZWN0b3JJbmRleCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkYXRhOiBGbG93Y2hhcnREYXRhID0geyBvcGVyYXRvcnM6IG9wZXJhdG9ycywgbGlua3M6IGxpbmtzIH07XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIFxyXG5cclxuICAgIHByaXZhdGUgc2F2ZUpTT05Ub0xvY2FsRmlsZSgpIHtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuZmJkMmpzb24oKTtcclxuICAgICAgICBsZXQgZmlsZW5hbWUgPSBcImZ1bmN0aW9uQmxvY2tEaWFncmFtLmpzb25cIjtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaHJlZicsICdkYXRhOnRleHQvcGxhaW47Y2hhcnNldD11dGYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpKTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgZWxlbWVudC5jbGljaygpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzYXZlQmluVG9Mb2NhbEZpbGUoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHRleHQgPSB0aGlzLmZiZDJqc29uKCk7XHJcbiAgICAgICAgbGV0IGNvbXBpbGVySW5zdGFuY2UgPSBuZXcgRmxvd2NoYXJ0Q29tcGlsZXIodGhpcy5vcGVyYXRvcnMpO1xyXG4gICAgICAgIGxldCBiaW5GaWxlID1jb21waWxlckluc3RhbmNlLkNvbXBpbGUoKTsgIFxyXG4gICAgICAgIGxldCBibG9iID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KGJpbkZpbGUuYnVmLCAwLCBiaW5GaWxlLmJ1Zi5ieXRlTGVuZ3RoKV0sIHt0eXBlOiBcIm9jdGV0L3N0cmVhbVwifSk7XHJcbiAgICAgICAgbGV0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICAgIGxldCBmaWxlbmFtZSA9IFwiZnVuY3Rpb25CbG9ja0RpYWdyYW0uYmluXCI7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIGVsZW1lbnQuaHJlZj11cmw7XHJcbiAgICAgICAgZWxlbWVudC5kb3dubG9hZD1maWxlbmFtZTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gICAgICAgIGVsZW1lbnQuY2xpY2soKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb3BlbkZyb21Mb2NhbEZpbGUoZmlsZXM6IEZpbGVMaXN0IHwgbnVsbCkge1xyXG4gICAgICAgIGlmIChmaWxlcyA9PSBudWxsIHx8IGZpbGVzLmxlbmd0aCAhPSAxKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gKGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IHM6IHN0cmluZyA9IDxzdHJpbmc+ZS50YXJnZXQhLnJlc3VsdDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSA8Rmxvd2NoYXJ0RGF0YT5KU09OLnBhcnNlKHMpO1xyXG4gICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGVzWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHB1dDJmYmQoYnVmOkFycmF5QnVmZmVyKVxyXG4gICAge1xyXG4gICAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Q7XHJcbiAgICAgICAgeGhyLm9wZW4oXCJQVVRcIiwgXCIvZmJkXCIsIHRydWUpO1xyXG4gICAgICAgIHhoci5vbmxvYWRlbmQgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZih4aHIuc3RhdHVzIT0yMDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBNYW5hZ2VtZW50LkRpYWxvZ0NvbnRyb2xsZXIoKS5zaG93T0tEaWFsb2coMTYsIGBIVFRQIEVycm9yICR7eGhyLnN0YXR1c31gLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFwcE1hbmFnZW1lbnQuRGlhbG9nQ29udHJvbGxlcigpLnNob3dPS0RpYWxvZygxNiwgYFN1Y2Nlc3NmdWxseSBzYXZlZGAsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB4aHIub25lcnJvciA9IChlKSA9PiB7IFxyXG4gICAgICAgICAgICB0aGlzLmFwcE1hbmFnZW1lbnQuRGlhbG9nQ29udHJvbGxlcigpLnNob3dPS0RpYWxvZygxNiwgYEdlbmVyaWMgRXJyb3JgLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeGhyLnNlbmQoYnVmKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNhdmVKU09OVG9MYWJhdGhvbWVGaWxlKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hcHBNYW5hZ2VtZW50LkRpYWxvZ0NvbnRyb2xsZXIoKS5zaG93RW50ZXJGaWxlbmFtZURpYWxvZygxMCwgXCJFbnRlciBmaWxlbmFtZSAod2l0aG91dCBFeHRlbnNpb25cIiwgKGZpbGVuYW1lOnN0cmluZyk9PntcclxuICAgICAgICAgICAgbGV0IHhocl9qc29uID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xyXG4gICAgICAgICAgICB4aHJfanNvbi5vcGVuKFwiUE9TVFwiLCBcIi9mYmRzdG9yZWpzb24vXCIrZmlsZW5hbWUsIHRydWUpO1xyXG4gICAgICAgICAgICB4aHJfanNvbi5vbmxvYWRlbmQgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYoeGhyX2pzb24uc3RhdHVzIT0yMDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwTWFuYWdlbWVudC5EaWFsb2dDb250cm9sbGVyKCkuc2hvd09LRGlhbG9nKDE2LCBgSFRUUCBFcnJvciAke3hocl9qc29uLnN0YXR1c31gLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcE1hbmFnZW1lbnQuRGlhbG9nQ29udHJvbGxlcigpLnNob3dPS0RpYWxvZygxNiwgYFN1Y2Nlc3NmdWxseSBzYXZlZGAsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhocl9qc29uLm9uZXJyb3IgPSAoZSkgPT4geyB0aGlzLmFwcE1hbmFnZW1lbnQuRGlhbG9nQ29udHJvbGxlcigpLnNob3dPS0RpYWxvZygxNiwgYEdlbmVyaWMgRXJyb3JgLCBudWxsKTt9XHJcbiAgICAgICAgICAgIHhocl9qc29uLnNlbmQodGhpcy5mYmQyanNvbigpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzYXZlSlNPTmFuZEJJTlRvTGFiYXRob21lRGVmYXVsdEZpbGUoYnVmOkFycmF5QnVmZmVyKVxyXG4gICAge1xyXG4gICAgICAgIGxldCB4aHJfYmluID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgeGhyX2Jpbi5vcGVuKFwiUE9TVFwiLCBcIi9mYmRkZWZhdWx0YmluXCIsIHRydWUpO1xyXG4gICAgICAgIHhocl9iaW4ub25sb2FkZW5kID0gKGUpID0+IHtcclxuICAgICAgICAgICAgaWYoeGhyX2Jpbi5zdGF0dXMhPTIwMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcE1hbmFnZW1lbnQuRGlhbG9nQ29udHJvbGxlcigpLnNob3dPS0RpYWxvZygxNiwgYEhUVFAgRXJyb3IgJHt4aHJfYmluLnN0YXR1c31gLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeGhyX2pzb24gID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIHhocl9qc29uLm9wZW4oXCJQT1NUXCIsIFwiL2ZiZGRlZmF1bHRqc29uXCIsIHRydWUpO1xyXG4gICAgICAgICAgICB4aHJfanNvbi5vbmxvYWRlbmQgPShlKT0+e1xyXG4gICAgICAgICAgICAgICAgaWYoeGhyX2pzb24uc3RhdHVzIT0yMDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwTWFuYWdlbWVudC5EaWFsb2dDb250cm9sbGVyKCkuc2hvd09LRGlhbG9nKDE2LCBgSFRUUCBFcnJvciAke3hocl9qc29uLnN0YXR1c31gLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcE1hbmFnZW1lbnQuRGlhbG9nQ29udHJvbGxlcigpLnNob3dPS0RpYWxvZygxNiwgYFN1Y2Nlc3NmdWxseSBzZXQgYSBuZXcgZGVmYXVsdCBGQkRgLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4aHJfanNvbi5vbmVycm9yID0gKGUpID0+IHsgdGhpcy5hcHBNYW5hZ2VtZW50LkRpYWxvZ0NvbnRyb2xsZXIoKS5zaG93T0tEaWFsb2coMTYsIGBHZW5lcmljIEVycm9yYCwgbnVsbCk7fVxyXG4gICAgICAgICAgICB4aHJfanNvbi5zZW5kKHRoaXMuZmJkMmpzb24oKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgeGhyX2Jpbi5vbmVycm9yID0gKGUpID0+IHsgdGhpcy5hcHBNYW5hZ2VtZW50LkRpYWxvZ0NvbnRyb2xsZXIoKS5zaG93T0tEaWFsb2coMTYsIGBHZW5lcmljIEVycm9yYCwgbnVsbCk7fVxyXG4gICAgICAgIHhocl9iaW4uc2VuZChidWYpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb3BlbkpTT05Gcm9tTGFiYXRob21lKClcclxuICAgIHtcclxuICAgICAgICBsZXQgZmlsZW5hbWU6c3RyaW5nID0gXCJcIjtcclxuICAgICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xyXG4gICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIFwiL2ZiZHN0b3JlanNvbi9cIiwgdHJ1ZSk7Ly9HRVQgd2l0aG91dCBmaWxlbmFtZSwgYnV0IHdpdGggXCIvXCIgYXQgdGhlIGVuZCEhIVxyXG4gICAgICAgIHhoci5vbmxvYWQgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcyA9IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gPHN0cmluZ1tdPkpTT04ucGFyc2Uocyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwTWFuYWdlbWVudC5EaWFsb2dDb250cm9sbGVyKCkuc2hvd0ZpbGVsaXN0KDEwMDAsIGRhdGEsIFxyXG4gICAgICAgICAgICAgICAgKGZpbGVuYW1lOnN0cmluZyk9PntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIFwiL2ZiZHN0b3JlanNvbi9cIitmaWxlbmFtZSwgdHJ1ZSk7IC8vR0VUIHdpdGggdGhlIGZpbGVuYW1lIHNlbGVjdGVkIGluIHRoZSBkaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IDxGbG93Y2hhcnREYXRhPkpTT04ucGFyc2Uocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAoZmlsZW5hbWU6c3RyaW5nKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJERUxFVEVcIiwgXCIvZmJkc3RvcmVqc29uL1wiK2ZpbGVuYW1lLCB0cnVlKTsgLy9HRVQgd2l0aCB0aGUgZmlsZW5hbWUgc2VsZWN0ZWQgaW4gdGhlIGRpYWxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vbmxvYWRlbmQgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcE1hbmFnZW1lbnQuRGlhbG9nQ29udHJvbGxlcigpLnNob3dPS0RpYWxvZygxLCBgRmlsZSAke2ZpbGVuYW1lfSBkZWxldGVkIHN1Y2Nlc3NmdWxseWAsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIG9wZW5EZWZhdWx0SlNPTkZyb21MYWJhdGhvbWUoKVxyXG4gICAge1xyXG4gICAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Q7XHJcbiAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgXCIvZmJkZGVmYXVsdGpzb25cIiwgdHJ1ZSk7XHJcbiAgICAgICAgeGhyLm9ubG9hZCA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzID0geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSA8Rmxvd2NoYXJ0RGF0YT5KU09OLnBhcnNlKHMpO1xyXG4gICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHhoci5zZW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgXHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZE1lbnUoc3ViY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCkge1xyXG4gICAgICAgIGxldCBmaWxlSW5wdXQgPSA8SFRNTElucHV0RWxlbWVudD4kLkh0bWwoc3ViY29udGFpbmVyLCBcImlucHV0XCIsIFtcInR5cGVcIiwgXCJmaWxlXCIsIFwiaWRcIiwgXCJmaWxlSW5wdXRcIiwgXCJhY2NlcHRcIiwgXCIuanNvblwiXSk7XHJcbiAgICAgICAgZmlsZUlucHV0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICBmaWxlSW5wdXQub25jaGFuZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5Gcm9tTG9jYWxGaWxlKGZpbGVJbnB1dC5maWxlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdG9vbGJhciA9ICQuSHRtbChzdWJjb250YWluZXIsIFwiZGl2XCIsIFtdLCBbXCJkZXZlbG9wLXRvb2xiYXJcIl0pO1xyXG4gICAgICAgIGxldCBtZW51RmlsZSA9ICQuSHRtbCh0b29sYmFyLCBcImRpdlwiLCBbXSwgW1wiZHJvcGRvd25cIl0pO1xyXG4gICAgICAgIGxldCBtZW51RmlsZURyb3BCdG4gPSA8SFRNTEJ1dHRvbkVsZW1lbnQ+JC5IdG1sKG1lbnVGaWxlLCBcImJ1dHRvblwiLCBbXSwgW1wiZHJvcGJ0blwiXSwgXCJGaWxlIOKWvFwiKTtcclxuICAgICAgICBsZXQgbWVudUZpbGVEcm9wQ29udGVudCA9ICQuSHRtbChtZW51RmlsZSwgXCJkaXZcIiwgW10sIFtcImRyb3Bkb3duLWNvbnRlbnRcIl0pO1xyXG4gICAgICAgIG1lbnVGaWxlRHJvcEJ0bi5vbmNsaWNrID0gKGUpID0+IHsgbWVudUZpbGVEcm9wQ29udGVudC5jbGFzc0xpc3QudG9nZ2xlKFwic2hvd1wiKTsgfTtcclxuICAgICAgICAkLkh0bWwobWVudUZpbGVEcm9wQ29udGVudCwgXCJhXCIsIFtcImhyZWZcIiwgXCIjXCJdLCBbXSwgXCLwn5OCIE9wZW4gKExvY2FsKVwiKS5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZHJvcGRvd24tY29udGVudFwiKSwgKGVsZW06IEhUTUxEaXZFbGVtZW50KSA9PiB7IGVsZW0uY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7IH0pO1xyXG4gICAgICAgICAgICBmaWxlSW5wdXQuY2xpY2soKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkLkh0bWwobWVudUZpbGVEcm9wQ29udGVudCwgXCJhXCIsIFtcImhyZWZcIiwgXCIjXCJdLCBbXSwgXCLwn5OCIE9wZW4gKGxhYmF0aG9tZSlcIikub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRyb3Bkb3duLWNvbnRlbnRcIiksIChlbGVtOiBIVE1MRGl2RWxlbWVudCkgPT4geyBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5vcGVuSlNPTkZyb21MYWJhdGhvbWUoKVxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQuSHRtbChtZW51RmlsZURyb3BDb250ZW50LCBcImFcIiwgW1wiaHJlZlwiLCBcIiNcIl0sIFtdLCBcIvCfk4IgT3BlbiBEZWZhdWx0IChsYWJhdGhvbWUpXCIpLm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJkcm9wZG93bi1jb250ZW50XCIpLCAoZWxlbTogSFRNTERpdkVsZW1lbnQpID0+IHsgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbkRlZmF1bHRKU09ORnJvbUxhYmF0aG9tZSgpXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJC5IdG1sKG1lbnVGaWxlRHJvcENvbnRlbnQsIFwiYVwiLCBbXCJocmVmXCIsIFwiI1wiXSwgW10sIFwi8J+SviBTYXZlIChMb2NhbClcIikub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRyb3Bkb3duLWNvbnRlbnRcIiksIChlbGVtOiBIVE1MRGl2RWxlbWVudCkgPT4geyBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5zYXZlSlNPTlRvTG9jYWxGaWxlKCk7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgJC5IdG1sKG1lbnVGaWxlRHJvcENvbnRlbnQsIFwiYVwiLCBbXCJocmVmXCIsIFwiI1wiXSwgW10sIFwi8J+SviBTYXZlIChsYWJhdGhvbWUpXCIpLm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJkcm9wZG93bi1jb250ZW50XCIpLCAoZWxlbTogSFRNTERpdkVsZW1lbnQpID0+IHsgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZUpTT05Ub0xhYmF0aG9tZUZpbGUoKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkLkh0bWwobWVudUZpbGVEcm9wQ29udGVudCwgXCJhXCIsIFtcImhyZWZcIiwgXCIjXCJdLCBbXSwgXCLwn5K+IFNhdmUgQmluIChMb2NhbClcIikub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRyb3Bkb3duLWNvbnRlbnRcIiksIChlbGVtOiBIVE1MRGl2RWxlbWVudCkgPT4geyBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5zYXZlQmluVG9Mb2NhbEZpbGUoKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2xldCBydW5idXR0b24gPSAkLkh0bWwodG9vbGJhciwgXCJhXCIsIFtcImhyZWZcIiwgXCIjXCJdLCBbXCJkZXZlbG9wLXRvb2xiYXJcIl0sIFwiUnVuXCIpO1xyXG5cclxuICAgICAgICBsZXQgbWVudURlYnVnID0gJC5IdG1sKHRvb2xiYXIsIFwiZGl2XCIsIFtdLCBbXCJkcm9wZG93blwiXSk7XHJcbiAgICAgICAgbGV0IG1lbnVEZWJ1Z0Ryb3BCdG4gPSA8SFRNTEJ1dHRvbkVsZW1lbnQ+JC5IdG1sKG1lbnVEZWJ1ZywgXCJidXR0b25cIiwgW10sIFtcImRyb3BidG5cIl0sIFwiRGVidWcg4pa8XCIpO1xyXG5cclxuICAgICAgICBsZXQgbWVudURlYnVnRHJvcENvbnRlbnQgPSAkLkh0bWwobWVudURlYnVnLCBcImRpdlwiLCBbXSwgW1wiZHJvcGRvd24tY29udGVudFwiXSk7XHJcbiAgICAgICAgbWVudURlYnVnRHJvcEJ0bi5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgbWVudURlYnVnRHJvcENvbnRlbnQuY2xhc3NMaXN0LnRvZ2dsZShcInNob3dcIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAkLkh0bWwobWVudURlYnVnRHJvcENvbnRlbnQsIFwiYVwiLCBbXCJocmVmXCIsIFwiI1wiXSwgW10sIFwi4pitIFJ1biBOb3dcIikub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRyb3Bkb3duLWNvbnRlbnRcIiksIChlbGVtOiBIVE1MRGl2RWxlbWVudCkgPT4geyBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpOyB9KTtcclxuICAgICAgICAgICAgbGV0IGNvbXBpbGVySW5zdGFuY2UgPSBuZXcgRmxvd2NoYXJ0Q29tcGlsZXIodGhpcy5vcGVyYXRvcnMpO1xyXG4gICAgICAgICAgICBsZXQgZ3VpZEFuZEJ1ZkFuZE1hcDogSGFzaEFuZEJ1ZkFuZE1hcHM9Y29tcGlsZXJJbnN0YW5jZS5Db21waWxlKCk7ICBcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGVidWdJbmZvPWd1aWRBbmRCdWZBbmRNYXA7XHJcbiAgICAgICAgICAgIHRoaXMucHV0MmZiZChndWlkQW5kQnVmQW5kTWFwLmJ1Zik7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJC5IdG1sKG1lbnVEZWJ1Z0Ryb3BDb250ZW50LCBcImFcIiwgW1wiaHJlZlwiLCBcIiNcIl0sIFtdLCBcIvCfkaMgU2V0IGFzIFN0YXJ0dXAtQXBwXCIpLm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJkcm9wZG93bi1jb250ZW50XCIpLCAoZWxlbTogSFRNTERpdkVsZW1lbnQpID0+IHsgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTsgfSk7XHJcbiAgICAgICAgICAgIGxldCBjb21waWxlckluc3RhbmNlID0gbmV3IEZsb3djaGFydENvbXBpbGVyKHRoaXMub3BlcmF0b3JzKTtcclxuICAgICAgICAgICAgbGV0IGd1aWRBbmRCdWZBbmRNYXA6IEhhc2hBbmRCdWZBbmRNYXBzPWNvbXBpbGVySW5zdGFuY2UuQ29tcGlsZSgpOyAgXHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZUpTT05hbmRCSU5Ub0xhYmF0aG9tZURlZmF1bHRGaWxlKGd1aWRBbmRCdWZBbmRNYXAuYnVmKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWVudVNpbXVsYXRpb24gPSAkLkh0bWwodG9vbGJhciwgXCJkaXZcIiwgW10sIFtcImRyb3Bkb3duXCJdKTtcclxuICAgICAgICBsZXQgbWVudVNpbXVsYXRpb25Ecm9wQnRuID0gPEhUTUxCdXR0b25FbGVtZW50PiQuSHRtbChtZW51U2ltdWxhdGlvbiwgXCJidXR0b25cIiwgW10sIFtcImRyb3BidG5cIl0sIFwiU2ltdWxhdGlvbiDilrxcIik7XHJcblxyXG4gICAgICAgIGxldCBtZW51U2ltdWxhdGlvbkRyb3BDb250ZW50ID0gJC5IdG1sKG1lbnVTaW11bGF0aW9uLCBcImRpdlwiLCBbXSwgW1wiZHJvcGRvd24tY29udGVudFwiXSk7XHJcbiAgICAgICAgbWVudVNpbXVsYXRpb25Ecm9wQnRuLm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBtZW51U2ltdWxhdGlvbkRyb3BDb250ZW50LmNsYXNzTGlzdC50b2dnbGUoXCJzaG93XCIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgJC5IdG1sKG1lbnVTaW11bGF0aW9uRHJvcENvbnRlbnQsIFwiYVwiLCBbXCJocmVmXCIsIFwiI1wiXSwgW10sIFwi4p6kIFN0YXJ0IFNpbXVsYXRpb25cIikub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRyb3Bkb3duLWNvbnRlbnRcIiksIChlbGVtOiBIVE1MRGl2RWxlbWVudCkgPT4geyBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpOyB9KTtcclxuICAgICAgICAgICAgbGV0IGNvbXBpbGVySW5zdGFuY2UgPSBuZXcgRmxvd2NoYXJ0Q29tcGlsZXIodGhpcy5vcGVyYXRvcnMpO1xyXG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRpb25NYW5hZ2VyPW5ldyBTaW11bGF0aW9uTWFuYWdlcihjb21waWxlckluc3RhbmNlLkNvbXBpbGVGb3JTaW11bGF0aW9uKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRpb25NYW5hZ2VyLlN0YXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkLkh0bWwobWVudVNpbXVsYXRpb25Ecm9wQ29udGVudCwgXCJhXCIsIFtcImhyZWZcIiwgXCIjXCJdLCBbXSwgXCLDlyBTdG9wIFNpbXVsYXRpb25cIikub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRyb3Bkb3duLWNvbnRlbnRcIiksIChlbGVtOiBIVE1MRGl2RWxlbWVudCkgPT4geyBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uTWFuYWdlcj8uU3RvcCgpO1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vbGV0IG1lbnVEZWJ1Z0xpbmsyID0gJC5IdG1sKG1lbnVEZWJ1Z0Ryb3BDb250ZW50LCBcImFcIiwgW1wiaHJlZlwiLCBcIiNcIl0sIFtdLCBcIuKXiSBTdG9wXCIpO1xyXG4gICAgICAgIC8vbGV0IG1lbnVEZWJ1Z0xpbmszID0gJC5IdG1sKG1lbnVEZWJ1Z0Ryb3BDb250ZW50LCBcImFcIiwgW1wiaHJlZlwiLCBcIiNcIl0sIFtdLCBcIuKXryBFcmFzZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwcE1hbmFnZW1lbnQ6QXBwTWFuYWdlbWVudCwgcHJpdmF0ZSBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcml2YXRlIG9wdGlvbnM6IEZsb3djaGFydE9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJjb250YWluZXIgaXMgbnVsbFwiKTtcclxuICAgICAgICB0aGlzLm9wZXJhdG9yUmVnaXN0cnk9b3BlcmF0b3JpbXBsLk9wZXJhdG9yUmVnaXN0cnkuQnVpbGQoKTtcclxuICAgICAgICBsZXQgc3ViY29udGFpbmVyID0gPEhUTUxEaXZFbGVtZW50PiQuSHRtbCh0aGlzLmNvbnRhaW5lciwgXCJkaXZcIiwgW10sIFtcImRldmVsb3AtdWlcIl0pO1xyXG4gICAgICAgIHN1YmNvbnRhaW5lci5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCg8SFRNTEVsZW1lbnQ+ZS50YXJnZXQpLmNsYXNzTGlzdC5jb250YWlucyhcImRyb3BidG5cIikpIHJldHVybjtcclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZHJvcGRvd24tY29udGVudFwiKSwgKGVsZW06IEhUTUxEaXZFbGVtZW50KSA9PiB7IGVsZW0uY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5idWlsZE1lbnUoc3ViY29udGFpbmVyKTtcclxuXHJcblxyXG4gICAgICAgIGxldCB3b3Jrc3BhY2UgPSA8SFRNTERpdkVsZW1lbnQ+JC5IdG1sKHN1YmNvbnRhaW5lciwgXCJkaXZcIiwgW1widGFiaW5kZXhcIiwgXCIwXCJdLCBbXCJkZXZlbG9wLXdvcmtzcGFjZVwiXSk7Ly90YWJpbmRleCwgZGFtaXQga2V5cHJlc3MtRXZlbnRzIGFiZ2VmYW5nZW4gd2VyZGVuIGvDtm5uZW5cclxuICAgICAgICB0aGlzLnByb3BlcnR5R3JpZEh0bWxEaXYgPSA8SFRNTERpdkVsZW1lbnQ+JC5IdG1sKHN1YmNvbnRhaW5lciwgXCJkaXZcIiwgW10sIFtcImRldmVsb3AtcHJvcGVydGllc1wiXSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5mbG93Y2hhcnRDb250YWluZXJTdmdTdmcgPSA8U1ZHU1ZHRWxlbWVudD4kLlN2Zyh3b3Jrc3BhY2UsIFwic3ZnXCIsIFtcIndpZHRoXCIsIFwiMTAwJVwiLCBcImhlaWdodFwiLCBcIjEwMCVcIl0sIFtcImZsb3djaGFydC1jb250YWluZXJcIl0pO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5saW5rc0xheWVyID0gPFNWR0dFbGVtZW50PiQuU3ZnKHRoaXMuZmxvd2NoYXJ0Q29udGFpbmVyU3ZnU3ZnLCBcImdcIiwgW10sIFtcImZsb3djaGFydC1saW5rcy1sYXllclwiXSk7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRvcnNMYXllciA9IDxTVkdHRWxlbWVudD4kLlN2Zyh0aGlzLmZsb3djaGFydENvbnRhaW5lclN2Z1N2ZywgXCJnXCIsIFtdLCBbXCJmbG93Y2hhcnQtb3BlcmF0b3JzLWxheWVyXCIsIFwidW5zZWxlY3RhYmxlXCJdKTtcclxuICAgICAgICB0aGlzLnRlbXBMYXllciA9IDxTVkdTVkdFbGVtZW50PiQuU3ZnKHRoaXMuZmxvd2NoYXJ0Q29udGFpbmVyU3ZnU3ZnLCBcImdcIiwgW10sIFtcImZsb3djaGFydC10ZW1wb3JhcnktbGluay1sYXllclwiXSk7XHJcbiAgICAgICAgdGhpcy50ZW1wTGF5ZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7Ly92aXNpYmxlXHJcbiAgICAgICAgbGV0IGRlZnMgPSAkLlN2Zyh0aGlzLnRlbXBMYXllciwgXCJkZWZzXCIsIFtdKTtcclxuICAgICAgICBsZXQgbWFya2VyQXJyb3cgPSAkLlN2ZyhkZWZzLCBcIm1hcmtlclwiLCBbXCJpZFwiLCBcIm1hcmtlci1hcnJvd1wiLCBcIm1hcmtlcldpZHRoXCIsIFwiNFwiLCBcIm1hcmtlckhlaWdodFwiLCBcIjRcIiwgXCJyZWZYXCIsIFwiMVwiLCBcInJlZllcIiwgXCIyXCIsIFwib3JpZW50XCIsIFwiMFwiXSk7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJBcnJvdyA9IDxTVkdQYXRoRWxlbWVudD4kLlN2ZyhtYXJrZXJBcnJvdywgXCJwYXRoXCIsIFtcImRcIiwgXCJNMCwwIEwwLDQgTDIsMiB6XCIsIFwiZmlsbFwiLCBcInJlZFwiLCBcInN0cm9rZVwiLCBcImJsYWNrXCIsIFwic3Ryb2tlLXdpZHRoXCIsIFwiMC41XCJdKTtcclxuICAgICAgICBsZXQgbWFya2VyQ2lyY2xlID0gJC5TdmcoZGVmcywgXCJtYXJrZXJcIiwgW1wiaWRcIiwgXCJtYXJrZXItY2lyY2xlXCIsIFwibWFya2VyV2lkdGhcIiwgXCI0XCIsIFwibWFya2VySGVpZ2h0XCIsIFwiNFwiLCBcInJlZlhcIiwgXCIyXCIsIFwicmVmWVwiLCBcIjJcIiwgXCJvcmllbnRcIiwgXCIwXCJdKTtcclxuICAgICAgICB0aGlzLm1hcmtlckNpcmNsZSA9IDxTVkdDaXJjbGVFbGVtZW50PiQuU3ZnKG1hcmtlckNpcmNsZSwgXCJjaXJjbGVcIiwgW1wiY3hcIiwgXCIyXCIsIFwiY3lcIiwgXCIyXCIsIFwiclwiLCBcIjJcIiwgXCJmaWxsXCIsIFwicmVkXCIsIFwic3Ryb2tlLXdpZHRoXCIsIFwiMXB4XCIsIFwic3Ryb2tlXCIsIFwiYmxhY2tcIl0pO1xyXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5TGluayA9IDxTVkdMaW5lRWxlbWVudD4kLlN2Zyh0aGlzLnRlbXBMYXllciwgXCJsaW5lXCIsIFtcIngxXCIsIFwiMFwiLCBcInkxXCIsIFwiMFwiLCBcIngyXCIsIFwiMFwiLCBcInkyXCIsIFwiMFwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCI2LDZcIiwgXCJzdHJva2Utd2lkdGhcIiwgXCI0XCIsIFwic3Ryb2tlXCIsIFwiYmxhY2tcIiwgXCJmaWxsXCIsIFwibm9uZVwiLCBcIm1hcmtlci1lbmRcIiwgXCJ1cmwoI21hcmtlci1hcnJvdylcIl0pO1xyXG5cclxuICAgICAgICBsZXQgb3BlcmF0b3JMaWJBY3RpdmF0b3IgPSA8U1ZHUmVjdEVsZW1lbnQ+JC5TdmcodGhpcy5mbG93Y2hhcnRDb250YWluZXJTdmdTdmcsIFwicmVjdFwiLCBbXCJ3aWR0aFwiLCBcIjQwXCIsIFwiaGVpZ2h0XCIsIFwiMTAwJVwiLCBcImZpbGxcIiwgXCJ3aGl0ZVwiLCBcImZpbGwtb3BhY2l0eVwiLCBcIjBcIl0pO1xyXG5cclxuICAgICAgICB0aGlzLm9wZXJhdG9yTGliRGl2ID0gPEhUTUxEaXZFbGVtZW50PiQuSHRtbCh3b3Jrc3BhY2UsIFwiZGl2XCIsIFtdLCBbXCJmbG93Y2hhcnQtb3BlcmF0b3JsaWJkaXZcIiwgXCJ1bnNlbGVjdGFibGVcIl0pO1xyXG4gICAgICAgIHRoaXMub3BlcmF0b3JMaWJEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cclxuXHJcbiAgICAgICAgLy9sZXQgdG9vbHNSZWN0PSA8U1ZHUmVjdEVsZW1lbnQ+JC5TdmcodGhpcy5vcGVyYXRvckxpYkRpdiwgXCJyZWN0XCIsIFtcIndpZHRoXCIsXCIxNDBcIiwgXCJoZWlnaHRcIiwgXCIxMDAlXCIsIFwicnhcIiwgXCIxMFwiLCBcInJ5XCIsIFwiMTBcIl0sIFtcInRvb2xzLWNvbnRhaW5lclwiXSk7XHJcblxyXG4gICAgICAgIC8vVGhlIG9ubW91c2Vtb3ZlIGV2ZW50IG9jY3VycyBldmVyeSB0aW1lIHRoZSBtb3VzZSBwb2ludGVyIGlzIG1vdmVkIG92ZXIgdGhlIGRpdiBlbGVtZW50LlxyXG4gICAgICAgIC8vVGhlIG1vdXNlZW50ZXIgZXZlbnQgb25seSBvY2N1cnMgd2hlbiB0aGUgbW91c2UgcG9pbnRlciBlbnRlcnMgdGhlIGRpdiBlbGVtZW50LlxyXG4gICAgICAgIC8vVGhlIG9ubW91c2VvdmVyIGV2ZW50IG9jY3VycyB3aGVuIHRoZSBtb3VzZSBwb2ludGVyIGVudGVycyB0aGUgZGl2IGVsZW1lbnQsIGFuZCBpdHMgY2hpbGQgZWxlbWVudHMgKHAgYW5kIHNwYW4pLlxyXG5cclxuICAgICAgICAvL1RoZSBtb3VzZW91dCBldmVudCB0cmlnZ2VycyB3aGVuIHRoZSBtb3VzZSBwb2ludGVyIGxlYXZlcyBhbnkgY2hpbGQgZWxlbWVudHMgYXMgd2VsbCB0aGUgc2VsZWN0ZWQgZWxlbWVudC5cclxuICAgICAgICAvL1RoZSBtb3VzZWxlYXZlIGV2ZW50IGlzIG9ubHkgdHJpZ2dlcmVkIHdoZW4gdGhlIG1vdXNlIHBvaW50ZXIgbGVhdmVzIHRoZSBzZWxlY3RlZCBlbGVtZW50LlxyXG4gICAgICAgIG9wZXJhdG9yTGliQWN0aXZhdG9yLm9ubW91c2VlbnRlciA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3JMaWJEaXYuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3BlcmF0b3JMaWJEaXYub25tb3VzZWxlYXZlID0gKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYXRvckxpYkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZsb3djaGFydENvbnRhaW5lclN2Z1N2Zy5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09IHRoaXMuRWxlbWVudCkvL2lmIHRoZSBjbGljayBpcyBpbiBhIFwiZnJlZVwiIGFyZWEsIHRoZW4gdGhlIHRhcmdldCBpcyB0aGUgdXBwZXJtb3N0IGxheWVyOyB0aGUgbGlua0xheWVyIVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0T3BlcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3RMaW5rKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdvcmtzcGFjZS5vbmtleXVwID0gKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUua2V5ID09IFwiRGVsZXRlXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmxvd2NoYXJ0IHdvcmtzcGFjZS5vbmtleXVwIHdpdGggZS50YXJnZXQ9XCIgKyBlLnRhcmdldCArIFwiIHVuZCBEZWxldGUtS2V5XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVTZWxlY3RlZFRoaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZsb3djaGFydCB3b3Jrc3BhY2Uub25rZXl1cCB3aXRoIGUudGFyZ2V0PVwiICsgZS50YXJnZXQgKyBcIiB1bmQga2V5IFwiICsgZS5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wZXJhdG9yUmVnaXN0cnkucG9wdWxhdGVPcGVyYXRvckxpYih0aGlzLm9wZXJhdG9yTGliRGl2LChlOk1vdXNlRXZlbnQsIHRpOlR5cGVJbmZvKT0+e1xyXG4gICAgICAgICAgICBsZXQgY2FwdGlvbiA9IHRpLk9wZXJhdG9yTmFtZTtcclxuICAgICAgICAgICAgbGV0IG8gPSB0aGlzLmNyZWF0ZU9wZXJhdG9ySW50ZXJuYWwodGkuR2xvYmFsVHlwZUluZGV4LCBjYXB0aW9uLCBudWxsKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IFV0aWxzLkV2ZW50Q29vcmRpbmF0ZXNJblNWRyhlLCB0aGlzLkVsZW1lbnQpO1xyXG4gICAgICAgICAgICBvLk1vdmVUbyhjb29yZHMueCAtIDEwLCBjb29yZHMueSAtIDEwKTtcclxuICAgICAgICAgICAgby5SZWdpc3RlckRyYWdnaW5nKGUpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9ycy5zZXQoby5HbG9iYWxPcGVyYXRvckluZGV4LCBvKTtcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkZpcnN0U3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy5kYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXREYXRhKHRoaXMub3B0aW9ucy5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlT3BlcmF0b3JJbnRlcm5hbChnbG9iYWxUeXBlSW5kZXg6IG51bWJlciwgY2FwdGlvbjogc3RyaW5nLCBjb25maWd1cmF0aW9uRGF0YTogS2V5VmFsdWVUdXBsZVtdIHwgbnVsbCk6IEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgICAgICBcclxuICAgICAgICBpZighdGhpcy5vcGVyYXRvclJlZ2lzdHJ5LklzSW5kZXhLbm93bihnbG9iYWxUeXBlSW5kZXgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGdsb2JhbFR5cGVJbmRleCAke2dsb2JhbFR5cGVJbmRleH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbk9wZXJhdG9yQ3JlYXRlICYmICF0aGlzLm9wdGlvbnMub25PcGVyYXRvckNyZWF0ZShjYXB0aW9uLCBudWxsLCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDcmVhdGlvbiBvZiBvcGVyYXRvciBvZiBnbG9iYWxUeXBlSW5kZXggJHtnbG9iYWxUeXBlSW5kZXh9IHByZXZlbnRlZCBieSBvbk9wZXJhdG9yQ3JlYXRlIHBsdWdpbmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgb3AgPSB0aGlzLm9wZXJhdG9yUmVnaXN0cnkuQ3JlYXRlQnlJbmRleChnbG9iYWxUeXBlSW5kZXgsIHRoaXMsIGNhcHRpb24sIGNvbmZpZ3VyYXRpb25EYXRhKSE7XHJcbiAgICAgICBcclxuICAgICAgICB0aGlzLmN1cnJlbnREZWJ1Z0luZm89bnVsbDtcclxuICAgICAgICByZXR1cm4gb3A7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldERhdGEoZGF0YTogRmxvd2NoYXJ0RGF0YSkge1xyXG5cclxuICAgICAgICB0aGlzLmxpbmtzLmZvckVhY2goKGUpID0+IGUuUmVtb3ZlRnJvbURPTSgpKTtcclxuICAgICAgICB0aGlzLmxpbmtzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRvcnMuZm9yRWFjaCgoZSkgPT4gZS5SZW1vdmVGcm9tRE9NKCkpO1xyXG4gICAgICAgIHRoaXMub3BlcmF0b3JzLmNsZWFyKCk7XHJcbiAgICAgICAgbGV0IGluZGV4SW5EYXRhMm9wZXJhdG9yID0gbmV3IE1hcDxudW1iZXIsIEZsb3djaGFydE9wZXJhdG9yPigpO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgZGF0YS5vcGVyYXRvcnMpIHtcclxuICAgICAgICAgICAgbGV0IG8gPSB0aGlzLmNyZWF0ZU9wZXJhdG9ySW50ZXJuYWwoZC5nbG9iYWxUeXBlSW5kZXgsIGQuY2FwdGlvbiwgZC5jb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgICAgIG8uTW92ZVRvKGQucG9zWCwgZC5wb3NZKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYXRvcnMuc2V0KG8uR2xvYmFsT3BlcmF0b3JJbmRleCwgbyk7XHJcbiAgICAgICAgICAgIGluZGV4SW5EYXRhMm9wZXJhdG9yLnNldChkLmluZGV4LCBvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIGRhdGEubGlua3MpIHtcclxuICAgICAgICAgICAgbGV0IGZyb21PcCA9IGluZGV4SW5EYXRhMm9wZXJhdG9yLmdldChkLmZyb21PcGVyYXRvckluZGV4KTtcclxuICAgICAgICAgICAgbGV0IHRvT3AgPSBpbmRleEluRGF0YTJvcGVyYXRvci5nZXQoZC50b09wZXJhdG9ySW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbU9wID09PSB1bmRlZmluZWQgfHwgdG9PcCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuICAgICAgICAgICAgbGV0IGZyb21Db25uID0gZnJvbU9wLkdldE91dHB1dENvbm5lY3RvckJ5SW5kZXgoZC5mcm9tT3V0cHV0KTtcclxuICAgICAgICAgICAgbGV0IHRvQ29ubiA9IHRvT3AuR2V0SW5wdXRDb25uZWN0b3JCeUluZGV4KGQudG9JbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQ29ubiA9PSBudWxsIHx8IHRvQ29ubiA9PSBudWxsKSBjb250aW51ZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVMaW5rKGQsIGZyb21Db25uLCB0b0Nvbm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgRGVsZXRlTGluayhnbG9iYWxMaW5rSW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERlYnVnSW5mbz1udWxsO1xyXG4gICAgICAgIGxldCBsID0gdGhpcy5saW5rcy5nZXQoZ2xvYmFsTGlua0luZGV4KTtcclxuICAgICAgICBpZiAobCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTGluayB0byBkZWxldGUgaXMgdW5kZWZpbmVkXCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTGluayA9PSBsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3RMaW5rKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGwuUmVtb3ZlRnJvbURPTSgpO1xyXG4gICAgICAgIHRoaXMubGlua3MuZGVsZXRlKGdsb2JhbExpbmtJbmRleCk7XHJcbiAgICAgICAgbC5Uby5SZW1vdmVMaW5rKGwpO1xyXG4gICAgICAgIGwuRnJvbS5SZW1vdmVMaW5rKGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBEZWxldGVPcGVyYXRvcihnbG9iYWxPcGVyYXRvckluZGV4OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREZWJ1Z0luZm89bnVsbDtcclxuICAgICAgICBsZXQgbyA9IHRoaXMub3BlcmF0b3JzLmdldChnbG9iYWxPcGVyYXRvckluZGV4KTtcclxuICAgICAgICBpZiAobyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiT3BlcmF0b3IgdG8gZGVsZXRlIGlzIHVuZGVmaW5lZFwiKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE9wZXJhdG9yID09IG8pIHtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdE9wZXJhdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG8uUmVtb3ZlRnJvbURPTSgpO1xyXG4gICAgICAgIHRoaXMub3BlcmF0b3JzLmRlbGV0ZShvLkdsb2JhbE9wZXJhdG9ySW5kZXgpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0S1Ygb2Ygby5PdXRwdXRzS1ZJdCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmtLViBvZiBvdXRwdXRLVlsxXS5MaW5rc0tWSXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuRGVsZXRlTGluayhsaW5rS1ZbMV0uR2xvYmFsTGlua0luZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGlucHV0S1Ygb2Ygby5JbnB1dHNLVkl0KSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlua0tWIG9mIGlucHV0S1ZbMV0uTGlua3NLVkl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkRlbGV0ZUxpbmsobGlua0tWWzFdLkdsb2JhbExpbmtJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUxpbmsoZGF0YTogTGlua0RhdGEgfCBudWxsLCBmcm9tOiBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IsIHRvOiBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcik6IEZsb3djaGFydExpbmsgfCBudWxsIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uTGlua0NyZWF0ZSAmJiAhdGhpcy5vcHRpb25zLm9uTGlua0NyZWF0ZShmcm9tLkNhcHRpb24sIGRhdGEpKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aXBsZUxpbmtzT25PdXRwdXQgJiYgZnJvbS5MaW5rc0xlbmd0aCA+IDApIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlTGlua3NPbklucHV0ICYmIHRvLkxpbmtzTGVuZ3RoID4gMCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGVidWdJbmZvPW51bGw7XHJcbiAgICAgICAgbGV0IGw6IEZsb3djaGFydExpbmsgPSBuZXcgRmxvd2NoYXJ0TGluayh0aGlzLCBcIlwiLCB0aGlzLk9wdGlvbnMuZGVmYXVsdExpbmtDb2xvciwgZnJvbSwgdG8pO1xyXG4gICAgICAgIGZyb20uQWRkTGluayhsKTtcclxuICAgICAgICB0by5BZGRMaW5rKGwpO1xyXG4gICAgICAgIHRoaXMubGlua3Muc2V0KGwuR2xvYmFsTGlua0luZGV4LCBsKTtcclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVuc2V0VGVtcG9yYXJ5TGluaygpIHtcclxuICAgICAgICB0aGlzLmxhc3RPdXRwdXRDb25uZWN0b3JDbGlja2VkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRlbXBMYXllci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldFRlbXBvcmFyeUxpbmsoYzogRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0T3V0cHV0Q29ubmVjdG9yQ2xpY2tlZCA9IGM7XHJcbiAgICAgICAgbGV0IGNvbG9yID0gRmxvd2NoYXJ0LkRBVEFUWVBFMkNPTE9SLmdldChjLlR5cGUpXHJcbiAgICAgICAgaWYgKCFjb2xvcikgY29sb3IgPSBcIkJMQUNLXCI7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJBcnJvdy5zdHlsZS5maWxsID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJDaXJjbGUuc3R5bGUuZmlsbCA9IGNvbG9yO1xyXG4gICAgICAgIHRoaXMudGVtcExheWVyLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVuc2VsZWN0T3BlcmF0b3IoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbk9wZXJhdG9yVW5zZWxlY3QgJiYgIXRoaXMub3B0aW9ucy5vbk9wZXJhdG9yVW5zZWxlY3QoKSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucHJvcGVydHlHcmlkSHRtbERpdi5pbm5lclRleHQgPSBcIlwiOyAvL2NsZWFyXHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRPcGVyYXRvciA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE9wZXJhdG9yLlNob3dBc1NlbGVjdGVkKGZhbHNlKTtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkT3BlcmF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBTZWxlY3RPcGVyYXRvcihvcGVyYXRvcjogRmxvd2NoYXJ0T3BlcmF0b3IpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uT3BlcmF0b3JTZWxlY3QgJiYgIXRoaXMub3B0aW9ucy5vbk9wZXJhdG9yU2VsZWN0KG9wZXJhdG9yLkNhcHRpb24pKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy51bnNlbGVjdExpbmsoKTtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE9wZXJhdG9yICE9IG51bGwpIHRoaXMuc2VsZWN0ZWRPcGVyYXRvci5TaG93QXNTZWxlY3RlZChmYWxzZSk7XHJcbiAgICAgICAgb3BlcmF0b3IuU2hvd0FzU2VsZWN0ZWQodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE9wZXJhdG9yID0gb3BlcmF0b3I7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUdyaWRIdG1sRGl2LmlubmVyVGV4dCA9IFwiXCI7IC8vY2xlYXJcclxuICAgICAgICAkLkh0bWwodGhpcy5wcm9wZXJ0eUdyaWRIdG1sRGl2LCBcInBcIiwgW10sIFtcImRldmVsb3AtcHJvcGVydHlncmlkLWhlYWRcIl0sIGBQcm9wZXJ0aWVzIGZvciAke3RoaXMuc2VsZWN0ZWRPcGVyYXRvci5DYXB0aW9ufWApO1xyXG4gICAgICAgIGxldCB0YWJsZSA9IDxIVE1MVGFibGVFbGVtZW50PiQuSHRtbCh0aGlzLnByb3BlcnR5R3JpZEh0bWxEaXYsIFwidGFibGVcIiwgW10sIFtcImRldmVsb3AtcHJvcGVydHlncmlkLXRhYmxlXCJdKTtcclxuICAgICAgICBsZXQgdGhlYWQgPSA8SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ+JC5IdG1sKHRhYmxlLCBcInRoZWFkXCIsIFtdLFtdKTtcclxuICAgICAgICBsZXQgdHJfaGVhZCA9ICQuSHRtbCh0aGVhZCwgXCJ0clwiLCBbXSwgW1wiZGV2ZWxvcC1wcm9wZXJ0eWdyaWQtdHJcIl0pO1xyXG4gICAgICAgICQuSHRtbCh0cl9oZWFkLCBcInRoXCIsIFtdLCBbXCJkZXZlbG9wLXByb3BlcnR5Z3JpZC10aFwiXSwgXCJLZXlcIik7XHJcbiAgICAgICAgJC5IdG1sKHRyX2hlYWQsIFwidGhcIiwgW10sIFtcImRldmVsb3AtcHJvcGVydHlncmlkLXRoXCJdLCBcIlZhbHVlXCIpO1xyXG4gICAgICAgIGxldCB0Ym9keT0gPEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50PiQuSHRtbCh0YWJsZSwgXCJ0Ym9keVwiLCBbXSxbXSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRPcGVyYXRvciEuUG9wdWxhdGVQcm9wZXJ5R3JpZCh0Ym9keSkpIHtcclxuICAgICAgICAgICAgJC5IdG1sKHRoaXMucHJvcGVydHlHcmlkSHRtbERpdiwgXCJidXR0b25cIiwgW10sIFtcImRldmVsb3AtcHJvcGVydHlncmlkLWJ1dHRvblwiXSwgYFNhdmVgKS5vbmNsaWNrPShlKT0+e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RGVidWdJbmZvPW51bGw7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvci5TYXZlUHJvcGVydHlHcmlkKHRib2R5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlHcmlkSHRtbERpdi5pbm5lclRleHQgPSBcIlwiOyAvL2NsZWFyXHJcbiAgICAgICAgICAgICQuSHRtbCh0aGlzLnByb3BlcnR5R3JpZEh0bWxEaXYsIFwicFwiLCBbXSwgW1wiZGV2ZWxvcC1wcm9wZXJ0eWdyaWQtaGVhZFwiXSwgYE5vIFByb3BlcnRpZXMgZm9yICR7dGhpcy5zZWxlY3RlZE9wZXJhdG9yLkNhcHRpb259YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZvdW5kIGhlcmUgOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1NjAyNDgvcHJvZ3JhbW1hdGljYWxseS1saWdodGVuLW9yLWRhcmtlbi1hLWhleC1jb2xvci1vci1yZ2ItYW5kLWJsZW5kLWNvbG9yc1xyXG4gICAgcHVibGljIHN0YXRpYyBfc2hhZGVDb2xvcihjb2xvcjogc3RyaW5nLCBwZXJjZW50OiBudW1iZXIpIHtcclxuICAgICAgICB2YXIgZiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNiksIHQgPSBwZXJjZW50IDwgMCA/IDAgOiAyNTUsIHAgPSBwZXJjZW50IDwgMCA/IHBlcmNlbnQgKiAtMSA6IHBlcmNlbnQsIFIgPSBmID4+IDE2LCBHID0gZiA+PiA4ICYgMHgwMEZGLCBCID0gZiAmIDB4MDAwMEZGO1xyXG4gICAgICAgIHJldHVybiBcIiNcIiArICgweDEwMDAwMDAgKyAoTWF0aC5yb3VuZCgodCAtIFIpICogcCkgKyBSKSAqIDB4MTAwMDAgKyAoTWF0aC5yb3VuZCgodCAtIEcpICogcCkgKyBHKSAqIDB4MTAwICsgKE1hdGgucm91bmQoKHQgLSBCKSAqIHApICsgQikpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge0Zsb3djaGFydE9wZXJhdG9yLCBQb3NpdGlvblR5cGUgfSBmcm9tIFwiLi9GbG93Y2hhcnRPcGVyYXRvclwiO1xyXG5pbXBvcnQge0Nvbm5lY3RvclR5cGUgfSBmcm9tIFwiLi9GbG93Y2hhcnRDb25uZWN0b3JcIjtcclxuaW1wb3J0IHsgTm9kZVdyYXBwZXIsIFRvcG9sb2dpY2FsU29ydERGUyB9IGZyb20gXCIuL1RvcG9sb2dpY2FsU29yZkRGU1wiO1xyXG5pbXBvcnQgeyBTZXJpYWxpemVDb250ZXh0IH0gZnJvbSBcIi4vU2VyaWFsaXplQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBGbG93Y2hhcnRMaW5rIH0gZnJvbSBcIi4vRmxvd2NoYXJ0TGlua1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemVDb250ZXh0QW5kQWRyZXNzTWFwIHtcclxuICAgIHR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQ6IE1hcDxudW1iZXIsIE1hcDxudW1iZXIsIG51bWJlcj4+O1xyXG4gICAgY3R4OiBTZXJpYWxpemVDb250ZXh0O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hBbmRCdWZBbmRNYXBze1xyXG4gICAgaGFzaDpudW1iZXI7XHJcbiAgICBidWY6IEFycmF5QnVmZmVyO1xyXG4gICAgdHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldDpNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBudW1iZXI+PixcclxuICAgIHR5cGVJbmRleDJhZHJlc3NPZmZzZXQyTGlzdE9mTGlua3M6TWFwPG51bWJlciwgTWFwPG51bWJlciwgQXJyYXk8Rmxvd2NoYXJ0TGluaz4+PixcclxuICAgIHR5cGVJbmRleDJtYXhPZmZzZXQ6TWFwPG51bWJlciwgbnVtYmVyPixcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBIYXNoQW5kQnVme1xyXG4gICAgaGFzaDpudW1iZXI7XHJcbiAgICBidWY6IEFycmF5QnVmZmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNvcnRlZE9wZXJhdG9yc0FuZE1hcHN7XHJcbiAgICBzb3J0ZWRPcGVyYXRvcnM6Rmxvd2NoYXJ0T3BlcmF0b3JbXTtcclxuICAgIHR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQ6TWFwPG51bWJlciwgTWFwPG51bWJlciwgbnVtYmVyPj4sXHJcbiAgICB0eXBlSW5kZXgyYWRyZXNzT2Zmc2V0Mkxpc3RPZkxpbmtzOk1hcDxudW1iZXIsIE1hcDxudW1iZXIsIEFycmF5PEZsb3djaGFydExpbms+Pj4sXHJcbiAgICB0eXBlSW5kZXgybWF4T2Zmc2V0Ok1hcDxudW1iZXIsIG51bWJlcj4sXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwc3tcclxuICAgIHR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQ6TWFwPG51bWJlciwgTWFwPG51bWJlciwgbnVtYmVyPj4sXHJcbiAgICB0eXBlSW5kZXgyYWRyZXNzT2Zmc2V0Mkxpc3RPZkxpbmtzOk1hcDxudW1iZXIsIE1hcDxudW1iZXIsIEFycmF5PEZsb3djaGFydExpbms+Pj4sXHJcbiAgICB0eXBlSW5kZXgybWF4T2Zmc2V0Ok1hcDxudW1iZXIsIG51bWJlcj4sXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBGbG93Y2hhcnRDb21waWxlciB7XHJcbiAgICBcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIGluZGV4Mm9wZXJhdG9yOk1hcDxudW1iZXIsRmxvd2NoYXJ0T3BlcmF0b3I+KVxyXG4gICAge1xyXG4gICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzb3J0T3BlcmF0b3JzKCk6Rmxvd2NoYXJ0T3BlcmF0b3JbXXtcclxuICAgICAgICBsZXQgaW5kZXgyd3JhcHBlZE9wZXJhdG9yID0gbmV3IE1hcDxudW1iZXIsIE5vZGVXcmFwcGVyPEZsb3djaGFydE9wZXJhdG9yPj4oKTtcclxuICAgICAgICB0aGlzLmluZGV4Mm9wZXJhdG9yLmZvckVhY2goKHYsIGssIG0pID0+IHtcclxuICAgICAgICAgICAgaW5kZXgyd3JhcHBlZE9wZXJhdG9yLnNldCh2Lkdsb2JhbE9wZXJhdG9ySW5kZXgsIG5ldyBOb2RlV3JhcHBlcjxGbG93Y2hhcnRPcGVyYXRvcj4odikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCB3cmFwcGVkT3V0cHV0T3BlcmF0b3JzOiBOb2RlV3JhcHBlcjxGbG93Y2hhcnRPcGVyYXRvcj5bXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgb2YgaW5kZXgyd3JhcHBlZE9wZXJhdG9yLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIC8vU3RlbGxlIGbDvHIgamVkZSBcImdld3JhcHRlIE5vZGVcIiBmZXN0LCB3ZWxjaGUgT3BlcmF0b3JlbiB2b24gSWhyIGFiaMOkbmdpZyBzaW5kXHJcbiAgICAgICAgICAgIGxldCBkZXBlbmRlbnRzID0gbmV3IFNldDxOb2RlV3JhcHBlcjxGbG93Y2hhcnRPcGVyYXRvcj4+KCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5wdXRrdiBvZiBpLlBheWxvYWQuSW5wdXRzS1ZJdCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5ra3Ygb2YgaW5wdXRrdlsxXS5MaW5rc0tWSXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVwZW5kZW50T3BlcmF0b3IgPSBsaW5ra3ZbMV0uRnJvbS5QYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlcGVuZGVudFdyYXBwZWROb2RlID0gaW5kZXgyd3JhcHBlZE9wZXJhdG9yLmdldChkZXBlbmRlbnRPcGVyYXRvci5HbG9iYWxPcGVyYXRvckluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlcGVuZGVudFdyYXBwZWROb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbXBsZW1lbnRhdGlvbiBFcnJvcjogZGVwZW5kZW50V3JhcHBlZE5vZGUgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVudHMuYWRkKGRlcGVuZGVudFdyYXBwZWROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXBlbmRlbnRzLmZvckVhY2goZSA9PiBpLkRlcGVuZGVuZE5vZGVzLnB1c2goZSkpO1xyXG4gICAgICAgICAgICAvL2bDvGdlIGFsbGUgbWl0IFR5cCBcIk91dHB1dFwiIGVpbmVyIExpc3RlIGhpbnp1XHJcbiAgICAgICAgICAgIGlmIChpLlBheWxvYWQuVHlwZUluZm8uUG9zaXRpb24gPT0gUG9zaXRpb25UeXBlLk91dHB1dCkgd3JhcHBlZE91dHB1dE9wZXJhdG9ycy5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGFsZ29yaXRobSA9IG5ldyBUb3BvbG9naWNhbFNvcnRERlM8Rmxvd2NoYXJ0T3BlcmF0b3I+KCk7XHJcbiAgICAgICAgbGV0IHNvcnRlZExpc3QgPSBhbGdvcml0aG0uc29ydCh3cmFwcGVkT3V0cHV0T3BlcmF0b3JzKTtcclxuICAgICAgICByZXR1cm4gc29ydGVkTGlzdC5tYXAoKGUpID0+IGUuUGF5bG9hZClcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgQ29tcGlsZUZvclNpbXVsYXRpb24oKTpTb3J0ZWRPcGVyYXRvcnNBbmRNYXBze1xyXG4gICAgICAgIGxldCBzb3J0ZWRPcGVyYXRvcnMgPSB0aGlzLnNvcnRPcGVyYXRvcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3J0ZWRPcGVyYXRvcnMpIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gc29ydGVkT3BlcmF0b3JzW2tleV07XHJcbiAgICAgICAgICAgIHZhbHVlLlNldERlYnVnSW5mb1RleHQoXCJTZXF1ZW5jZSBcIiArIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtYXBzPXRoaXMuY3JlYXRlTG9va3VwTWFwcyhzb3J0ZWRPcGVyYXRvcnMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNvcnRlZE9wZXJhdG9yczpzb3J0ZWRPcGVyYXRvcnMsXHJcbiAgICAgICAgICAgIHR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQ6bWFwcy50eXBlSW5kZXgyZ2xvYmFsQ29ubmVjdG9ySW5kZXgyYWRyZXNzT2Zmc2V0LFxyXG4gICAgICAgICAgICB0eXBlSW5kZXgyYWRyZXNzT2Zmc2V0Mkxpc3RPZkxpbmtzOm1hcHMudHlwZUluZGV4MmFkcmVzc09mZnNldDJMaXN0T2ZMaW5rcyxcclxuICAgICAgICAgICAgdHlwZUluZGV4Mm1heE9mZnNldDptYXBzLnR5cGVJbmRleDJtYXhPZmZzZXQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgQ29tcGlsZSgpOiBIYXNoQW5kQnVmQW5kTWFwcyB7XHJcbiAgICAgICAgbGV0IHNvcnRlZE9wZXJhdG9ycyA9IHRoaXMuc29ydE9wZXJhdG9ycygpO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvcnRlZE9wZXJhdG9ycykge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBzb3J0ZWRPcGVyYXRvcnNba2V5XTtcclxuICAgICAgICAgICAgdmFsdWUuU2V0RGVidWdJbmZvVGV4dChcIlNlcXVlbmNlIFwiICsga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1hcHM9dGhpcy5jcmVhdGVMb29rdXBNYXBzKHNvcnRlZE9wZXJhdG9ycyk7XHJcbiAgICAgICAgbGV0IGhhc2hBbmRCdWY9IHRoaXMuc2VyaWFsaXplKHNvcnRlZE9wZXJhdG9ycywgbWFwcyk7XHJcblxyXG4gICAgICAgIGxldCBkdiA9IG5ldyBEYXRhVmlldyhoYXNoQW5kQnVmLmJ1Zik7XHJcbiAgICAgICAgbGV0IGNvZGU6IFN0cmluZyA9IFwiY29uc3QgdWludDhfdCBjb2RlW10gPSB7XCJcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR2LmJ5dGVMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb2RlICs9IFwiMHhcIiArIGR2LmdldFVpbnQ4KGkpLnRvU3RyaW5nKDE2KSArIFwiLCBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29kZSArPSBcIn07XCI7XHJcbiAgICAgICAgY29uc29sZS5sb2coY29kZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhhc2g6aGFzaEFuZEJ1Zi5oYXNoLFxyXG4gICAgICAgICAgICBidWY6IGhhc2hBbmRCdWYuYnVmLFxyXG4gICAgICAgICAgICB0eXBlSW5kZXgyZ2xvYmFsQ29ubmVjdG9ySW5kZXgyYWRyZXNzT2Zmc2V0Om1hcHMudHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldCxcclxuICAgICAgICAgICAgdHlwZUluZGV4MmFkcmVzc09mZnNldDJMaXN0T2ZMaW5rczptYXBzLnR5cGVJbmRleDJhZHJlc3NPZmZzZXQyTGlzdE9mTGlua3MsXHJcbiAgICAgICAgICAgIHR5cGVJbmRleDJtYXhPZmZzZXQ6bWFwcy50eXBlSW5kZXgybWF4T2Zmc2V0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVMb29rdXBNYXBzKG9wZXJhdG9yczpGbG93Y2hhcnRPcGVyYXRvcltdKTpNYXBze1xyXG4gICAgICAgIC8vU3BlaWNoZXJ0IHNlcGFyYXQgZsO8ciBqZWRlbiBEYXRlbnR5cCAoQm9vbCwgaW50LCBmbG9hdCwgY29sb3IsLi4uKSwgd2VsY2hlciBHbG9iYWxDb25uZWN0b3JJbmRleCBhdWYgd2VsY2hlbiBiZWkgMiBiZWdpbm5lbmQgZm9ydGxhdWZlbmRlbiBBZHJlc3MtT2Zmc2V0IGdlbWFwcGVkIHdpcmRcclxuICAgICAgICAvL3dpciBiZWdpbm5lbiBiZWkgMiwgd2VpbCB1bmJlc2NoYWx0ZXRlIE91dHB1dHMgYXVmIDAgc2NocmVpYmVuIHVuZCB1bmJlc2NoYWx0ZXRlIElucHV0cyB2b24gMSBsZXNlbi5cclxuICAgICAgICBsZXQgdHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldCA9IG5ldyBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBudW1iZXI+PigpOyAvL2dsb2JhbENvbm5lY3RvckluZGV4X091dHB1dHMgMiB2YXJpYWJsZUFkcmVzc1xyXG4gICAgICAgIGxldCB0eXBlSW5kZXgybWF4T2Zmc2V0ID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKTtcclxuICAgICAgICBsZXQgdHlwZUluZGV4MmFkcmVzc09mZnNldDJMaXN0T2ZMaW5rcyA9IG5ldyBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBBcnJheTxGbG93Y2hhcnRMaW5rPj4+KCk7XHJcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBDb25uZWN0b3JUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOYU4oTnVtYmVyKHR5cGUpKSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldC5zZXQoTnVtYmVyKHR5cGUpLCBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpKTtcclxuICAgICAgICAgICAgICAgIHR5cGVJbmRleDJtYXhPZmZzZXQuc2V0KE51bWJlcih0eXBlKSwgMik7XHJcbiAgICAgICAgICAgICAgICB0eXBlSW5kZXgyYWRyZXNzT2Zmc2V0Mkxpc3RPZkxpbmtzLnNldChOdW1iZXIodHlwZSksIG5ldyBNYXA8bnVtYmVyLEFycmF5PEZsb3djaGFydExpbms+PigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IG9wZXJhdG9yIG9mIG9wZXJhdG9ycykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dEtWIG9mIG9wZXJhdG9yLk91dHB1dHNLVkl0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0S1ZbMV0uTGlua3NMZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdW5jb25uZWN0ZWQgb3V0cHV0IC0tPndyaXRlcyB0byBtZW1vcnkgYWRyZXNzIHplcm8gb2YgdGhlIHJlc3BlY3RpdmUgZGF0YSB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldC5nZXQob3V0cHV0S1ZbMV0uVHlwZSkhLnNldChvdXRwdXRLVlsxXS5HbG9iYWxDb25uZWN0b3JJbmRleCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2Nvbm5lY3RlZCBvdXRwdXQgLS0+IGNyZWF0ZSBuZXcgbWVtb3J5IGFkZHJlc3MgYW5kIHNldCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHR5cGVJbmRleDJtYXhPZmZzZXQuZ2V0KG91dHB1dEtWWzFdLlR5cGUpITtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSW5kZXgyZ2xvYmFsQ29ubmVjdG9ySW5kZXgyYWRyZXNzT2Zmc2V0LmdldChvdXRwdXRLVlsxXS5UeXBlKSEuc2V0KG91dHB1dEtWWzFdLkdsb2JhbENvbm5lY3RvckluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgYWxsIG91dGdvaW5nIGxpbmtzIHRvIHR5cGVJbmRleDJhZHJlc3NPZmZzZXQyTGlzdE9mTGlua3NcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSW5kZXgyYWRyZXNzT2Zmc2V0Mkxpc3RPZkxpbmtzLmdldChvdXRwdXRLVlsxXS5UeXBlKSEuc2V0KGluZGV4LCBvdXRwdXRLVlsxXS5HZXRMaW5rc0NvcHkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSW5kZXgybWF4T2Zmc2V0LnNldChvdXRwdXRLVlsxXS5UeXBlLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldDp0eXBlSW5kZXgyZ2xvYmFsQ29ubmVjdG9ySW5kZXgyYWRyZXNzT2Zmc2V0LFxyXG4gICAgICAgICAgICB0eXBlSW5kZXgyYWRyZXNzT2Zmc2V0Mkxpc3RPZkxpbmtzOnR5cGVJbmRleDJhZHJlc3NPZmZzZXQyTGlzdE9mTGlua3MsXHJcbiAgICAgICAgICAgIHR5cGVJbmRleDJtYXhPZmZzZXQ6dHlwZUluZGV4Mm1heE9mZnNldCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIHNlcmlhbGl6ZShvcGVyYXRvcnM6IEZsb3djaGFydE9wZXJhdG9yW10sIG1hcHM6TWFwcyk6SGFzaEFuZEJ1ZiB7XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIExlZ2UgbnVuIGRpZSBPcGVyYXRvcmVuIGluIGRlciBkdXJjaCBkYXMgQXJyYXkgdm9yZ2VnZWJlbmVuIFN0cnVrdHVyIGluIGVpbiBBcnJheSBhYlxyXG4gICAgICAgICovXHJcbiAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihNYXRoLnBvdygyLCAxNikpO1xyXG4gICAgICAgIGxldCBzZXJjdHggPSBuZXcgU2VyaWFsaXplQ29udGV4dChidWZmZXIsIDApO1xyXG4gICAgICAgIGxldCBjdHg6IFNlcmlhbGl6ZUNvbnRleHRBbmRBZHJlc3NNYXAgPSB7IFxyXG4gICAgICAgICAgICB0eXBlSW5kZXgyZ2xvYmFsQ29ubmVjdG9ySW5kZXgyYWRyZXNzT2Zmc2V0OiBtYXBzLnR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQsIFxyXG4gICAgICAgICAgICBjdHg6c2VyY3R4XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL1ZlcnNpb24gb2YgRGF0YSBTdHJ1Y3R1cmVcclxuICAgICAgICBzZXJjdHgud3JpdGVVMzIoMHhBRkZFQ0FGRSk7XHJcbiAgICAgICAgLy9QbGFjZWhvbGRlciBmb3IgaGFzaFxyXG4gICAgICAgIHNlcmN0eC53cml0ZVUzMigwKTtcclxuXHJcblxyXG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gQ29ubmVjdG9yVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcih0eXBlKSkpIHtcclxuICAgICAgICAgICAgICAgIHNlcmN0eC53cml0ZVUzMihtYXBzLnR5cGVJbmRleDJtYXhPZmZzZXQuZ2V0KE51bWJlcih0eXBlKSkhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vb3BlcmF0b3JzQ291bnRcclxuICAgICAgICBzZXJjdHgud3JpdGVVMzIob3BlcmF0b3JzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBvcGVyYXRvciBvZiBvcGVyYXRvcnMpIHtcclxuICAgICAgICAgICAgb3BlcmF0b3IuU2VyaWFsaXplVG9CaW5hcnkoY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBoYXNoPSBzZXJjdHguZnVuaGFzaCg4LCAoMl4zMiktMSk7XHJcbiAgICAgICAgc2VyY3R4Lm92ZXJ3cml0ZVUzMihoYXNoLCA0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGFzaDpoYXNoLCBcclxuICAgICAgICAgICAgYnVmOmN0eC5jdHguZ2V0UmVzdWx0KCksIFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBGbG93Y2hhcnRPcGVyYXRvciB9IGZyb20gXCIuL0Zsb3djaGFydE9wZXJhdG9yXCI7XHJcbmltcG9ydCB7IEZsb3djaGFydCB9IGZyb20gXCIuL0Zsb3djaGFydFwiO1xyXG5pbXBvcnQgeyBGbG93Y2hhcnRMaW5rIH0gZnJvbSBcIi4vRmxvd2NoYXJ0TGlua1wiO1xyXG5pbXBvcnQgeyQsIExvY2F0aW9uMkR9IGZyb20gXCIuLi91dGlsc1wiXHJcblxyXG5jb25zdCBUUkFOU0xBVEVZID0gMjA7XHJcblxyXG5leHBvcnQgZW51bSBDb25uZWN0b3JUeXBle1xyXG4gICAgQk9PTEVBTj0wLFxyXG4gICAgSU5URUdFUj0xLFxyXG4gICAgRkxPQVQ9MixcclxuICAgIENPTE9SPTMsXHJcbn1cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGbG93Y2hhcnRDb25uZWN0b3Ige1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgSU5ERVg6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIGdsb2JhbENvbm5lY3RvckluZGV4OiBudW1iZXI7XHJcbiAgICBnZXQgR2xvYmFsQ29ubmVjdG9ySW5kZXgoKSB7IHJldHVybiB0aGlzLmdsb2JhbENvbm5lY3RvckluZGV4OyB9XHJcbiAgICBnZXQgTG9jYWxDb25uZWN0b3JJbmRleCgpe3JldHVybiB0aGlzLmxvY2FsSW5kZXg7fVxyXG5cclxuICAgIHByb3RlY3RlZCBlbGVtZW50OiBTVkdHRWxlbWVudDtcclxuICAgIGdldCBFbGVtZW50KCkgeyByZXR1cm4gdGhpcy5lbGVtZW50OyB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHNuYXBwZXI6U1ZHQ2lyY2xlRWxlbWVudDtcclxuICAgIHByb3RlY3RlZCBjb25uZWN0b3I6U1ZHRWxlbWVudDtcclxuICAgIHByb3RlY3RlZCBjb25uZWN0b3JHcm91cDpTVkdHRWxlbWVudDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgIGxpbmtzID0gbmV3IE1hcDxudW1iZXIsIEZsb3djaGFydExpbms+KCk7XHJcbiAgICBwdWJsaWMgSGFzTGluayA9IChnbG9iYWxMaW5rSW5kZXg6IG51bWJlcikgPT4gdGhpcy5saW5rcy5oYXMoZ2xvYmFsTGlua0luZGV4KTtcclxuICAgIHB1YmxpYyBBZGRMaW5rID0gKGxpbms6IEZsb3djaGFydExpbmspID0+IHRoaXMubGlua3Muc2V0KGxpbmsuR2xvYmFsTGlua0luZGV4LCBsaW5rKTtcclxuICAgIHB1YmxpYyBSZW1vdmVMaW5rID0gKGxpbms6IEZsb3djaGFydExpbmspID0+IHRoaXMubGlua3MuZGVsZXRlKGxpbmsuR2xvYmFsTGlua0luZGV4KTtcclxuICAgIGdldCBMaW5rc0xlbmd0aCgpIHsgcmV0dXJuIHRoaXMubGlua3Muc2l6ZX07XHJcbiAgICBwdWJsaWMgR2V0TGlua3NDb3B5KCk6IEZsb3djaGFydExpbmtbXSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5saW5rcy52YWx1ZXMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IExpbmtzS1ZJdCgpe3JldHVybiB0aGlzLmxpbmtzLmVudHJpZXMoKX1cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBHZXRMaW5rcG9pbnRYT2Zmc2V0KHdpZHRoOm51bWJlcik6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBnZXRJT1NwZWNpZmljcygpOntpbnB1dE9yT3V0cHV0OnN0cmluZywgcGFyZW50OlNWR0dFbGVtZW50LCB0cmFuc2xhdGVZOm51bWJlciwgZHg6bnVtYmVyfTtcclxuXHJcbiAgICBwdWJsaWMgUmVmcmVzaExpbmtQb3NpdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5saW5rcy5mb3JFYWNoKGw9PntcclxuICAgICAgICAgICAgbC5SZWZyZXNoUG9zaXRpb24oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBhcmVudDogRmxvd2NoYXJ0T3BlcmF0b3IsIHByaXZhdGUgY2FwdGlvbjogc3RyaW5nLCBwcml2YXRlIGxvY2FsSW5kZXg6bnVtYmVyLCBwcml2YXRlIHR5cGU6Q29ubmVjdG9yVHlwZSkge1xyXG5cclxuICAgICAgICB0aGlzLmdsb2JhbENvbm5lY3RvckluZGV4ID0gRmxvd2NoYXJ0Q29ubmVjdG9yLklOREVYKys7XHJcbiAgICAgICAgbGV0IHNwZWMgPSB0aGlzLmdldElPU3BlY2lmaWNzKCk7XHJcbiAgICAgICAgbGV0IHRyYW5zbGF0ZVkgPSBUUkFOU0xBVEVZKnNwZWMucGFyZW50LmNoaWxkRWxlbWVudENvdW50O1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IDxTVkdHRWxlbWVudD4kLlN2ZyhzcGVjLnBhcmVudCwgXCJnXCIsIFtcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKDAgJHt0cmFuc2xhdGVZfSlgXSwgW2BvcGVyYXRvci0ke3NwZWMuaW5wdXRPck91dHB1dH1gXSk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtY29ubmVjdG9yLWRhdGF0eXBlXCIsIENvbm5lY3RvclR5cGVbdHlwZV0pO1xyXG5cclxuICAgICAgICBsZXQgdGV4dCA9ICA8U1ZHVGV4dEVsZW1lbnQ+JC5TdmcodGhpcy5lbGVtZW50LCBcInRleHRcIiwgW1wiZHhcIixcIlwiK3NwZWMuZHgsIFwiZHlcIiwgXCI0XCJdLCBbYG9wZXJhdG9yLSR7c3BlYy5pbnB1dE9yT3V0cHV0fS1jYXB0aW9uYF0pO1xyXG4gICAgICAgIHRleHQudGV4dENvbnRlbnQ9Y2FwdGlvbjtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rvckdyb3VwID0gPFNWR0dFbGVtZW50PiQuU3ZnKHRoaXMuZWxlbWVudCwgXCJnXCIsIFtdKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IDxTVkdDaXJjbGVFbGVtZW50PiQuU3ZnKHRoaXMuY29ubmVjdG9yR3JvdXAsIFwiY2lyY2xlXCIsIFtcInJcIixcIjRcIl0sIFtgb3BlcmF0b3ItJHtzcGVjLmlucHV0T3JPdXRwdXR9LWNvbm5lY3RvcmAsIENvbm5lY3RvclR5cGVbdHlwZV1dKTtcclxuICAgICAgICB0aGlzLnNuYXBwZXI9IDxTVkdDaXJjbGVFbGVtZW50PiQuU3ZnKHRoaXMuY29ubmVjdG9yR3JvdXAsIFwiY2lyY2xlXCIsIFtcInJcIixcIjEwXCJdLCBbYG9wZXJhdG9yLSR7c3BlYy5pbnB1dE9yT3V0cHV0fS1zbmFwcGVyYF0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuZWxlbWVudC5vbm1vdXNlb3ZlciA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiB0aGlzLmxpbmtzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluayAmJiBsaW5rICE9IHRoaXMucGFyZW50LlBhcmVudC5TZWxlY3RlZExpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rLlNldENvbG9yKEZsb3djaGFydC5fc2hhZGVDb2xvcih0aGlzLnBhcmVudC5QYXJlbnQuT3B0aW9ucy5kZWZhdWx0TGlua0NvbG9yLCAtMC40KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudC5vbm1vdXNlb3V0ID0gKGUpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5rIG9mIHRoaXMubGlua3MudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5rICYmIGxpbmsgIT0gdGhpcy5wYXJlbnQuUGFyZW50LlNlbGVjdGVkTGluaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmsuVW5zZXRDb2xvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IFBhcmVudCgpIHsgcmV0dXJuIHRoaXMucGFyZW50OyB9XHJcbiAgICBnZXQgQ2FwdGlvbigpIHsgcmV0dXJuIHRoaXMuY2FwdGlvbjsgfVxyXG4gICAgZ2V0IFR5cGUoKSB7IHJldHVybiB0aGlzLnR5cGU7IH1cclxuXHJcblxyXG4gICAgcHVibGljIEdldExpbmtwb2ludCgpOiBMb2NhdGlvbjJEIHtcclxuICAgICAgICBsZXQgZmxvd2NoYXJ0ID0gdGhpcy5QYXJlbnQuUGFyZW50O1xyXG4gICAgICAgIGxldCBwb3NyYXQgPSBmbG93Y2hhcnQuUG9zaXRpb25SYXRpbztcclxuICAgICAgICBsZXQgZmxvd2NoYXJ0UmVjdCA9IGZsb3djaGFydC5FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxldCBjb25uZWN0b3JSZWN0ID0gdGhpcy5jb25uZWN0b3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdmFyIHggPSAoY29ubmVjdG9yUmVjdC5sZWZ0IC0gZmxvd2NoYXJ0UmVjdC5sZWZ0KSAvIHBvc3JhdCArIGNvbm5lY3RvclJlY3Qud2lkdGgvMjtcclxuICAgICAgICB2YXIgeSA9IChjb25uZWN0b3JSZWN0LnRvcCAtIGZsb3djaGFydFJlY3QudG9wKSAvIHBvc3JhdCArIGNvbm5lY3RvclJlY3QuaGVpZ2h0LzI7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IgZXh0ZW5kcyBGbG93Y2hhcnRDb25uZWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3IgKHBhcmVudDogRmxvd2NoYXJ0T3BlcmF0b3IsIGNhcHRpb246IHN0cmluZywgbG9jYWxJbmRleDpudW1iZXIsIHR5cGU6Q29ubmVjdG9yVHlwZSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgbG9jYWxJbmRleCwgdHlwZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JHcm91cC5vbm1vdXNldXAgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgIHBhcmVudC5QYXJlbnQuX25vdGlmeUlucHV0Q29ubmVjdG9yTW91c2V1cCh0aGlzLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JHcm91cC5vbm1vdXNlZW50ZXI9KGUpPT5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBhcmVudC5QYXJlbnQuX25vdGlmeUlucHV0Q29ubmVjdG9yTW91c2VlbnRlcih0aGlzLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JHcm91cC5vbm1vdXNlbGVhdmU9KGUpPT5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBhcmVudC5QYXJlbnQuX25vdGlmeUlucHV0Q29ubmVjdG9yTW91c2VsZWF2ZSh0aGlzLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgR2V0TGlua3BvaW50WE9mZnNldCh3aWR0aDpudW1iZXIpOiBudW1iZXJ7cmV0dXJuIDA7fSAgXHJcbiAgICBwcm90ZWN0ZWQgIGdldElPU3BlY2lmaWNzKCl7cmV0dXJuIHtpbnB1dE9yT3V0cHV0OlwiaW5wdXRcIiwgcGFyZW50OnRoaXMuUGFyZW50LklucHV0U3ZnRywgdHJhbnNsYXRlWTowLCBkeDo4fTt9XHJcbiAgICBwdWJsaWMgR2V0R2xvYmFsQ29ubmVjdG9ySW5kZXhPZlNpZ25hbFNvdXJjZSgpOm51bWJlciB7XHJcbiAgICAgICAgZm9yKGxldCBsaW5rIG9mIHRoaXMubGlua3MudmFsdWVzKCkpe1xyXG4gICAgICAgICAgICByZXR1cm4gbGluay5Gcm9tLkdsb2JhbENvbm5lY3RvckluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEZsb3djaGFydE91dHB1dENvbm5lY3RvciBleHRlbmRzIEZsb3djaGFydENvbm5lY3RvciB7XHJcbiAgICBjb25zdHJ1Y3RvciAocGFyZW50OiBGbG93Y2hhcnRPcGVyYXRvciwgY2FwdGlvbjogc3RyaW5nLCBsb2NhbEluZGV4Om51bWJlciwgdHlwZTpDb25uZWN0b3JUeXBlKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCBsb2NhbEluZGV4LCB0eXBlKVxyXG4gICAgICAgIHRoaXMuZWxlbWVudC5vbm1vdXNlZG93biA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHBhcmVudC5QYXJlbnQuX25vdGlmeU91dHB1dENvbm5lY3Rvck1vdXNlZG93bih0aGlzLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgR2V0TGlua3BvaW50WE9mZnNldCh3aWR0aDpudW1iZXIpOiBudW1iZXJ7cmV0dXJuIHdpZHRoO31cclxuICAgIHByb3RlY3RlZCAgZ2V0SU9TcGVjaWZpY3MoKXtyZXR1cm4ge2lucHV0T3JPdXRwdXQ6XCJvdXRwdXRcIiwgcGFyZW50OnRoaXMuUGFyZW50Lk91dHB1dFN2Z0csIHRyYW5zbGF0ZVk6MTQwLCBkeDotOH07fVxyXG59XHJcbiIsImltcG9ydCB7IEZsb3djaGFydElucHV0Q29ubmVjdG9yLCBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IgfSBmcm9tIFwiLi9GbG93Y2hhcnRDb25uZWN0b3JcIjtcclxuaW1wb3J0IHsgRmxvd2NoYXJ0IH0gZnJvbSBcIi4vRmxvd2NoYXJ0XCI7XHJcbmltcG9ydCB7JH0gZnJvbSBcIi4uL3V0aWxzXCJcclxuZXhwb3J0IGNsYXNzIEZsb3djaGFydExpbmsge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgTUFYX0lOREVYOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBpbmRleDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBlbGVtZW50OiBTVkdQYXRoRWxlbWVudDtcclxuICAgIHByaXZhdGUgY2FwdGlvbkVsZW1lbnQ6U1ZHVGV4dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGNhcHRpb25QYXRoOiBTVkdUZXh0UGF0aEVsZW1lbnQ7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBhcmVudDogRmxvd2NoYXJ0LCBwcml2YXRlIGNhcHRpb246IHN0cmluZywgcHJpdmF0ZSBjb2xvcjogc3RyaW5nLCBwcml2YXRlIGZyb206IEZsb3djaGFydE91dHB1dENvbm5lY3RvciwgcHJpdmF0ZSB0bzogRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gRmxvd2NoYXJ0TGluay5NQVhfSU5ERVgrKztcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSA8U1ZHUGF0aEVsZW1lbnQ+JC5TdmcocGFyZW50LkxpbmtMYXllciwgXCJwYXRoXCIsIFtcInN0cm9rZS13aWR0aFwiLCBcIlwiICsgdGhpcy5wYXJlbnQuT3B0aW9ucy5saW5rV2lkdGgsIFwiZmlsbFwiLCBcIm5vbmVcIiwgXCJpZFwiLCBcIkxJTktcIiArIHRoaXMuaW5kZXhdKTtcclxuICAgICAgICB0aGlzLlJlZnJlc2hQb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMuVW5zZXRDb2xvcigpO1xyXG4gICAgICAgIHRoaXMucGFyZW50LkxpbmtMYXllci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuY2FwdGlvbkVsZW1lbnQgPTxTVkdUZXh0RWxlbWVudD4kLlN2ZyhwYXJlbnQuTGlua0xheWVyLCBcInRleHRcIixbXSk7XHJcbiAgICAgICAgdGhpcy5jYXB0aW9uUGF0aCA9IDxTVkdUZXh0UGF0aEVsZW1lbnQ+JC5TdmcodGhpcy5jYXB0aW9uRWxlbWVudCwgXCJ0ZXh0UGF0aFwiLFtcInN0YXJ0T2Zmc2V0XCIsIFwiNTAlXCIsXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiXSk7XHJcbiAgICAgICAgdGhpcy5jYXB0aW9uUGF0aC5zZXRBdHRyaWJ1dGVOUygkLlhMSU5LTlMsIFwiaHJlZlwiLCAnIycgKyBcIkxJTktcIiArIHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIHRoaXMuY2FwdGlvblBhdGguaW5uZXJIVE1MID0gY2FwdGlvbjtcclxuICAgICAgICB0aGlzLmVsZW1lbnQub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9ub3RpZnlMaW5rQ2xpY2tlZCh0aGlzLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgR2xvYmFsTGlua0luZGV4KCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxyXG4gICAgZ2V0IEZyb20oKSB7IHJldHVybiB0aGlzLmZyb207IH1cclxuICAgIGdldCBUbygpIHsgcmV0dXJuIHRoaXMudG87IH1cclxuICAgIHNldCBDb2xvcihjb2xvcjogc3RyaW5nKSB7IHRoaXMuY29sb3IgPSBjb2xvcjsgfVxyXG5cclxuICAgIHB1YmxpYyBSZW1vdmVGcm9tRE9NKCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmNhcHRpb25FbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgU2V0Q29sb3IoY29sb3I6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIGNvbG9yKTtcclxuICAgICAgICAvL3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBjb2xvcik7XHJcbiAgICAgICAgLy9UT0RPOiBjb2xvcml6ZSB0aGUgc21hbGwgdHJpYW5nbGUgaW4gdGhlIGNvbm5lY3RvclxyXG4gICAgICAgIC8vbGlua0RhdGEuaW50ZXJuYWwuZWxzLmZyb21TbWFsbENvbm5lY3Rvci5jc3MoJ2JvcmRlci1sZWZ0LWNvbG9yJywgY29sb3IpO1xyXG4gICAgICAgIC8vbGlua0RhdGEuaW50ZXJuYWwuZWxzLnRvU21hbGxDb25uZWN0b3IuY3NzKCdib3JkZXItbGVmdC1jb2xvcicsIGNvbG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgU2V0Q2FwdGlvbihjYXB0aW9uOnN0cmluZyl7XHJcbiAgICAgICAgdGhpcy5jYXB0aW9uUGF0aC5pbm5lckhUTUw9Y2FwdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgVW5zZXRDb2xvcigpIHtcclxuICAgICAgICB0aGlzLlNldENvbG9yKHRoaXMucGFyZW50Lk9wdGlvbnMuZGVmYXVsdExpbmtDb2xvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIFJlZnJlc2hQb3NpdGlvbigpIHtcclxuICAgICAgICBsZXQgZnJvbVBvc2l0aW9uID0gdGhpcy5mcm9tLkdldExpbmtwb2ludCgpO1xyXG4gICAgICAgIGxldCB0b1Bvc2l0aW9uID0gdGhpcy50by5HZXRMaW5rcG9pbnQoKTtcclxuICAgICAgICBsZXQgZnJvbVggPSBmcm9tUG9zaXRpb24ueDtcclxuICAgICAgICBsZXQgZnJvbVkgPSBmcm9tUG9zaXRpb24ueSArIHRoaXMucGFyZW50Lk9wdGlvbnMubGlua1ZlcnRpY2FsRGVjYWw7XHJcbiAgICAgICAgbGV0IHRvWCA9IHRvUG9zaXRpb24ueDtcclxuICAgICAgICBsZXQgdG9ZID0gdG9Qb3NpdGlvbi55ICsgdGhpcy5wYXJlbnQuT3B0aW9ucy5saW5rVmVydGljYWxEZWNhbDtcclxuICAgICAgICBsZXQgZGlzdGFuY2VGcm9tQXJyb3cgPSB0aGlzLnBhcmVudC5PcHRpb25zLmRpc3RhbmNlRnJvbUFycm93O1xyXG4gICAgICAgIGxldCBiZXppZXJGcm9tWCA9IChmcm9tWCArIGRpc3RhbmNlRnJvbUFycm93KTtcclxuICAgICAgICBsZXQgYmV6aWVyVG9YID0gdG9YICsgMTtcclxuICAgICAgICBsZXQgYmV6aWVySW50ZW5zaXR5ID0gTWF0aC5taW4oMTAwLCBNYXRoLm1heChNYXRoLmFicyhiZXppZXJGcm9tWCAtIGJlemllclRvWCkgLyAyLCBNYXRoLmFicyhmcm9tWSAtIHRvWSkpKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZFwiLCAnTScgKyBiZXppZXJGcm9tWCArICcsJyArIChmcm9tWSkgKyAnIEMnICsgKGZyb21YICsgZGlzdGFuY2VGcm9tQXJyb3cgKyBiZXppZXJJbnRlbnNpdHkpICsgJywnICsgZnJvbVkgKyAnICcgKyAodG9YIC0gYmV6aWVySW50ZW5zaXR5KSArICcsJyArIHRvWSArICcgJyArIGJlemllclRvWCArICcsJyArIHRvWSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtGbG93Y2hhcnRJbnB1dENvbm5lY3RvciwgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yIH0gZnJvbSBcIi4vRmxvd2NoYXJ0Q29ubmVjdG9yXCI7XHJcbmltcG9ydCB7Rmxvd2NoYXJ0fSBmcm9tIFwiLi9GbG93Y2hhcnRcIjtcclxuaW1wb3J0IHsgU2VyaWFsaXplQ29udGV4dEFuZEFkcmVzc01hcCB9IGZyb20gXCIuL0Zsb3djaGFydENvbXBpbGVyXCI7XHJcbmltcG9ydCB7JCwgS2V5VmFsdWVUdXBsZX0gZnJvbSBcIi4uL3V0aWxzXCJcclxuaW1wb3J0IHsgU2ltdWxhdGlvbkNvbnRleHQgfSBmcm9tIFwiLi9TaW11bGF0aW9uQ29udGV4dFwiO1xyXG5cclxuZXhwb3J0IGVudW0gUG9zaXRpb25UeXBle1xyXG4gICAgRGVmYXVsdCxcclxuICAgIElucHV0LFxyXG4gICAgT3V0cHV0LFxyXG59O1xyXG5leHBvcnQgZW51bSBTaW5nbGV0b25UeXBle1xyXG4gICAgRGVmYXVsdCxcclxuICAgIFNpbmdsZXRvbixcclxufTtcclxuZXhwb3J0IGNsYXNzIFR5cGVJbmZvXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHB1YmxpYyBHbG9iYWxUeXBlSW5kZXg6bnVtYmVyLCBcclxuICAgICAgICBwdWJsaWMgR3JvdXBOYW1lOnN0cmluZywgXHJcbiAgICAgICAgcHVibGljIE9wZXJhdG9yTmFtZTpzdHJpbmcsIFxyXG4gICAgICAgIHB1YmxpYyBQb3NpdGlvbjpQb3NpdGlvblR5cGUsIFxyXG4gICAgICAgIHB1YmxpYyBTaW5nbGV0b246U2luZ2xldG9uVHlwZSwgXHJcbiAgICAgICAgcHVibGljIEJ1aWxkZXI6KHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCk9PkZsb3djaGFydE9wZXJhdG9yKVxyXG4gICAgICAgIHt9XHJcbn1cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcblxyXG4gICAgLy9kZXIgSW5kZXggZGVyIElucHV0cyBpc3QgcmVpbiBsb2thbCB1bmQgYmVnaW5udCBiZWkgMCBmb3J0bGF1ZmVuZFxyXG4gICAgcHJpdmF0ZSBJbnB1dHM6IEZsb3djaGFydElucHV0Q29ubmVjdG9yW109W107XHJcbiAgICAvL2RlciBJbmRleCBkZXIgT3V0cHV0cyBpc3QgcmVpbiBsb2thbCB1bmQgYmVnaW5udCBiZWkgMCBmb3J0bGF1ZmVuZFxyXG4gICAgcHJpdmF0ZSBPdXRwdXRzOiBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3JbXT0gW107XHJcblxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIE1BWF9JTkRFWDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgaW5kZXg6IG51bWJlcjtcclxuICAgIGdldCBHbG9iYWxPcGVyYXRvckluZGV4KCl7cmV0dXJuIHRoaXMuaW5kZXg7fVxyXG5cclxuICAgIHByaXZhdGUgZWxlbWVudFN2Z0c6IFNWR0dFbGVtZW50O1xyXG4gICAgZ2V0IEVsZW1lbnRTdmdHKCkgeyByZXR1cm4gdGhpcy5lbGVtZW50U3ZnRzsgfVxyXG4gICAgcHJpdmF0ZSBpbnB1dFN2Z0c6U1ZHR0VsZW1lbnQ7XHJcbiAgICBnZXQgSW5wdXRTdmdHKCk6IFNWR0dFbGVtZW50IHsgcmV0dXJuIHRoaXMuaW5wdXRTdmdHOyB9XHJcbiAgICBwcml2YXRlIG91dHB1dFN2Z0c6U1ZHR0VsZW1lbnQ7XHJcbiAgICBnZXQgT3V0cHV0U3ZnRygpOiBTVkdHRWxlbWVudCB7IHJldHVybiB0aGlzLm91dHB1dFN2Z0c7fVxyXG4gICAgcHJpdmF0ZSBkZWJ1Z0luZm9TdmdUZXh0OlNWR1RleHRFbGVtZW50O1xyXG5cclxuICAgIGdldCBUeXBlSW5mbygpe3JldHVybiB0aGlzLnR5cGVJbmZvO31cclxuXHJcbiAgICBnZXQgWHBvcygpe3JldHVybiB0aGlzLng7fVxyXG4gICAgZ2V0IFlwb3MoKXtyZXR1cm4gdGhpcy55O31cclxuICAgIGdldCBDb25maWdfQ29weSgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb25EYXRhP3RoaXMuY29uZmlndXJhdGlvbkRhdGEuc2xpY2UoMCk6bnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHg9MDtcclxuICAgIHByaXZhdGUgeT0wO1xyXG5cclxuICAgIHByb3RlY3RlZCBib3g6U1ZHUmVjdEVsZW1lbnQ7XHJcblxyXG4gICAgcHVibGljIFNob3dBc1NlbGVjdGVkKHN0YXRlOmJvb2xlYW4pXHJcbiAgICB7XHJcbiAgICAgICAgaWYoc3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJveC5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLmJveC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgU2V0RGVidWdJbmZvVGV4dCh0ZXh0OnN0cmluZyk6dm9pZHtcclxuICAgICAgICB0aGlzLmRlYnVnSW5mb1N2Z1RleHQudGV4dENvbnRlbnQ9dGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY2ZnX3NldERlZmF1bHQoa2V5OnN0cmluZywgdmFsdWU6YW55KVxyXG4gICAge1xyXG4gICAgICAgIGlmKHRoaXMuY29uZmlndXJhdGlvbkRhdGE9PW51bGwpIHRoaXMuY29uZmlndXJhdGlvbkRhdGE9W107XHJcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuY29uZmlndXJhdGlvbkRhdGEpIHtcclxuICAgICAgICAgICAgaWYoZS5rZXk9PWtleSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IFxyXG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbkRhdGEucHVzaCh7a2V5OmtleSwgdmFsdWU6dmFsdWV9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY2ZnX2dldFZhbHVlKGtleTpzdHJpbmcsIGRlZmF1bHRWYWx1ZTphbnkpOmFueVxyXG4gICAge1xyXG4gICAgICAgIGlmKHRoaXMuY29uZmlndXJhdGlvbkRhdGE9PW51bGwpIHRoaXMuY29uZmlndXJhdGlvbkRhdGE9W107XHJcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuY29uZmlndXJhdGlvbkRhdGEpIHtcclxuICAgICAgICAgICAgaWYoZS5rZXk9PWtleSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uRGF0YS5wdXNoKHtrZXk6a2V5LCB2YWx1ZTpkZWZhdWx0VmFsdWV9KTtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjZmdfc2V0VmFsdWUoa2V5OnN0cmluZywgdmFsdWU6YW55KVxyXG4gICAge1xyXG4gICAgICAgIGlmKHRoaXMuY29uZmlndXJhdGlvbkRhdGE9PW51bGwpIHRoaXMuY29uZmlndXJhdGlvbkRhdGE9W107XHJcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuY29uZmlndXJhdGlvbkRhdGEpIHtcclxuICAgICAgICAgICAgaWYoZS5rZXk9PWtleSl7XHJcbiAgICAgICAgICAgICAgICBlLnZhbHVlPXZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25EYXRhLnB1c2goe2tleTprZXksIHZhbHVlOnZhbHVlfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJlbnQ6IEZsb3djaGFydCwgcHJpdmF0ZSBjYXB0aW9uOiBzdHJpbmcsIHByaXZhdGUgdHlwZUluZm86IFR5cGVJbmZvLCBwcm90ZWN0ZWQgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gRmxvd2NoYXJ0T3BlcmF0b3IuTUFYX0lOREVYKys7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50U3ZnRyA9IDxTVkdHRWxlbWVudD4kLlN2ZyhwYXJlbnQuT3BlcmF0b3JzTGF5ZXIsIFwiZ1wiLCBbXSwgW1wib3BlcmF0b3JcIl0pO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudFN2Z0cuc2V0QXR0cmlidXRlKCdkYXRhLW9wZXJhdG9yLWluZGV4JywgXCJcIiArIHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIGxldCBkcmFnR3JvdXAgPSA8U1ZHR0VsZW1lbnQ+JC5TdmcodGhpcy5lbGVtZW50U3ZnRywgXCJnXCIsIFtdLCBbXSk7XHJcbiAgICAgICAgdGhpcy5ib3ggPSA8U1ZHUmVjdEVsZW1lbnQ+JC5TdmcoZHJhZ0dyb3VwLCBcInJlY3RcIiwgW1wid2lkdGhcIixcIjE0MFwiLCBcImhlaWdodFwiLCBcIjEwMFwiLCBcInJ4XCIsIFwiMTBcIiwgXCJyeVwiLCBcIjEwXCJdLCBbXCJvcGVyYXRvci1ib3hcIl0pO1xyXG4gICAgICAgIGxldCB0aXRsZSA9IDxTVkdUZXh0RWxlbWVudD4kLlN2ZyhkcmFnR3JvdXAsXCJ0ZXh0XCIsIFtcInhcIiwgXCI1XCIsIFwieVwiLCBcIjIxXCJdLFtcIm9wZXJhdG9yLXRpdGxlXCJdKTtcclxuICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9IGNhcHRpb247XHJcbiAgICAgICAgdGhpcy5kZWJ1Z0luZm9TdmdUZXh0ID0gPFNWR1RleHRFbGVtZW50PiQuU3ZnKGRyYWdHcm91cCwgXCJ0ZXh0XCIsIFtcInhcIiwgXCIwXCIsIFwieVwiLCBcIjEwMFwiXSxbXCJvcGVyYXRvci1kZWJ1Z2luZm9cIl0pO1xyXG4gICAgICAgIHRoaXMuZGVidWdJbmZvU3ZnVGV4dC50ZXh0Q29udGVudD1cIk5vIGRlYnVnIGluZm9cIjtcclxuXHJcbiAgICAgICAgdGhpcy5pbnB1dFN2Z0c9IDxTVkdHRWxlbWVudD4kLlN2Zyh0aGlzLmVsZW1lbnRTdmdHLFwiZ1wiLCBbXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCA1MClcIl0sIFtcIm9wZXJhdG9yLWlucHV0c1wiXSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdmdHPSA8U1ZHR0VsZW1lbnQ+JC5TdmcodGhpcy5lbGVtZW50U3ZnRyxcImdcIiwgW1widHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDE0MCA1MClcIl0sIFtcIm9wZXJhdG9yLW91dHB1dHNcIl0pO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50U3ZnRy5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGbG93Y2hhcnRPcGVyYXRvciB0aGlzLmVsZW1lbnRTdmdHLm9uY2xpY2tcIik7XHJcbiAgICAgICAgICAgIHBhcmVudC5fbm90aWZ5T3BlcmF0b3JDbGlja2VkKHRoaXMsIGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Lk9wdGlvbnMuY2FuVXNlck1vdmVPcGVyYXRvcnMpIHtcclxuICAgICAgICAgICAgZHJhZ0dyb3VwLm9ubW91c2Vkb3duID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuUmVnaXN0ZXJEcmFnZ2luZyhlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHB1YmxpYyBSZWdpc3RlckRyYWdnaW5nKGU6TW91c2VFdmVudClcclxuICAgIHtcclxuICAgICAgICBsZXQgb2Zmc2V0WD0gZS5jbGllbnRYLXRoaXMueDtcclxuICAgICAgICBsZXQgb2Zmc2V0WSA9IGUuY2xpZW50WS10aGlzLnk7XHJcblxyXG4gICAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IG51bGw7XHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gZSA9PiB7XHJcbiAgICAgICAgICAgIC8vVE9ETzogbmV1ZSBQb3NpdGlvbiBudXIgc2V0emVuLCB3ZW5uIHRoaXMuZWxlbWVudC5jbGllbnRSZWN0IGlubmVyaGFsYiB2b24gcGFyZW50LmNsaWVudFJlY3RhbmdsZSBpc3RcclxuICAgICAgICAgICAgdGhpcy5Nb3ZlVG8oZS5jbGllbnRYIC0gb2Zmc2V0WCwgZS5jbGllbnRZIC0gb2Zmc2V0WSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldCBQYXJlbnQoKSB7IHJldHVybiB0aGlzLnBhcmVudCB9O1xyXG4gICAgZ2V0IENhcHRpb24oKSB7IHJldHVybiB0aGlzLmNhcHRpb247IH1cclxuXHJcbiAgICBnZXQgSW5wdXRzS1ZJdCgpe3JldHVybiB0aGlzLklucHV0cy5lbnRyaWVzKCl9XHJcbiAgICBnZXQgT3V0cHV0c0tWSXQoKXtyZXR1cm4gdGhpcy5PdXRwdXRzLmVudHJpZXMoKX1cclxuICAgIHB1YmxpYyBHZXRPdXRwdXRDb25uZWN0b3JCeUluZGV4PShpOm51bWJlcik9PnRoaXMuT3V0cHV0c1tpXTtcclxuICAgIHB1YmxpYyBHZXRJbnB1dENvbm5lY3RvckJ5SW5kZXg9KGk6bnVtYmVyKT0+dGhpcy5JbnB1dHNbaV07XHJcblxyXG4gICAgcHVibGljIFJlbW92ZUZyb21ET00oKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50U3ZnRy5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgQXBwZW5kQ29ubmVjdG9ycyhpbnB1dHM6IEZsb3djaGFydElucHV0Q29ubmVjdG9yW10sIG91dHB1dHM6IEZsb3djaGFydE91dHB1dENvbm5lY3RvcltdKSB7XHJcbiAgICAgICAgaWYodGhpcy5JbnB1dHMubGVuZ3RoIT0wIHx8IHRoaXMuT3V0cHV0cy5sZW5ndGggIT0wKSB0aHJvdyBuZXcgRXJyb3IoXCJBcHBlbmRDb25uZWN0b3JzIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIVwiKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGlmIChpLlBhcmVudCAhPSB0aGlzKSBjb250aW51ZTtcclxuICAgICAgICAgICAgdGhpcy5JbnB1dHMucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBvIG9mIG91dHB1dHMpIHtcclxuICAgICAgICAgICAgaWYgKG8uUGFyZW50ICE9IHRoaXMpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0aGlzLk91dHB1dHMucHVzaChvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG51bSA9IE1hdGgubWF4KHRoaXMuSW5wdXRzLmxlbmd0aCwgdGhpcy5PdXRwdXRzLmxlbmd0aCk7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDUwK251bSoyMCsxMDtcclxuICAgICAgICB0aGlzLmJveC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCJcIitoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZGVidWdJbmZvU3ZnVGV4dC5zZXRBdHRyaWJ1dGUoXCJ5XCIsIFwiXCIraGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgTW92ZVRvKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IGcgPSB0aGlzLnBhcmVudC5PcHRpb25zLmdyaWQ7XHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh4IC8gZykgKiBnO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoeSAvIGcpICogZztcclxuICAgICAgICB0aGlzLmVsZW1lbnRTdmdHLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7dGhpcy54fSAke3RoaXMueX0pYCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuSW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGMuUmVmcmVzaExpbmtQb3NpdGlvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuT3V0cHV0cykge1xyXG4gICAgICAgICAgICBjLlJlZnJlc2hMaW5rUG9zaXRpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBQb3B1bGF0ZVByb3BlcnlHcmlkKHBhcmVudDpIVE1MVGFibGVTZWN0aW9uRWxlbWVudCk6Ym9vbGVhblxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgU2F2ZVByb3BlcnR5R3JpZCh0Ym9keTpIVE1MVGFibGVTZWN0aW9uRWxlbWVudCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGFydChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgT25TaW11bGF0aW9uU3RlcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgT25TaW11bGF0aW9uU3RvcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIHByb3RlY3RlZCBTZXJpYWxpemVJbnB1dHNBbmRPdXRwdXRzKGN0eDpTZXJpYWxpemVDb250ZXh0QW5kQWRyZXNzTWFwKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5JbnB1dHMpIHtcclxuICAgICAgICAgICAgbGV0IHZhcmlhYmxlQWRyZXNzID0gMDtcclxuICAgICAgICAgICAgbGV0IGxpbmtzID0gaW5wdXQuR2V0TGlua3NDb3B5KCk7XHJcbiAgICAgICAgICAgIGlmKGxpbmtzLmxlbmd0aD09MCl7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZUFkcmVzcz0xOyAvL2JlY2F1c2UgdW5jb25uZWN0ZWQgaW5wdXRzIHJlYWQgZnJvbSBhZHJlc3MgMSAod2hpY2ggaXMgXCJmYWxzZVwiLCAwLCAwLjAsIGJsYWNrLi4uKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3V0ID0gbGlua3NbMF0uRnJvbTtcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlQWRyZXNzPWN0eC50eXBlSW5kZXgyZ2xvYmFsQ29ubmVjdG9ySW5kZXgyYWRyZXNzT2Zmc2V0LmdldChvdXQuVHlwZSkhLmdldChvdXQuR2xvYmFsQ29ubmVjdG9ySW5kZXgpfHwxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5jdHgud3JpdGVVMzIodmFyaWFibGVBZHJlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IoY29uc3Qgb3V0cHV0IG9mIHRoaXMuT3V0cHV0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCB2YXJpYWJsZUFkcmVzcyA9IDA7XHJcbiAgICAgICAgICAgIGlmKG91dHB1dC5MaW5rc0xlbmd0aD09MCl7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZUFkcmVzcz0wOyAvL2JlY2F1c2UgdW5jb25uZWN0ZWQgb3V0cHV0cyB3cml0ZSB0byBhZHJlc3MgMCAod2hpY2ggaXMgbmV2ZXIgcmVhZCEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlQWRyZXNzPWN0eC50eXBlSW5kZXgyZ2xvYmFsQ29ubmVjdG9ySW5kZXgyYWRyZXNzT2Zmc2V0LmdldChvdXRwdXQuVHlwZSkhLmdldChvdXRwdXQuR2xvYmFsQ29ubmVjdG9ySW5kZXgpfHwxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5jdHgud3JpdGVVMzIodmFyaWFibGVBZHJlc3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgU2VyaWFsaXplVG9CaW5hcnkoY3R4OlNlcmlhbGl6ZUNvbnRleHRBbmRBZHJlc3NNYXApXHJcbiAgICB7XHJcbiAgICAgICAgLy9zZXJpYWxpemUgVHlwZVxyXG4gICAgICAgIGN0eC5jdHgud3JpdGVVMzIodGhpcy5UeXBlSW5mby5HbG9iYWxUeXBlSW5kZXgpO1xyXG4gICAgICAgIC8vSW5kZXggb2YgaW5zdGFuY2VcclxuICAgICAgICBjdHguY3R4LndyaXRlVTMyKHRoaXMuR2xvYmFsT3BlcmF0b3JJbmRleCk7XHJcbiAgICAgICAgdGhpcy5TZXJpYWxpemVJbnB1dHNBbmRPdXRwdXRzKGN0eCk7XHJcbiAgICAgICAgdGhpcy5TZXJpYWxpemVGdXJ0aGVyUHJvcGVydGllcyhjdHgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcm90ZWN0ZWQgU2VyaWFsaXplRnVydGhlclByb3BlcnRpZXMobWFwcGVyOlNlcmlhbGl6ZUNvbnRleHRBbmRBZHJlc3NNYXApOnZvaWR7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7Rmxvd2NoYXJ0T3BlcmF0b3IsIFR5cGVJbmZvLCBQb3NpdGlvblR5cGUsIFNpbmdsZXRvblR5cGV9IGZyb20gXCIuL0Zsb3djaGFydE9wZXJhdG9yXCI7XHJcbmltcG9ydCB7Rmxvd2NoYXJ0fSBmcm9tIFwiLi9GbG93Y2hhcnRcIjtcclxuaW1wb3J0IHtGbG93Y2hhcnRJbnB1dENvbm5lY3RvciwgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yLCBDb25uZWN0b3JUeXBlfSBmcm9tIFwiLi9GbG93Y2hhcnRDb25uZWN0b3JcIjtcclxuaW1wb3J0IHsgU2VyaWFsaXplQ29udGV4dEFuZEFkcmVzc01hcCB9IGZyb20gXCIuL0Zsb3djaGFydENvbXBpbGVyXCI7XHJcbmltcG9ydCB7JCwgS2V5VmFsdWVUdXBsZX0gZnJvbSBcIi4uL3V0aWxzXCI7XHJcbmltcG9ydCAqIGFzIFNvbmcgZnJvbSBcIi4vU29uZ3NcIjtcclxuaW1wb3J0IHsgU2ltdWxhdGlvbkNvbnRleHQgfSBmcm9tIFwiLi9TaW11bGF0aW9uQ29udGV4dFwiO1xyXG5cclxuY29uc3QgQmFzaWM9XCJCYXNpY1wiO1xyXG5jb25zdCBBcml0aG1ldGljPVwiQXJpdGhtZXRpY1wiO1xyXG5jb25zdCBJbnB1dD1cIklucHV0XCI7XHJcbmNvbnN0IFNlbnNvciA9IFwiU2Vuc29yXCI7XHJcbmNvbnN0IE91dHB1dD1cIk91dHB1dFwiO1xyXG5jb25zdCBDb252ZXJ0ZXI9XCJDb252ZXJ0ZXJcIjtcclxuY29uc3QgU291bmQgPSBcIlNvdW5kXCI7XHJcbmNvbnN0IENvbnRyb2wgPSBcIkNvbnRyb2xcIjtcclxuY29uc3QgQ3VzdG9tID1cIkN1c3RvbVwiO1xyXG5cclxuY29uc3QgQ09OU1RBTlQgPSBcIkNvbnN0YW50XCI7XHJcbmNvbnN0IFNPTkdfSU5ERVggPSBcIlNvbmcgSW5kZXhcIlxyXG5cclxuZXhwb3J0IGNsYXNzIE9wZXJhdG9yUmVnaXN0cnl7XHJcbiAgICBJc0luZGV4S25vd24oZ2xvYmFsVHlwZUluZGV4OiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDJJbmZvLmhhcyhnbG9iYWxUeXBlSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIGluZGV4MkluZm8gPSBuZXcgTWFwPG51bWJlciwgVHlwZUluZm8+KCk7XHJcbiAgICBwcml2YXRlIGdyb3VwTmFtZTJvcGVyYXRvck5hbWUySW5mbyA9IG5ldyBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBUeXBlSW5mbz4+KCk7XHJcbiAgICBcclxuICAgIHByaXZhdGUgUmVnaXN0ZXIoZ2xvYmFsVHlwZUluZGV4Om51bWJlciwgZ3JvdXBOYW1lOnN0cmluZywgb3BlcmF0b3JOYW1lOnN0cmluZywgcG9zaXRpb246UG9zaXRpb25UeXBlLCBzaW5nbGV0b246U2luZ2xldG9uVHlwZSwgYnVpbGRlcjoocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKT0+Rmxvd2NoYXJ0T3BlcmF0b3IpXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IHRpOlR5cGVJbmZvPW5ldyBUeXBlSW5mbyhnbG9iYWxUeXBlSW5kZXgsIGdyb3VwTmFtZSwgb3BlcmF0b3JOYW1lLCBwb3NpdGlvbiwgc2luZ2xldG9uLCBidWlsZGVyKVxyXG4gICAgICAgIGlmKHRoaXMuaW5kZXgySW5mby5oYXMoZ2xvYmFsVHlwZUluZGV4KSkgdGhyb3cgbmV3IEVycm9yKGB0aGlzLmluZGV4MkluZm8uaGFzKGdsb2JhbFR5cGVJbmRleCkgZm9yICR7Z3JvdXBOYW1lfTo6JHtvcGVyYXRvck5hbWV9YCk7XHJcbiAgICAgICAgdGhpcy5pbmRleDJJbmZvLnNldChnbG9iYWxUeXBlSW5kZXgsIHRpKTtcclxuICAgICAgICBpZighdGhpcy5ncm91cE5hbWUyb3BlcmF0b3JOYW1lMkluZm8uaGFzKGdyb3VwTmFtZSkpIHRoaXMuZ3JvdXBOYW1lMm9wZXJhdG9yTmFtZTJJbmZvLnNldChncm91cE5hbWUsIG5ldyBNYXA8c3RyaW5nLCBUeXBlSW5mbz4oKSk7XHJcbiAgICAgICAgbGV0IG9wZXJhdG9yTmFtZTJJbmZvID0gdGhpcy5ncm91cE5hbWUyb3BlcmF0b3JOYW1lMkluZm8uZ2V0KGdyb3VwTmFtZSkhO1xyXG4gICAgICAgIGlmKG9wZXJhdG9yTmFtZTJJbmZvLmhhcyhvcGVyYXRvck5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoYG9wZXJhdG9yTmFtZTJJbmZvLmhhcyhvcGVyYXRvck5hbWUpIGZvciAke2dyb3VwTmFtZX06OiR7b3BlcmF0b3JOYW1lfWApO1xyXG4gICAgICAgIG9wZXJhdG9yTmFtZTJJbmZvLnNldChvcGVyYXRvck5hbWUsIHRpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgQ3JlYXRlQnlJbmRleChpbmRleDpudW1iZXIsIHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKTpGbG93Y2hhcnRPcGVyYXRvcnxudWxsXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IHRpPXRoaXMuaW5kZXgySW5mby5nZXQoaW5kZXgpO1xyXG4gICAgICAgIGlmKHRpPT09dW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGkuQnVpbGRlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIEdldFR5cGVJbmZvKGluZGV4Om51bWJlcik6VHlwZUluZm98bnVsbFxyXG4gICAge1xyXG4gICAgICAgIGxldCB0aT10aGlzLmluZGV4MkluZm8uZ2V0KGluZGV4KTtcclxuICAgICAgICBpZih0aT09PXVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwb3B1bGF0ZU9wZXJhdG9yTGliKHBhcmVudDogSFRNTERpdkVsZW1lbnQsIG9ubW91c2Vkb3duSGFuZGxlcjogKGU6TW91c2VFdmVudCwgdGk6VHlwZUluZm8pPT5hbnkpIHsgXHJcbiAgICAgICAgbGV0IHkgPSAxMDtcclxuICAgICAgICBsZXQgdG9wID0gJC5IdG1sKHBhcmVudCwgXCJ1bFwiLCBbXSwgW10pO1xyXG4gICAgICAgIGZvciAoY29uc3Qga3Ygb2YgdGhpcy5ncm91cE5hbWUyb3BlcmF0b3JOYW1lMkluZm8uZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGxldCBncm91cE5hbWUgPSBrdlswXTtcclxuICAgICAgICAgICAgJC5IdG1sKHRvcCwgXCJsaVwiLCBbXSwgW10sIGdyb3VwTmFtZSk7XHJcbiAgICAgICAgICAgIGxldCB1bCA9ICQuSHRtbCh0b3AsIFwidWxcIiwgW10sIFtcIm5lc3RlZFwiXSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5mbyBvZiBrdlsxXS52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpID0gJC5IdG1sKHVsLCBcImxpXCIsIFtdLCBbXSwgaW5mby5PcGVyYXRvck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbGkub25tb3VzZWRvd24gPSAoZSkgPT4gb25tb3VzZWRvd25IYW5kbGVyKGUsIGluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgQnVpbGQoKTpPcGVyYXRvclJlZ2lzdHJ5e1xyXG4gICAgICAgIGxldCByOk9wZXJhdG9yUmVnaXN0cnkgPSBuZXcgT3BlcmF0b3JSZWdpc3RyeSgpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMSwgQmFzaWMsIFwiQU5EXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEJhc2ljX0FORE9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDIsIEJhc2ljLCBcIk9SXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEJhc2ljX09ST3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMywgQmFzaWMsIFwiWE9SXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEJhc2ljX1hPUk9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDQsIEJhc2ljLCBcIk5PVFwiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBCYXNpY19Ob3RPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3Rlcig1LCBCYXNpYywgXCJSU1wiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBCYXNpY19SU09wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDYsIEJhc2ljLCBcIlNSXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEJhc2ljX1NST3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoNywgQmFzaWMsXCJDb25zdFRSVUVcIiwgUG9zaXRpb25UeXBlLklucHV0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEJhc2ljX0NvbnN0VFJVRU9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDgsIEJhc2ljLFwiQ29uc3RGQUxTRVwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuRGVmYXVsdCwgKHAsIGNhLCB0aSwgY28pPT5uZXcgQmFzaWNfQ29uc3RGQUxTRU9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDksIEJhc2ljLCBcIkNOVFwiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBCYXNpY19DTlRPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3RlcigxMCwgQmFzaWMsIFwiVGltZWtlZXBlclwiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBCYXNpY19UaW1la2VlcGVyT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMTEsIEJhc2ljLFwiVE9OXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEJhc2ljX1RPTk9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDEyLCBCYXNpYyxcIlRPRlwiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBCYXNpY19UT0ZPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgci5SZWdpc3RlcigxMywgQXJpdGhtZXRpYywgXCJBRERcIiwgUG9zaXRpb25UeXBlLkRlZmF1bHQsIFNpbmdsZXRvblR5cGUuRGVmYXVsdCwgKHAsIGNhLCB0aSwgY28pPT5uZXcgQXJpdGhtZXRpY19BRERPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3RlcigxNCwgQXJpdGhtZXRpYywgXCJTVUJcIiwgUG9zaXRpb25UeXBlLkRlZmF1bHQsIFNpbmdsZXRvblR5cGUuRGVmYXVsdCwgKHAsIGNhLCB0aSwgY28pPT5uZXcgQXJpdGhtZXRpY19TVUJPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3RlcigxNSwgQXJpdGhtZXRpYywgXCJNVUxUSVBMWVwiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBBcml0aG1ldGljX01VTFRJUExZT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMTYsIEFyaXRobWV0aWMsIFwiRElWSURFXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEFyaXRobWV0aWNfRElWSURFT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMTcsIEFyaXRobWV0aWMsIFwiTUFYXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEFyaXRobWV0aWNfTUFYT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMTgsIEFyaXRobWV0aWMsIFwiTUlOXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEFyaXRobWV0aWNfTUlOT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMTksIEFyaXRobWV0aWMsXCJHcmVhdGVyVGhhblwiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBBcml0aG1ldGljX0dyZWF0ZXJUaGFuT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMjAsIEFyaXRobWV0aWMsXCJMZXNzVGhhblwiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBBcml0aG1ldGljX0xlc3NUaGFuT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMjEsIEFyaXRobWV0aWMsIFwiQ29uc3RJTlRcIiwgUG9zaXRpb25UeXBlLklucHV0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEFyaXRobWV0aWNfQ29uc3RJTlRPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3RlcigyMiwgQXJpdGhtZXRpYywgXCJMSU1JVFwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuRGVmYXVsdCwgKHAsIGNhLCB0aSwgY28pPT5uZXcgQXJpdGhtZXRpY19MSU1JVE9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDIzLCBBcml0aG1ldGljLCBcIkxJTUlUTU9OSVRPUlwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuRGVmYXVsdCwgKHAsIGNhLCB0aSwgY28pPT5uZXcgQXJpdGhtZXRpY19MSU1JVE1PTklUT1JPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcblxyXG4gICAgICAgIHIuUmVnaXN0ZXIoMjQsIENvbnZlcnRlciwgXCJCb29sMkNvbG9yXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEJvb2wyQ29sb3JDb252ZXJ0KHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDI1LCBDb252ZXJ0ZXIsIFwiQm9vbDJJbnRcIiwgUG9zaXRpb25UeXBlLkRlZmF1bHQsIFNpbmdsZXRvblR5cGUuRGVmYXVsdCwgKHAsIGNhLCB0aSwgY28pPT5uZXcgQm9vbDJJbnRDb252ZXJ0KHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDI2LCBDb252ZXJ0ZXIsIFwiSW50MkJvb2xcIiwgUG9zaXRpb25UeXBlLkRlZmF1bHQsIFNpbmdsZXRvblR5cGUuRGVmYXVsdCwgKHAsIGNhLCB0aSwgY28pPT5uZXcgSW50MkJvb2xDb252ZXJ0KHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDI3LCBDb252ZXJ0ZXIsIFwiSW50MkZsb2F0XCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEludDJGbG9hdENvbnZlcnQocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMjgsIENvbnZlcnRlciwgXCJJbnQyQ29sb3JcIiwgUG9zaXRpb25UeXBlLkRlZmF1bHQsIFNpbmdsZXRvblR5cGUuRGVmYXVsdCwgKHAsIGNhLCB0aSwgY28pPT5uZXcgSW50MkNvbG9yQ29udmVydChwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3RlcigyOSwgQ29udmVydGVyLCBcIkZsb2F0MkludFwiLCBQb3NpdGlvblR5cGUuRGVmYXVsdCwgU2luZ2xldG9uVHlwZS5EZWZhdWx0LCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBGbG9hdDJJbnRDb252ZXJ0KHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICBcclxuICAgICAgICByLlJlZ2lzdGVyKDMwLCBJbnB1dCwgXCJHcmVlbkJ1dHRvblwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBJbnB1dF9HcmVlbkJ1dHRvbk9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDMxLCBJbnB1dCwgXCJFbmNvZGVyQnV0dG9uXCIsIFBvc2l0aW9uVHlwZS5JbnB1dCwgU2luZ2xldG9uVHlwZS5TaW5nbGV0b24sIChwLCBjYSwgdGksIGNvKT0+bmV3IElucHV0X0VuY29kZXJCdXR0b25PcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3RlcigzMiwgSW5wdXQsIFwiRW5jb2RlclRpY2tzXCIsIFBvc2l0aW9uVHlwZS5JbnB1dCwgU2luZ2xldG9uVHlwZS5TaW5nbGV0b24sIChwLCBjYSwgdGksIGNvKT0+bmV3IElucHV0X0VuY29kZXJUaWNrc09wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDMzLCBJbnB1dCwgXCJSZWRCdXR0b25cIiwgUG9zaXRpb25UeXBlLklucHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgSW5wdXRfUmVkQnV0dG9uT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHIuUmVnaXN0ZXIoMzQsIFNlbnNvciwgXCJNb3ZlbWVudFwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBTZW5zb3JfTW92ZW1lbnRPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3RlcigzNSwgU2Vuc29yLCBcIkFpclRlbXBlcmF0dXJlRFMxOFwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBTZW5zb3JfQWlyVGVtcGVyYXR1cmVEUzE4T3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMzYsIFNlbnNvciwgXCJBaXJUZW1wZXJhdHVyZUJNRVwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBTZW5zb3JfQWlyVGVtcGVyYXR1cmVCTUVPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3RlcigzNywgU2Vuc29yLCBcIkFpckh1bWlkaXR5XCIsIFBvc2l0aW9uVHlwZS5JbnB1dCwgU2luZ2xldG9uVHlwZS5TaW5nbGV0b24sIChwLCBjYSwgdGksIGNvKT0+bmV3IFNlbnNvcl9BaXJIdW1pZGl0eU9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDM4LCBTZW5zb3IsIFwiQWlyUHJlc3N1cmVcIiwgUG9zaXRpb25UeXBlLklucHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgU2Vuc29yX0FpclByZXNzdXJlT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoMzksIFNlbnNvciwgXCJBaXJDTzJcIiwgUG9zaXRpb25UeXBlLklucHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgU2Vuc29yX0FpckNPMk9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDQwLCBTZW5zb3IsIFwiQWlyUXVhbGl0eVwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBTZW5zb3JfQWlyUXVhbGl0eU9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDQxLCBTZW5zb3IsIFwiQW1iaWVudEJyaWdodG5lc3NcIiwgUG9zaXRpb25UeXBlLklucHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgU2Vuc29yX0FtYmllbnRCcmlnaHRuZXNzT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoNDIsIFNlbnNvciwgXCJBbWJpZW50Tm9pc2VcIiwgUG9zaXRpb25UeXBlLklucHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgU2Vuc29yX0FtYmllbnROb2lzZShwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3Rlcig0MywgU2Vuc29yLCBcIkV4dGVybmFsUHJlc3N1cmVcIiwgUG9zaXRpb25UeXBlLklucHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgU2Vuc29yX0V4dGVybmFsUHJlc3N1cmUocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoNDQsIFNlbnNvciwgXCJIZWF0ZXJUZW1wZXJhdHVyZVwiLCBQb3NpdGlvblR5cGUuSW5wdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBTZW5zb3JfSGVhdGVyVGVtcGVyYXR1cmVPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgci5SZWdpc3Rlcig0NSwgT3V0cHV0LCBcIlJlbGF5XCIsIFBvc2l0aW9uVHlwZS5PdXRwdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBPdXRwdXRfUmVsYXlPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3Rlcig0NiwgT3V0cHV0LCBcIlJlZExlZFwiLCBQb3NpdGlvblR5cGUuT3V0cHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgT3V0cHV0X1JlZExlZE9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDQ3LCBPdXRwdXQsIFwiWWVsbG93TGVkXCIsIFBvc2l0aW9uVHlwZS5PdXRwdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBPdXRwdXRfWWVsbG93TGVkT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoNDgsIE91dHB1dCwgXCJHcmVlbkxlZFwiLCBQb3NpdGlvblR5cGUuT3V0cHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgT3V0cHV0X0dyZWVuTGVkT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoNDksIE91dHB1dCwgXCJMRUQzXCIsIFBvc2l0aW9uVHlwZS5PdXRwdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBPdXRwdXRfTGVkM09wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDUwLCBPdXRwdXQsIFwiTEVENFwiLCBQb3NpdGlvblR5cGUuT3V0cHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgT3V0cHV0X0xlZDRPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3Rlcig1MSwgT3V0cHV0LCBcIkxFRDVcIiwgUG9zaXRpb25UeXBlLk91dHB1dCwgU2luZ2xldG9uVHlwZS5TaW5nbGV0b24sIChwLCBjYSwgdGksIGNvKT0+bmV3IE91dHB1dF9MZWQ1T3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoNTIsIE91dHB1dCwgXCJMRUQ2XCIsIFBvc2l0aW9uVHlwZS5PdXRwdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBPdXRwdXRfTGVkNk9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDUzLCBPdXRwdXQsIFwiTEVEN1wiLCBQb3NpdGlvblR5cGUuT3V0cHV0LCBTaW5nbGV0b25UeXBlLlNpbmdsZXRvbiwgKHAsIGNhLCB0aSwgY28pPT5uZXcgT3V0cHV0X0xlZDdPcGVyYXRvcihwLCBjYSwgdGksIGNvKSk7XHJcbiAgICAgICAgci5SZWdpc3Rlcig1NCwgT3V0cHV0LCBcIkZhbjFcIiwgUG9zaXRpb25UeXBlLk91dHB1dCwgU2luZ2xldG9uVHlwZS5TaW5nbGV0b24sIChwLCBjYSwgdGksIGNvKT0+bmV3IE91dHB1dF9GYW4xT3BlcmF0b3IocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIHIuUmVnaXN0ZXIoNTUsIE91dHB1dCwgXCJGYW4yXCIsIFBvc2l0aW9uVHlwZS5PdXRwdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBPdXRwdXRfRmFuMk9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICByLlJlZ2lzdGVyKDU2LCBPdXRwdXQsIFwiUG93ZXJMZWRcIiwgUG9zaXRpb25UeXBlLk91dHB1dCwgU2luZ2xldG9uVHlwZS5TaW5nbGV0b24sIChwLCBjYSwgdGksIGNvKT0+bmV3IE91dHB1dF9Qb3dlckxlZE9wZXJhdG9yKHAsIGNhLCB0aSwgY28pKTtcclxuXHJcbiAgICAgICAgci5SZWdpc3Rlcig1NywgU291bmQsIFwiTWVsb2R5XCIsIFBvc2l0aW9uVHlwZS5PdXRwdXQsIFNpbmdsZXRvblR5cGUuU2luZ2xldG9uLCAocCwgY2EsIHRpLCBjbyk9Pm5ldyBTb3VuZF9NZWxvZHkocCwgY2EsIHRpLCBjbykpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHIuUmVnaXN0ZXIoNTgsIENvbnRyb2wsIFwiUElEXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IENvbnRyb2xfUElEKHAsIGNhLCB0aSwgY28pKTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICByLlJlZ2lzdGVyKDEwMCwgQ3VzdG9tLCBcIlhZWlhZWkJsb2NrXCIsIFBvc2l0aW9uVHlwZS5EZWZhdWx0LCBTaW5nbGV0b25UeXBlLkRlZmF1bHQsIChwLCBjYSwgdGksIGNvKT0+bmV3IEN1c3RvbV9YWVpCbG9jayhwLCBjYSwgdGksIGNvKSlcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgU2Vuc29yX0NvbW1vblNlbnNvck9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBzZW5zb3JWYWx1ZTpudW1iZXI9MDtcclxuICAgIHByaXZhdGUgTzpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwsIG5hbWVPZk91dHB1dDpzdHJpbmcsIHJlYWRvbmx5IG1pbk91dHB1dDpudW1iZXIsIHJlYWRvbmx5IG1heE91dHB1dDpudW1iZXIpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5PID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBuYW1lT2ZPdXRwdXQsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFtdLCBbdGhpcy5PXSk7XHJcbiAgICAgICAgdGhpcy5FbGVtZW50U3ZnRy5vbmNsaWNrPShlKT0+e1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklucHV0X0NvbW1vbkJ1dHRvbk9wZXJhdG9yIHRoaXMuRWxlbWVudFN2Z0cub25jbGlja1wiKTtcclxuICAgICAgICAgICAgcGFyZW50Ll9ub3RpZnlPcGVyYXRvckNsaWNrZWQodGhpcywgZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vuc29yVmFsdWU9dGhpcy5zZW5zb3JWYWx1ZT09dGhpcy5taW5PdXRwdXQ/dGhpcy5tYXhPdXRwdXQ6dGhpcy5taW5PdXRwdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT25TaW11bGF0aW9uU3RhcnQoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLnNlbnNvclZhbHVlPXRoaXMubWluT3V0cHV0O1xyXG4gICAgfVxyXG4gICAgT25TaW11bGF0aW9uU3RlcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIGN0eC5TZXRJbnRlZ2VyKHRoaXMuTywgdGhpcy5zZW5zb3JWYWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFNlbnNvcl9IZWF0ZXJUZW1wZXJhdHVyZU9wZXJhdG9yIGV4dGVuZHMgU2Vuc29yX0NvbW1vblNlbnNvck9wZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhLCBcIkRlZ3JlZXNDZWxzaXVzXCIsIDI1LCA2NSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZW5zb3JfQWlyVGVtcGVyYXR1cmVEUzE4T3BlcmF0b3IgZXh0ZW5kcyBTZW5zb3JfQ29tbW9uU2Vuc29yT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEsIFwiVGVtcGVyYXR1cmUqMTBcIiwgMTgwLCAyNTApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2Vuc29yX0FpclRlbXBlcmF0dXJlQk1FT3BlcmF0b3IgZXh0ZW5kcyBTZW5zb3JfQ29tbW9uU2Vuc29yT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEsIFwiVGVtcGVyYXR1cmUqMTBcIiwgMTgwLCAyNTApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2Vuc29yX0Fpckh1bWlkaXR5T3BlcmF0b3IgZXh0ZW5kcyBTZW5zb3JfQ29tbW9uU2Vuc29yT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEsIFwiUmVsSHVtaWQlXCIsIDQwLCA2MCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFNlbnNvcl9BaXJQcmVzc3VyZU9wZXJhdG9yIGV4dGVuZHMgU2Vuc29yX0NvbW1vblNlbnNvck9wZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhLCBcIlBhXCIsIDgwMCwgMTIwMCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZW5zb3JfQWlyQ08yT3BlcmF0b3IgZXh0ZW5kcyBTZW5zb3JfQ29tbW9uU2Vuc29yT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEsIFwiQ08ycHBtXCIsIDQwMCwgMTUwMCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZW5zb3JfQWlyUXVhbGl0eU9wZXJhdG9yIGV4dGVuZHMgU2Vuc29yX0NvbW1vblNlbnNvck9wZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhLCBcIlF1YWxpdHklXCIsIDIwLCA4MCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgU2Vuc29yX0FtYmllbnRCcmlnaHRuZXNzT3BlcmF0b3IgZXh0ZW5kcyBTZW5zb3JfQ29tbW9uU2Vuc29yT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEsIFwiTHV4XCIsIDIwMCwgNzAwKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNlbnNvcl9BbWJpZW50Tm9pc2UgZXh0ZW5kcyBTZW5zb3JfQ29tbW9uU2Vuc29yT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEsIFwiTm9pc2VkQkFcIiwgMzAsIDgwKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNlbnNvcl9FeHRlcm5hbFByZXNzdXJlIGV4dGVuZHMgU2Vuc29yX0NvbW1vblNlbnNvck9wZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhLCBcIlBhXCIsIDEwMDAsIDIwMDApO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFNlbnNvcl9Nb3ZlbWVudE9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHVibGljIFN0b3JhZ2VJZDpzdHJpbmc7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgbGV0IE8gPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiTW92ZW1lbnRcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW10sIFtPXSk7XHJcbiAgICAgICAgdGhpcy5TdG9yYWdlSWQ9XCI0NzExXCI7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBCYXNpY19BTkRPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgQTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQjpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQzpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5BID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQVwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkJcIiwgMSwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkMgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiQ1wiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5BLCB0aGlzLkJdLCBbdGhpcy5DXSk7XHJcbiAgICB9XHJcblxyXG4gICAgT25TaW11bGF0aW9uU3RlcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIGxldCBBID0gY3R4LkdldEJvb2xlYW4odGhpcy5BKTtcclxuICAgICAgICBsZXQgQiA9IGN0eC5HZXRCb29sZWFuKHRoaXMuQik7XHJcbiAgICAgICAgY3R4LlNldEJvb2xlYW4odGhpcy5DLCBBICYmIEIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQmFzaWNfT1JPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgQTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQjpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQzpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5BID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQVwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkJcIiwgMSwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkMgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiQ1wiLCAwLENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLkEsIHRoaXMuQl0sIFt0aGlzLkNdKTtcclxuICAgIH1cclxuXHJcbiAgICBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IEEgPSBjdHguR2V0Qm9vbGVhbih0aGlzLkEpO1xyXG4gICAgICAgIGxldCBCID0gY3R4LkdldEJvb2xlYW4odGhpcy5CKTtcclxuICAgICAgICBjdHguU2V0Qm9vbGVhbih0aGlzLkMsIEEgfHwgQik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCYXNpY19YT1JPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgQTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQjpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQzpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5BID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQVwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkJcIiwgMSwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkMgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiQ1wiLCAwLENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLkEsIHRoaXMuQl0sIFt0aGlzLkNdKTtcclxuICAgIH1cclxuXHJcbiAgICBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IEEgPSBjdHguR2V0Qm9vbGVhbih0aGlzLkEpO1xyXG4gICAgICAgIGxldCBCID0gY3R4LkdldEJvb2xlYW4odGhpcy5CKTtcclxuICAgICAgICBjdHguU2V0Qm9vbGVhbih0aGlzLkMsIEEgPyAhQiA6IEIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQXJpdGhtZXRpY19BRERPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgQTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQjpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQzpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5BID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQVwiLCAwLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkJcIiwgMSwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkMgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiQ1wiLCAwLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5BLCB0aGlzLkJdLCBbdGhpcy5DXSk7XHJcbiAgICB9XHJcblxyXG4gICAgT25TaW11bGF0aW9uU3RlcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIGxldCBBID0gY3R4LkdldEludGVnZXIodGhpcy5BKTtcclxuICAgICAgICBsZXQgQiA9IGN0eC5HZXRJbnRlZ2VyKHRoaXMuQik7XHJcbiAgICAgICAgY3R4LlNldEludGVnZXIodGhpcy5DLCBBICsgQik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBcml0aG1ldGljX1NVQk9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBBOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBCOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBDOkZsb3djaGFydE91dHB1dENvbm5lY3RvcjtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICB0aGlzLkEgPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJBXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5CID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQlwiLCAxLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJDXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLkEsIHRoaXMuQl0sIFt0aGlzLkNdKTtcclxuICAgIH1cclxuXHJcbiAgICBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IEEgPSBjdHguR2V0SW50ZWdlcih0aGlzLkEpO1xyXG4gICAgICAgIGxldCBCID0gY3R4LkdldEludGVnZXIodGhpcy5CKTtcclxuICAgICAgICBjdHguU2V0SW50ZWdlcih0aGlzLkMsIEEgLSBCKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBBcml0aG1ldGljX01VTFRJUExZT3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIEE6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIEI6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIEM6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuQSA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkFcIiwgMCwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkIgPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJCXCIsIDEsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5DID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBcIkNcIiwgMCwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW3RoaXMuQSwgdGhpcy5CXSwgW3RoaXMuQ10pO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBsZXQgQSA9IGN0eC5HZXRJbnRlZ2VyKHRoaXMuQSk7XHJcbiAgICAgICAgbGV0IEIgPSBjdHguR2V0SW50ZWdlcih0aGlzLkIpO1xyXG4gICAgICAgIGN0eC5TZXRJbnRlZ2VyKHRoaXMuQywgQSAqIEIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQXJpdGhtZXRpY19ESVZJREVPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgQTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQjpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQzpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5BID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQVwiLCAwLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkJcIiwgMSwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkMgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiQ1wiLCAwLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5BLCB0aGlzLkJdLCBbdGhpcy5DXSk7XHJcbiAgICB9XHJcblxyXG4gICAgT25TaW11bGF0aW9uU3RlcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIGxldCBBID0gY3R4LkdldEludGVnZXIodGhpcy5BKTtcclxuICAgICAgICBsZXQgQiA9IGN0eC5HZXRJbnRlZ2VyKHRoaXMuQik7XHJcbiAgICAgICAgY3R4LlNldEludGVnZXIodGhpcy5DLCBBIC8gQik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBcml0aG1ldGljX01BWE9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBBOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBCOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBDOkZsb3djaGFydE91dHB1dENvbm5lY3RvcjtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICB0aGlzLkEgPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJBXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5CID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQlwiLCAxLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJDXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLkEsIHRoaXMuQl0sIFt0aGlzLkNdKTtcclxuICAgIH1cclxuXHJcbiAgICBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IEEgPSBjdHguR2V0SW50ZWdlcih0aGlzLkEpO1xyXG4gICAgICAgIGxldCBCID0gY3R4LkdldEludGVnZXIodGhpcy5CKTtcclxuICAgICAgICBjdHguU2V0SW50ZWdlcih0aGlzLkMsIE1hdGgubWF4KEEsQikpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQXJpdGhtZXRpY19NSU5PcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgQTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQjpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgQzpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5BID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQVwiLCAwLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkJcIiwgMSwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkMgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiQ1wiLCAwLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5BLCB0aGlzLkJdLCBbdGhpcy5DXSk7XHJcbiAgICB9XHJcblxyXG4gICAgT25TaW11bGF0aW9uU3RlcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIGxldCBBID0gY3R4LkdldEludGVnZXIodGhpcy5BKTtcclxuICAgICAgICBsZXQgQiA9IGN0eC5HZXRJbnRlZ2VyKHRoaXMuQik7XHJcbiAgICAgICAgY3R4LlNldEludGVnZXIodGhpcy5DLCBNYXRoLm1pbihBLEIpKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJhc2ljX1JTT3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIFI6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIFM6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIEM6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBzdGF0ZTpib29sZWFuPWZhbHNlO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuUiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIlJcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLlMgPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJTXCIsIDEsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5DID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBcIkNcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW3RoaXMuUiwgdGhpcy5TXSwgW3RoaXMuQ10pO1xyXG4gICAgfVxyXG4gICAgT25TaW11bGF0aW9uU3RhcnQoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLnN0YXRlPWZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBpZihjdHguR2V0Qm9vbGVhbih0aGlzLlIpKSB0aGlzLnN0YXRlPWZhbHNlO1xyXG4gICAgICAgIGVsc2UgaWYoY3R4LkdldEJvb2xlYW4odGhpcy5TKSkgdGhpcy5zdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgY3R4LlNldEJvb2xlYW4odGhpcy5DLCB0aGlzLnN0YXRlKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJhc2ljX1NST3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIFI6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIFM6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIEM6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBzdGF0ZTpib29sZWFuPWZhbHNlO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuUiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIlJcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLlMgPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJTXCIsIDEsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5DID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBcIkNcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW3RoaXMuUiwgdGhpcy5TXSwgW3RoaXMuQ10pO1xyXG4gICAgfVxyXG4gICAgT25TaW11bGF0aW9uU3RhcnQoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLnN0YXRlPWZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBpZihjdHguR2V0Qm9vbGVhbih0aGlzLlMpKSB0aGlzLnN0YXRlID0gdHJ1ZTtcclxuICAgICAgICBlbHNlIGlmKGN0eC5HZXRCb29sZWFuKHRoaXMuUikpIHRoaXMuc3RhdGU9ZmFsc2U7XHJcbiAgICAgICAgY3R4LlNldEJvb2xlYW4odGhpcy5DLCB0aGlzLnN0YXRlKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJhc2ljX0NOVE9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBDb3VudFVwOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBSZXNldDpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgUHJlc2V0VmFsdWU6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIE9VVDpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIEN1cnJlbnRWYWx1ZTpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIF9DdXJyZW50VmFsdWU6bnVtYmVyPTA7XHJcbiAgICBwcml2YXRlIGxhc3RJbnB1dFZhbHVlOmJvb2xlYW49ZmFsc2U7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5Db3VudFVwID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQ1VcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLlJlc2V0ID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiUmVzZXRcIiwgMSwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLlByZXNldFZhbHVlID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiUFZcIiwgMiwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLk9VVCA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJPVVRcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkN1cnJlbnRWYWx1ZSA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJDVlwiLCAxLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5Db3VudFVwLCB0aGlzLlJlc2V0LCB0aGlzLlByZXNldFZhbHVlXSwgW3RoaXMuT1VULCB0aGlzLkN1cnJlbnRWYWx1ZV0pO1xyXG4gICAgfVxyXG4gICAgT25TaW11bGF0aW9uU3RhcnQoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLl9DdXJyZW50VmFsdWU9MDtcclxuICAgIH1cclxuXHJcbiAgICBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRJbnB1dFZhbHVlID0gY3R4LkdldEJvb2xlYW4odGhpcy5Db3VudFVwKTtcclxuICAgICAgICBsZXQgUFY9Y3R4LkdldEludGVnZXIodGhpcy5QcmVzZXRWYWx1ZSk7XHJcbiAgICAgICAgaWYoY3R4LkdldEJvb2xlYW4odGhpcy5SZXNldCkpe1xyXG4gICAgICAgICAgICB0aGlzLl9DdXJyZW50VmFsdWU9MDtcclxuICAgICAgICB9ZWxzZSBpZih0aGlzLmxhc3RJbnB1dFZhbHVlPT1mYWxzZSAmJiBjdXJyZW50SW5wdXRWYWx1ZT09dHJ1ZSAmJiB0aGlzLl9DdXJyZW50VmFsdWU8UFYpe1xyXG4gICAgICAgICAgICB0aGlzLl9DdXJyZW50VmFsdWUrKztcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dpY19DTlRPcGVyYXRvciB0aGlzLl9DdXJyZW50VmFsdWUrKzsgXCIrdGhpcy5fQ3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LlNldEJvb2xlYW4odGhpcy5PVVQsIHRoaXMuX0N1cnJlbnRWYWx1ZT49UFYpOy8va2FubiBhdWNoIGR1cmNoIFZlcsOkbmRlcnVuZyBkZXMgUFYgcGFzc2llcmVuLCBkZXNoYWxiIG5pY2h0IGltIGlmXHJcbiAgICAgICAgY3R4LlNldEludGVnZXIodGhpcy5DdXJyZW50VmFsdWUsIHRoaXMuX0N1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgdGhpcy5sYXN0SW5wdXRWYWx1ZT1jdXJyZW50SW5wdXRWYWx1ZVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEJhc2ljX1RpbWVrZWVwZXJPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgQ291bnRVcDpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgUmVzZXQ6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIFByZXNldFZhbHVlOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBPVVQ6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBDdXJyZW50VmFsdWU6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBfQ3VycmVudFZhbHVlTXM6bnVtYmVyPTA7XHJcbiAgICBwcml2YXRlIGxhc3RJbnB1dFZhbHVlOmJvb2xlYW49ZmFsc2U7XHJcbiAgICBwcml2YXRlIGxhc3RNaWxsaXM6bnVtYmVyPTA7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5Db3VudFVwID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiQ1VcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLlJlc2V0ID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiUmVzZXRcIiwgMSwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLlByZXNldFZhbHVlID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiUFZfbXNcIiwgMiwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLk9VVCA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJPVVRcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkN1cnJlbnRWYWx1ZSA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJDVl9tc1wiLCAxLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5Db3VudFVwLCB0aGlzLlJlc2V0LCB0aGlzLlByZXNldFZhbHVlXSwgW3RoaXMuT1VULCB0aGlzLkN1cnJlbnRWYWx1ZV0pO1xyXG4gICAgfVxyXG4gICAgT25TaW11bGF0aW9uU3RhcnQoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLl9DdXJyZW50VmFsdWVNcz0wO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBsZXQgY3VycmVudElucHV0VmFsdWUgPSBjdHguR2V0Qm9vbGVhbih0aGlzLkNvdW50VXApO1xyXG4gICAgICAgIGxldCBQVj1jdHguR2V0SW50ZWdlcih0aGlzLlByZXNldFZhbHVlKTtcclxuICAgICAgICBpZihjdHguR2V0Qm9vbGVhbih0aGlzLlJlc2V0KSl7XHJcbiAgICAgICAgICAgIHRoaXMuX0N1cnJlbnRWYWx1ZU1zPTA7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdE1pbGxpcz1jdHguR2V0TWlsbGlzKCk7XHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy5sYXN0SW5wdXRWYWx1ZT09ZmFsc2UgJiYgY3VycmVudElucHV0VmFsdWU9PXRydWUgJiYgdGhpcy5fQ3VycmVudFZhbHVlTXM8UFYpe1xyXG4gICAgICAgICAgICBsZXQgbm93ID0gY3R4LkdldE1pbGxpcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9DdXJyZW50VmFsdWVNcys9bm93LXRoaXMubGFzdE1pbGxpcztcclxuICAgICAgICAgICAgdGhpcy5sYXN0TWlsbGlzPW5vdztcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dpY19DTlRPcGVyYXRvciB0aGlzLl9DdXJyZW50VmFsdWUrKzsgXCIrdGhpcy5fQ3VycmVudFZhbHVlTXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguU2V0Qm9vbGVhbih0aGlzLk9VVCwgdGhpcy5fQ3VycmVudFZhbHVlTXM+PVBWKTsvL2thbm4gYXVjaCBkdXJjaCBWZXLDpG5kZXJ1bmcgZGVzIFBWIHBhc3NpZXJlbiwgZGVzaGFsYiBuaWNodCBpbSBpZlxyXG4gICAgICAgIGN0eC5TZXRJbnRlZ2VyKHRoaXMuQ3VycmVudFZhbHVlLCB0aGlzLl9DdXJyZW50VmFsdWVNcyk7XHJcbiAgICAgICAgdGhpcy5sYXN0SW5wdXRWYWx1ZT1jdXJyZW50SW5wdXRWYWx1ZVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQmFzaWNfTm90T3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIElOOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBPVVQ6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuSU4gPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJJTlwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuT1VUID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBcIk9VVFwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5JTl0sIFt0aGlzLk9VVF0pO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBjdHguU2V0Qm9vbGVhbih0aGlzLk9VVCwgIWN0eC5HZXRCb29sZWFuKHRoaXMuSU4pKTtcclxuICAgIH1cclxuXHJcbn1cclxuY2xhc3MgSW5wdXRfQ29tbW9uQnV0dG9uT3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIHN0YXRlOmJvb2xlYW49ZmFsc2U7XHJcbiAgICBwcml2YXRlIE86Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuTyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJJc1ByZXNzZWRcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW10sIFt0aGlzLk9dKTtcclxuICAgICAgICB0aGlzLkVsZW1lbnRTdmdHLm9uY2xpY2s9KGUpPT57XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXRfQ29tbW9uQnV0dG9uT3BlcmF0b3IgdGhpcy5FbGVtZW50U3ZnRy5vbmNsaWNrXCIpO1xyXG4gICAgICAgICAgICBwYXJlbnQuX25vdGlmeU9wZXJhdG9yQ2xpY2tlZCh0aGlzLCBlKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZT0hdGhpcy5zdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgT25TaW11bGF0aW9uU3RhcnQoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLnN0YXRlPWZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLmJveC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuc3RhdGU/XCJGYWxzZVwiOlwiVHJ1ZVwiKTtcclxuICAgICAgICB0aGlzLmJveC5jbGFzc0xpc3QuYWRkKHRoaXMuc3RhdGU/XCJUcnVlXCI6XCJGYWxzZVwiKTtcclxuICAgICAgICBjdHguU2V0Qm9vbGVhbih0aGlzLk8sIHRoaXMuc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0b3AoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLmJveC5jbGFzc0xpc3QucmVtb3ZlKFwiRmFsc2VcIiwgXCJUcnVlXCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIElucHV0X0dyZWVuQnV0dG9uT3BlcmF0b3IgZXh0ZW5kcyBJbnB1dF9Db21tb25CdXR0b25PcGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBJbnB1dF9FbmNvZGVyQnV0dG9uT3BlcmF0b3IgZXh0ZW5kcyBJbnB1dF9Db21tb25CdXR0b25PcGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBJbnB1dF9SZWRCdXR0b25PcGVyYXRvciBleHRlbmRzIElucHV0X0NvbW1vbkJ1dHRvbk9wZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIElucHV0X0VuY29kZXJUaWNrc09wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHVibGljIFN0b3JhZ2VJZDpzdHJpbmc7XHJcbiAgICBwcm90ZWN0ZWQgTzpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5PID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBcIlRpY2tzXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFtdLCBbdGhpcy5PXSk7XHJcbiAgICAgICAgdGhpcy5TdG9yYWdlSWQ9XCI0NzExXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIE9uU2ltdWxhdGlvblN0YXJ0KGN0eDogU2ltdWxhdGlvbkNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgICBjdHguU2V0SW50ZWdlcih0aGlzLk8sIDEwMDApO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dF9SZWxheU9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBJOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuST1uZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJSZWxheVwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5JXSwgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBsZXQgc3RhdGUgPSBjdHguR2V0Qm9vbGVhbih0aGlzLkkpO1xyXG4gICAgICAgIHRoaXMuYm94LmNsYXNzTGlzdC5yZW1vdmUoc3RhdGU/XCJGYWxzZVwiOlwiVHJ1ZVwiKTtcclxuICAgICAgICB0aGlzLmJveC5jbGFzc0xpc3QuYWRkKHN0YXRlP1wiVHJ1ZVwiOlwiRmFsc2VcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRfRmFuMU9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBJOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuST1uZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJQb3dlciVcIiwgMCwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW3RoaXMuSV0sIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gY3R4LkdldEludGVnZXIodGhpcy5JKTtcclxuICAgICAgICB0aGlzLmJveC5pbm5lckhUTUw9c3RhdGUrXCIlXCI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRfRmFuMk9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBJOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuST1uZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJQb3dlciVcIiwgMCwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW3RoaXMuSV0sIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gY3R4LkdldEludGVnZXIodGhpcy5JKTtcclxuICAgICAgICB0aGlzLmJveC5pbm5lckhUTUw9c3RhdGUrXCIlXCI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRfUG93ZXJMZWRPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgSTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICB0aGlzLkk9bmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiUG93ZXIlXCIsIDAsIENvbm5lY3RvclR5cGUuRkxPQVQpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5JXSwgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBsZXQgc3RhdGUgPSBjdHguR2V0RmxvYXQodGhpcy5JKTtcclxuICAgICAgICB0aGlzLmJveC5pbm5lckhUTUw9c3RhdGUrXCIlXCI7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5jbGFzcyBPdXRwdXRfQ29tbW9uTGVkT3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcm90ZWN0ZWQgIEk6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwsIHByb3RlY3RlZCBjb2xvck9uVFJVRTpzdHJpbmcsIHByb3RlY3RlZCBjb2xvck9uRkFMU0U6c3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuSSA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkxFRFwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5JXSwgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBsZXQgc3RhdGUgPSBjdHguR2V0Qm9vbGVhbih0aGlzLkkpO1xyXG4gICAgICAgIHRoaXMuYm94LnN0eWxlLmZpbGw9c3RhdGU/dGhpcy5jb2xvck9uVFJVRTp0aGlzLmNvbG9yT25GQUxTRTtcclxuICAgIH1cclxuXHJcbiAgICBPblNpbXVsYXRpb25TdG9wKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgdGhpcy5ib3guc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJmaWxsXCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dF9SZWRMZWRPcGVyYXRvciBleHRlbmRzIE91dHB1dF9Db21tb25MZWRPcGVyYXRvciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEsIFwicmVkXCIsIFwiZ3JleVwiKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dF9ZZWxsb3dMZWRPcGVyYXRvciBleHRlbmRzIE91dHB1dF9Db21tb25MZWRPcGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSwgXCJ5ZWxsb3dcIiwgXCJncmV5XCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0X0dyZWVuTGVkT3BlcmF0b3IgZXh0ZW5kcyBPdXRwdXRfQ29tbW9uTGVkT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEsIFwiZ3JlZW5cIiwgXCJncmV5XCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0X0NvbW1vblJHQkxlZE9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJvdGVjdGVkIExFRDpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICB0aGlzLkxFRCA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkxFRFwiLCAwLCBDb25uZWN0b3JUeXBlLkNPTE9SKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW3RoaXMuTEVEXSwgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLmJveC5zdHlsZS5maWxsPWN0eC5HZXRDb2xvcih0aGlzLkxFRCk7XHJcbiAgICB9XHJcblxyXG4gICAgT25TaW11bGF0aW9uU3RvcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIHRoaXMuYm94LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZmlsbFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dF9MZWQzT3BlcmF0b3IgZXh0ZW5kcyBPdXRwdXRfQ29tbW9uUkdCTGVkT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0X0xlZDRPcGVyYXRvciBleHRlbmRzIE91dHB1dF9Db21tb25SR0JMZWRPcGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRfTGVkNU9wZXJhdG9yIGV4dGVuZHMgT3V0cHV0X0NvbW1vblJHQkxlZE9wZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dF9MZWQ2T3BlcmF0b3IgZXh0ZW5kcyBPdXRwdXRfQ29tbW9uUkdCTGVkT3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0X0xlZDdPcGVyYXRvciBleHRlbmRzIE91dHB1dF9Db21tb25SR0JMZWRPcGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCYXNpY19Db25zdFRSVUVPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByb3RlY3RlZCBPOkZsb3djaGFydE91dHB1dENvbm5lY3RvcjtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICB0aGlzLk8gPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiVFJVRVwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbXSwgW3RoaXMuT10pO1xyXG4gICAgfVxyXG5cclxuICAgIE9uU2ltdWxhdGlvblN0YXJ0KGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgY3R4LlNldEJvb2xlYW4odGhpcy5PLCBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCYXNpY19Db25zdEZBTFNFT3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcblxyXG4gICAgcHJvdGVjdGVkIE86Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuTyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJUUlVFXCIsIDAsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFtdLCBbdGhpcy5PXSk7XHJcbiAgICB9XHJcblxyXG4gICAgT25TaW11bGF0aW9uU3RhcnQoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBjdHguU2V0Qm9vbGVhbih0aGlzLk8sIHRydWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU291bmRfTWVsb2R5IGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gIFxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIGxldCBBID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiVHJpZ2dlclwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbQV0sIFtdKTtcclxuICAgICAgICB0aGlzLmNmZ19zZXREZWZhdWx0KFNPTkdfSU5ERVgsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc29uZ0luZGV4SFRNTFNlbGVjdDpIVE1MU2VsZWN0RWxlbWVudHxudWxsPW51bGw7XHJcbiAgICBwdWJsaWMgUG9wdWxhdGVQcm9wZXJ5R3JpZCh0Ym9keTpIVE1MVGFibGVTZWN0aW9uRWxlbWVudCk6Ym9vbGVhblxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc29uZ0luZGV4SFRNTFNlbGVjdD0kLklucHV0U2VsZWN0KHRib2R5LCBTb25nLmRlZmF1bHQoKSwgU09OR19JTkRFWCwgdGhpcy5jb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIFNhdmVQcm9wZXJ0eUdyaWQodGJvZHk6SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQpe1xyXG4gICAgICAgIGlmKHRoaXMuc29uZ0luZGV4SFRNTFNlbGVjdD09bnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuY2ZnX3NldFZhbHVlKFNPTkdfSU5ERVgsIHBhcnNlSW50KHRoaXMuc29uZ0luZGV4SFRNTFNlbGVjdC52YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBTZXJpYWxpemVGdXJ0aGVyUHJvcGVydGllcyhjdHg6U2VyaWFsaXplQ29udGV4dEFuZEFkcmVzc01hcCk6dm9pZHtcclxuICAgICAgICBjdHguY3R4LndyaXRlUzMyKHRoaXMuY2ZnX2dldFZhbHVlKFNPTkdfSU5ERVgsIDApKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBcml0aG1ldGljX0NvbnN0SU5UT3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIE86Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuTyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJPdXRcIiwgMCwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW10sIFt0aGlzLk9dKTtcclxuICAgICAgICB0aGlzLmNmZ19zZXREZWZhdWx0KENPTlNUQU5ULCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbnN0YW50SFRNTElucHV0OkhUTUxJbnB1dEVsZW1lbnR8bnVsbD1udWxsO1xyXG4gICAgcHVibGljIFBvcHVsYXRlUHJvcGVyeUdyaWQodGJvZHk6SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQpOmJvb2xlYW5cclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbnN0YW50SFRNTElucHV0PSQuSW5wdXROdW1iZXIodGJvZHksIC0zMjc2OCwgMzI3NjcsIENPTlNUQU5ULCB0aGlzLmNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgU2F2ZVByb3BlcnR5R3JpZCh0Ym9keTpIVE1MVGFibGVTZWN0aW9uRWxlbWVudCl7XHJcbiAgICAgICAgaWYodGhpcy5jb25zdGFudEhUTUxJbnB1dD09bnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuY2ZnX3NldFZhbHVlKENPTlNUQU5ULCB0aGlzLmNvbnN0YW50SFRNTElucHV0LnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBTZXJpYWxpemVGdXJ0aGVyUHJvcGVydGllcyhjdHg6U2VyaWFsaXplQ29udGV4dEFuZEFkcmVzc01hcCk6dm9pZHtcclxuICAgICAgICBjdHguY3R4LndyaXRlUzMyKHRoaXMuY2ZnX2dldFZhbHVlKENPTlNUQU5ULCAwKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGFydChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIGN0eC5TZXRJbnRlZ2VyKHRoaXMuTywgdGhpcy5jZmdfZ2V0VmFsdWUoQ09OU1RBTlQsIDApKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5jb25zdCBDT0xPUl9UUlVFPVwiQ29sb3IgZm9yIFRSVUVcIjtcclxuY29uc3QgQ09MT1JfRkFMU0U9XCJDb2xvciBmb3IgRkFMU0VcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBCb29sMkNvbG9yQ29udmVydCBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgSU46Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIE9VVDpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5JTiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIklOXCIsIDAsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5PVVQgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiT1VUXCIsIDAsIENvbm5lY3RvclR5cGUuQ09MT1IpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5JTl0sIFt0aGlzLk9VVF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29sb3JUUlVFSFRNTElucHV0OkhUTUxJbnB1dEVsZW1lbnR8bnVsbD1udWxsO1xyXG4gICAgcHJpdmF0ZSBjb2xvckZBTFNFSFRNTElucHV0OkhUTUxJbnB1dEVsZW1lbnR8bnVsbD1udWxsO1xyXG4gICAgXHJcbiAgICBwdWJsaWMgUG9wdWxhdGVQcm9wZXJ5R3JpZCh0Ym9keTpIVE1MVGFibGVTZWN0aW9uRWxlbWVudCk6Ym9vbGVhblxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29sb3JUUlVFSFRNTElucHV0PSQuSW5wdXRDb2xvcih0Ym9keSwgQ09MT1JfVFJVRSwgdGhpcy5jb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5jb2xvckZBTFNFSFRNTElucHV0PSQuSW5wdXRDb2xvcih0Ym9keSwgQ09MT1JfRkFMU0UsIHRoaXMuY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBTYXZlUHJvcGVydHlHcmlkKHRib2R5OkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50KXtcclxuICAgICAgICBpZih0aGlzLmNvbG9yVFJVRUhUTUxJbnB1dD09bnVsbCB8fCB0aGlzLmNvbG9yRkFMU0VIVE1MSW5wdXQ9PW51bGwpIHJldHVybjtcclxuICAgICAgICB0aGlzLmNmZ19zZXRWYWx1ZShDT0xPUl9UUlVFLCB0aGlzLmNvbG9yVFJVRUhUTUxJbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5jZmdfc2V0VmFsdWUoQ09MT1JfRkFMU0UsIHRoaXMuY29sb3JGQUxTRUhUTUxJbnB1dC52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIFNlcmlhbGl6ZUZ1cnRoZXJQcm9wZXJ0aWVzKGN0eDpTZXJpYWxpemVDb250ZXh0QW5kQWRyZXNzTWFwKTp2b2lke1xyXG4gICAgICAgIGxldCBjb2xvclN0cmluZyA9IHRoaXMuY2ZnX2dldFZhbHVlKENPTE9SX1RSVUUsIFwiI2ZmMDAwMFwiKTtcclxuICAgICAgICBsZXQgY29sb3JOdW09JC5Db2xvckRvbVN0cmluZzJDb2xvck51bShjb2xvclN0cmluZyk7XHJcbiAgICAgICAgY3R4LmN0eC53cml0ZVUzMihjb2xvck51bSk7XHJcbiAgICAgICAgY29sb3JTdHJpbmcgPSB0aGlzLmNmZ19nZXRWYWx1ZShDT0xPUl9GQUxTRSwgXCIjMDAwMDAwXCIpO1xyXG4gICAgICAgIGNvbG9yTnVtPSQuQ29sb3JEb21TdHJpbmcyQ29sb3JOdW0oY29sb3JTdHJpbmcpO1xyXG4gICAgICAgIGN0eC5jdHgud3JpdGVVMzIoY29sb3JOdW0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgT25TaW11bGF0aW9uU3RlcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIGxldCBjdXJyZW50SW5wdXRWYWx1ZSA9IGN0eC5HZXRCb29sZWFuKHRoaXMuSU4pO1xyXG4gICAgICAgIGxldCBjb2xvciA9Y3VycmVudElucHV0VmFsdWU/dGhpcy5jZmdfZ2V0VmFsdWUoQ09MT1JfVFJVRSwgXCJSRURcIik6dGhpcy5jZmdfZ2V0VmFsdWUoQ09MT1JfRkFMU0UsIFwiR1JFWVwiKTtcclxuICAgICAgICBjdHguU2V0Q29sb3IodGhpcy5PVVQsIGNvbG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgTlVNQkVSX1RSVUU9XCJOdW1iZXIgZm9yIFRSVUVcIjtcclxuY29uc3QgTlVNQkVSX0ZBTFNFPVwiTnVtYmVyIGZvciBGQUxTRVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEJvb2wySW50Q29udmVydCBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgSU46Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIE9VVDpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIG51bWJlclRSVUVIVE1MSW5wdXQ6SFRNTElucHV0RWxlbWVudHxudWxsPW51bGw7XHJcbiAgICBwcml2YXRlIG51bWJlckZBTFNFSFRNTElucHV0OkhUTUxJbnB1dEVsZW1lbnR8bnVsbD1udWxsO1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5JTiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIklOXCIsIDAsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5PVVQgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiT1VUXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLklOXSwgW3RoaXMuT1VUXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIFBvcHVsYXRlUHJvcGVyeUdyaWQodGJvZHk6SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQpOmJvb2xlYW5cclxuICAgIHtcclxuICAgICAgICB0aGlzLm51bWJlclRSVUVIVE1MSW5wdXQ9JC5JbnB1dE51bWJlcih0Ym9keSwgTnVtYmVyLk1JTl9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTlVNQkVSX1RSVUUsIHRoaXMuY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMubnVtYmVyRkFMU0VIVE1MSW5wdXQ9JC5JbnB1dE51bWJlcih0Ym9keSwgTnVtYmVyLk1JTl9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTlVNQkVSX0ZBTFNFLCB0aGlzLmNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgU2F2ZVByb3BlcnR5R3JpZCh0Ym9keTpIVE1MVGFibGVTZWN0aW9uRWxlbWVudCl7XHJcbiAgICAgICAgaWYodGhpcy5udW1iZXJGQUxTRUhUTUxJbnB1dD09bnVsbCB8fCB0aGlzLm51bWJlclRSVUVIVE1MSW5wdXQ9PW51bGwpIHJldHVybjtcclxuICAgICAgICB0aGlzLmNmZ19zZXRWYWx1ZShOVU1CRVJfVFJVRSwgdGhpcy5udW1iZXJUUlVFSFRNTElucHV0LnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgIHRoaXMuY2ZnX3NldFZhbHVlKE5VTUJFUl9GQUxTRSwgdGhpcy5udW1iZXJGQUxTRUhUTUxJbnB1dC52YWx1ZUFzTnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgU2VyaWFsaXplRnVydGhlclByb3BlcnRpZXMoY3R4OlNlcmlhbGl6ZUNvbnRleHRBbmRBZHJlc3NNYXApOnZvaWR7XHJcbiAgICAgICAgY3R4LmN0eC53cml0ZVMzMih0aGlzLmNmZ19nZXRWYWx1ZShOVU1CRVJfVFJVRSwgMSkpO1xyXG4gICAgICAgIGN0eC5jdHgud3JpdGVTMzIodGhpcy5jZmdfZ2V0VmFsdWUoTlVNQkVSX0ZBTFNFLCAwKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IGkgPSBjdHguR2V0Qm9vbGVhbih0aGlzLklOKTtcclxuICAgICAgICBjdHguU2V0SW50ZWdlcih0aGlzLk9VVCwgaT90aGlzLmNmZ19nZXRWYWx1ZShOVU1CRVJfVFJVRSwgMSk6dGhpcy5jZmdfZ2V0VmFsdWUoTlVNQkVSX0ZBTFNFLCAwKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBJbnQyQm9vbENvbnZlcnQgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIElOOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBPVVQ6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5JTiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIklOXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5PVVQgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiT1VUXCIsIDAsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLklOXSwgW3RoaXMuT1VUXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIE9uU2ltdWxhdGlvblN0ZXAoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICBsZXQgaSA9IGN0eC5HZXRJbnRlZ2VyKHRoaXMuSU4pO1xyXG4gICAgICAgIGN0eC5TZXRCb29sZWFuKHRoaXMuT1VULCBpIT0wKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEludDJGbG9hdENvbnZlcnQgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIElOOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBPVVQ6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5JTiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIklOXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5PVVQgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiT1VUXCIsIDAsIENvbm5lY3RvclR5cGUuRkxPQVQpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5JTl0sIFt0aGlzLk9VVF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IGkgPSBjdHguR2V0SW50ZWdlcih0aGlzLklOKTtcclxuICAgICAgICBjdHguU2V0RmxvYXQodGhpcy5PVVQsIGkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEludDJDb2xvckNvbnZlcnQgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIElOOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBPVVQ6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5JTiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIklOXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5PVVQgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiT1VUXCIsIDAsIENvbm5lY3RvclR5cGUuQ09MT1IpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5JTl0sIFt0aGlzLk9VVF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRJbnB1dFZhbHVlID0gY3R4LkdldEludGVnZXIodGhpcy5JTik7XHJcbiAgICAgICAgY3R4LlNldENvbG9yKHRoaXMuT1VULCBjdXJyZW50SW5wdXRWYWx1ZT9cIlJFRFwiOiBcIkdSRVlcIik7Ly9UT0RPOiBIYXMgdG8gYmUgaW1wcm92ZWRcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEZsb2F0MkludENvbnZlcnQgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIElOOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBPVVQ6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEZsb3djaGFydCwgY2FwdGlvbjogc3RyaW5nLCB0aTpUeXBlSW5mbywgY29uZmlndXJhdGlvbkRhdGE6S2V5VmFsdWVUdXBsZVtdfG51bGwpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNhcHRpb24sIHRpLCBjb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgdGhpcy5JTiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIklOXCIsIDAsIENvbm5lY3RvclR5cGUuRkxPQVQpO1xyXG4gICAgICAgIHRoaXMuT1VUID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBcIk9VVFwiLCAwLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5JTl0sIFt0aGlzLk9VVF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IGkgPSBjdHguR2V0RmxvYXQodGhpcy5JTik7XHJcbiAgICAgICAgY3R4LlNldEludGVnZXIodGhpcy5PVVQsIGkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQmFzaWNfVE9OT3BlcmF0b3IgZXh0ZW5kcyBGbG93Y2hhcnRPcGVyYXRvciB7XHJcbiAgICBwcml2YXRlIGlucHV0VFJJR0dFUjpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgaW5wdXRQcmVzZXRUaW1lX21zZWNzOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBvdXRwdXQ6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBvdXRwdXRFbGFwc2VkVGltZV9tc2VjczpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIGxhc3RJbnB1dFZhbHVlOmJvb2xlYW49ZmFsc2U7XHJcbiAgICBwcml2YXRlIGlucHV0UG9zaXRpdmVFZGdlOm51bWJlciA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICB0aGlzLmlucHV0VFJJR0dFUiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIlRSSUdHRVJcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLmlucHV0UHJlc2V0VGltZV9tc2VjcyA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIlBUX01TXCIsIDEsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiT1VUXCIsIDAsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRFbGFwc2VkVGltZV9tc2VjcyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJFVF9NU1wiLCAwLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5pbnB1dFRSSUdHRVIsIHRoaXMuaW5wdXRQcmVzZXRUaW1lX21zZWNzXSwgW3RoaXMub3V0cHV0LHRoaXMub3V0cHV0RWxhcHNlZFRpbWVfbXNlY3NdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgT25TaW11bGF0aW9uU3RhcnQoY3R4OlNpbXVsYXRpb25Db250ZXh0KXtcclxuICAgICAgICB0aGlzLmlucHV0UG9zaXRpdmVFZGdlID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgT25TaW11bGF0aW9uU3RlcChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIGxldCBjdXJyZW50SW5wdXRWYWx1ZSA9IGN0eC5HZXRCb29sZWFuKHRoaXMuaW5wdXRUUklHR0VSKTtcclxuICAgICAgICBsZXQgcHJlc2V0VGltZV9tc2VjcyA9IGN0eC5HZXRJbnRlZ2VyKHRoaXMuaW5wdXRQcmVzZXRUaW1lX21zZWNzKTtcclxuICAgICAgICBsZXQgbm93ID0gY3R4LkdldE1pbGxpcygpO1xyXG4gICAgICAgIGlmKHRoaXMubGFzdElucHV0VmFsdWU9PWZhbHNlICYmIGN1cnJlbnRJbnB1dFZhbHVlPT10cnVlKXtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dFBvc2l0aXZlRWRnZT1ub3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoY3VycmVudElucHV0VmFsdWU9PWZhbHNlKXtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dFBvc2l0aXZlRWRnZT1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RJbnB1dFZhbHVlPWN1cnJlbnRJbnB1dFZhbHVlO1xyXG4gICAgICAgIGxldCBlbGFwc2VkID0gKG5vdy10aGlzLmlucHV0UG9zaXRpdmVFZGdlKTtcclxuICAgICAgICBjdHguU2V0Qm9vbGVhbih0aGlzLm91dHB1dCwgZWxhcHNlZD49cHJlc2V0VGltZV9tc2Vjcyk7XHJcbiAgICAgICAgY3R4LlNldEludGVnZXIodGhpcy5vdXRwdXRFbGFwc2VkVGltZV9tc2VjcywgZWxhcHNlZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCYXNpY19UT0ZPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICBcclxuICAgIHByaXZhdGUgaW5wdXRUUklHR0VSOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJpdmF0ZSBpbnB1dFByZXNldFRpbWVfbXNlY3M6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIG91dHB1dDpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIG91dHB1dEVsYXBzZWRUaW1lX21zZWNzOkZsb3djaGFydE91dHB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgbGFzdElucHV0VmFsdWU6Ym9vbGVhbj1mYWxzZTtcclxuICAgIHByaXZhdGUgaW5wdXROZWdhdGl2ZUVkZ2U6bnVtYmVyID0gMDtcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRUUklHR0VSID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiVFJJR0dFUlwiLCAwLCBDb25uZWN0b3JUeXBlLkJPT0xFQU4pO1xyXG4gICAgICAgIHRoaXMuaW5wdXRQcmVzZXRUaW1lX21zZWNzID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiUFRfTVNcIiwgMSwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJPVVRcIiwgMCwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICB0aGlzLm91dHB1dEVsYXBzZWRUaW1lX21zZWNzID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBcIkVUX01TXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLmlucHV0VFJJR0dFUiwgdGhpcy5pbnB1dFByZXNldFRpbWVfbXNlY3NdLCBbdGhpcy5vdXRwdXQsdGhpcy5vdXRwdXRFbGFwc2VkVGltZV9tc2Vjc10pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGFydChjdHg6U2ltdWxhdGlvbkNvbnRleHQpe1xyXG4gICAgICAgIHRoaXMuaW5wdXROZWdhdGl2ZUVkZ2UgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGVwKGN0eDpTaW11bGF0aW9uQ29udGV4dCl7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRJbnB1dFZhbHVlID0gY3R4LkdldEJvb2xlYW4odGhpcy5pbnB1dFRSSUdHRVIpO1xyXG4gICAgICAgIGxldCBwcmVzZXRUaW1lX21zZWNzID0gY3R4LkdldEludGVnZXIodGhpcy5pbnB1dFByZXNldFRpbWVfbXNlY3MpO1xyXG4gICAgICAgIGxldCBub3cgPSBjdHguR2V0TWlsbGlzKCk7XHJcbiAgICAgICAgaWYodGhpcy5sYXN0SW5wdXRWYWx1ZT09dHJ1ZSAmJiBjdXJyZW50SW5wdXRWYWx1ZT09ZmFsc2Upe1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0TmVnYXRpdmVFZGdlPW5vdztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjdXJyZW50SW5wdXRWYWx1ZT09dHJ1ZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXROZWdhdGl2ZUVkZ2U9MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYXN0SW5wdXRWYWx1ZT1jdXJyZW50SW5wdXRWYWx1ZTtcclxuICAgICAgICBsZXQgZWxhcHNlZCA9IChub3ctdGhpcy5pbnB1dE5lZ2F0aXZlRWRnZSk7XHJcbiAgICAgICAgZWxhcHNlZD1NYXRoLm1pbihlbGFwc2VkLCBwcmVzZXRUaW1lX21zZWNzKVxyXG4gICAgICAgIGN0eC5TZXRCb29sZWFuKHRoaXMub3V0cHV0LCBjdXJyZW50SW5wdXRWYWx1ZSB8fCAoZWxhcHNlZDxwcmVzZXRUaW1lX21zZWNzKSk7XHJcbiAgICAgICAgY3R4LlNldEludGVnZXIodGhpcy5vdXRwdXRFbGFwc2VkVGltZV9tc2VjcywgZWxhcHNlZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQXJpdGhtZXRpY19MSU1JVE9wZXJhdG9yIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgcHJvdGVjdGVkIE1pbmltdW06Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcm90ZWN0ZWQgSW5wdXQ6Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcm90ZWN0ZWQgTWF4aW11bTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByb3RlY3RlZCBPdXRwdXQ6Rmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yO1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuTWluaW11bSA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIk1pbmltdW1cIiwgMCwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLklucHV0ID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiSW5wdXRcIiwgMSwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLk1heGltdW0gPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJNYXhpbXVtXCIsIDIsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5PdXRwdXQgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiT3V0cHV0XCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLk1pbmltdW0sIHRoaXMuSW5wdXQsIHRoaXMuTWF4aW11bV0sIFt0aGlzLk91dHB1dF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBPblNpbXVsYXRpb25TdGVwKGN0eDogU2ltdWxhdGlvbkNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaSA9IGN0eC5HZXRJbnRlZ2VyKHRoaXMuSW5wdXQpO1xyXG4gICAgICAgIGxldCBtaW4gPSBjdHguR2V0SW50ZWdlcih0aGlzLk1pbmltdW0pO1xyXG4gICAgICAgIGxldCBtYXggPSBjdHguR2V0SW50ZWdlcih0aGlzLk1pbmltdW0pO1xyXG4gICAgICAgIGN0eC5TZXRJbnRlZ2VyKHRoaXMuT3V0cHV0LCBpPm1heD9tYXg6aTxtaW4/bWluOmkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQXJpdGhtZXRpY19MSU1JVE1PTklUT1JPcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByb3RlY3RlZCBNaW5pbXVtOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJvdGVjdGVkIElucHV0OkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJvdGVjdGVkIE1heGltdW06Rmxvd2NoYXJ0SW5wdXRDb25uZWN0b3I7XHJcbiAgICBwcm90ZWN0ZWQgSHlzdGVyZXNlOkZsb3djaGFydElucHV0Q29ubmVjdG9yO1xyXG4gICAgcHJvdGVjdGVkIExMRTpGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3I7XHJcbiAgICBwcm90ZWN0ZWQgVUxFOkZsb3djaGFydE91dHB1dENvbm5lY3RvcjtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICB0aGlzLk1pbmltdW0gPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJNaW5pbXVtXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5JbnB1dCA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIklucHV0XCIsIDEsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5NYXhpbXVtID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiTWF4aW11bVwiLCAyLCBDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuSHlzdGVyZXNlID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiSHlzdGVyZXNlXCIsIDMsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgdGhpcy5MTEUgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiTExFXCIsIDAsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5VTEUgPSBuZXcgRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yKHRoaXMsIFwiVUxFXCIsIDEsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFt0aGlzLk1pbmltdW0sIHRoaXMuSW5wdXQsIHRoaXMuTWF4aW11bV0sIFt0aGlzLkxMRSwgdGhpcy5VTEVdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgT25TaW11bGF0aW9uU3RlcChjdHg6IFNpbXVsYXRpb25Db250ZXh0KTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGkgPSBjdHguR2V0SW50ZWdlcih0aGlzLklucHV0KTtcclxuICAgICAgICBsZXQgbWluID0gY3R4LkdldEludGVnZXIodGhpcy5NaW5pbXVtKTtcclxuICAgICAgICBsZXQgbWF4ID0gY3R4LkdldEludGVnZXIodGhpcy5NaW5pbXVtKTtcclxuICAgICAgICBsZXQgaCA9IGN0eC5HZXRJbnRlZ2VyKHRoaXMuSHlzdGVyZXNlKTtcclxuICAgICAgICBpZihpPm1heCl7XHJcbiAgICAgICAgICAgIGN0eC5TZXRCb29sZWFuKHRoaXMuVUxFLCB0cnVlKTtcclxuICAgICAgICB9ZWxzZSBpZihpPD1tYXgtaCl7XHJcbiAgICAgICAgICAgIGN0eC5TZXRCb29sZWFuKHRoaXMuVUxFLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGk8bWluKXtcclxuICAgICAgICAgICAgY3R4LlNldEJvb2xlYW4odGhpcy5MTEUsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZihpPj1taW4raCl7XHJcbiAgICAgICAgICAgIGN0eC5TZXRCb29sZWFuKHRoaXMuTExFLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEFyaXRobWV0aWNfR3JlYXRlclRoYW5PcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICBsZXQgQSA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkFcIiwgMCwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICBsZXQgQiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkJcIiwgMSwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICBsZXQgQyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJDXCIsIDAsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFtBLCBCXSwgW0NdKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFyaXRobWV0aWNfTGVzc1RoYW5PcGVyYXRvciBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRmxvd2NoYXJ0LCBjYXB0aW9uOiBzdHJpbmcsIHRpOlR5cGVJbmZvLCBjb25maWd1cmF0aW9uRGF0YTpLZXlWYWx1ZVR1cGxlW118bnVsbCkge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgY2FwdGlvbiwgdGksIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuICAgICAgICBsZXQgQSA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkFcIiwgMCwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICBsZXQgQiA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkJcIiwgMSwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICBsZXQgQyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJDXCIsIDAsIENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRDb25uZWN0b3JzKFtBLCBCXSwgW0NdKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tX1hZWkJsb2NrIGV4dGVuZHMgRmxvd2NoYXJ0T3BlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIGxldCBBID0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiVGVtcFZMXCIsIDAsIENvbm5lY3RvclR5cGUuSU5URUdFUik7XHJcbiAgICAgICAgbGV0IEIgPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJUZW1wUkxcIiwgMSwgQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICBsZXQgQjEgPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJTd2l0Y2hcIiwgMiwgQ29ubmVjdG9yVHlwZS5CT09MRUFOKTtcclxuICAgICAgICBsZXQgQyA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJNb3RvclwiLCAwLENvbm5lY3RvclR5cGUuQk9PTEVBTik7XHJcbiAgICAgICAgbGV0IEMxID0gbmV3IEZsb3djaGFydE91dHB1dENvbm5lY3Rvcih0aGlzLCBcIlZhbHZlXCIsIDEsQ29ubmVjdG9yVHlwZS5JTlRFR0VSKTtcclxuICAgICAgICB0aGlzLkFwcGVuZENvbm5lY3RvcnMoW0EsIEIsIEIxXSwgW0MsIEMxXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB2YWx1ZTFIVE1MSW5wdXQ6SFRNTElucHV0RWxlbWVudHxudWxsPW51bGw7XHJcbiAgICBwcml2YXRlIHZhbHVlMkhUTUxJbnB1dDpIVE1MSW5wdXRFbGVtZW50fG51bGw9bnVsbDtcclxuICAgIHByaXZhdGUgdmFsdWUzSFRNTElucHV0OkhUTUxJbnB1dEVsZW1lbnR8bnVsbD1udWxsO1xyXG4gICAgcHJpdmF0ZSBjb2xvcjFIVE1MSW5wdXQ6SFRNTElucHV0RWxlbWVudHxudWxsPW51bGw7XHJcbiAgICBwdWJsaWMgUG9wdWxhdGVQcm9wZXJ5R3JpZCh0Ym9keTpIVE1MVGFibGVTZWN0aW9uRWxlbWVudCk6Ym9vbGVhblxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudmFsdWUxSFRNTElucHV0PSQuSW5wdXROdW1iZXIodGJvZHksIC0zMjc2OCwgMzI3NjcsIFwiVmFsdWUxXCIsIHRoaXMuY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMudmFsdWUxSFRNTElucHV0PSQuSW5wdXROdW1iZXIodGJvZHksIC0zMjc2OCwgMzI3NjcsIFwiVmFsdWUyXCIsIHRoaXMuY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMudmFsdWUxSFRNTElucHV0PSQuSW5wdXROdW1iZXIodGJvZHksIC0zMjc2OCwgMzI3NjcsIFwiVmFsdWUzXCIsIHRoaXMuY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuY29sb3IxSFRNTElucHV0PSQuSW5wdXRDb2xvcih0Ym9keSwgXCJDb2xvcjFcIiwgdGhpcy5jb25maWd1cmF0aW9uRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIFNhdmVQcm9wZXJ0eUdyaWQodGJvZHk6SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQpe1xyXG4gICAgICAgIHRoaXMuY2ZnX3NldFZhbHVlKFwiVmFsdWUxXCIsIHRoaXMudmFsdWUxSFRNTElucHV0IS52YWx1ZUFzTnVtYmVyKTtcclxuICAgICAgICB0aGlzLmNmZ19zZXRWYWx1ZShcIlZhbHVlMlwiLCB0aGlzLnZhbHVlMkhUTUxJbnB1dCEudmFsdWVBc051bWJlcik7XHJcbiAgICAgICAgdGhpcy5jZmdfc2V0VmFsdWUoXCJWYWx1ZTNcIiwgdGhpcy52YWx1ZTNIVE1MSW5wdXQhLnZhbHVlQXNOdW1iZXIpO1xyXG4gICAgICAgIHRoaXMuY2ZnX3NldFZhbHVlKFwiQ29sb3IxXCIsIHRoaXMuY29sb3IxSFRNTElucHV0IS52YWx1ZUFzTnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgU2VyaWFsaXplRnVydGhlclByb3BlcnRpZXMoY3R4OlNlcmlhbGl6ZUNvbnRleHRBbmRBZHJlc3NNYXApOnZvaWR7XHJcbiAgICAgICAgY3R4LmN0eC53cml0ZVMzMih0aGlzLmNmZ19nZXRWYWx1ZShcIlZhbHVlMVwiLCAwKSk7XHJcbiAgICAgICAgY3R4LmN0eC53cml0ZVMzMih0aGlzLmNmZ19nZXRWYWx1ZShcIlZhbHVlMlwiLCAwKSk7XHJcbiAgICAgICAgY3R4LmN0eC53cml0ZVMzMih0aGlzLmNmZ19nZXRWYWx1ZShcIlZhbHVlM1wiLCAwKSk7XHJcbiAgICAgICAgbGV0IGNvbG9yU3RyaW5nID0gdGhpcy5jZmdfZ2V0VmFsdWUoXCJDb2xvcjFcIiwgXCIjMDAwMDAwXCIpO1xyXG4gICAgICAgIGxldCBjb2xvck51bT0kLkNvbG9yRG9tU3RyaW5nMkNvbG9yTnVtKGNvbG9yU3RyaW5nKTtcclxuICAgICAgICBjdHguY3R4LndyaXRlVTMyKGNvbG9yTnVtKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDb250cm9sX1BJRCBleHRlbmRzIEZsb3djaGFydE9wZXJhdG9yIHtcclxuICAgIHByaXZhdGUgaW5wdXRBY3R1YWxWYWx1ZTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgaW5wdXRTZXRwb2ludDpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgaW5wdXRLUDpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgaW5wdXRLSTpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgaW5wdXRLRDpGbG93Y2hhcnRJbnB1dENvbm5lY3RvcjtcclxuICAgIHByaXZhdGUgb3V0cHV0OkZsb3djaGFydE91dHB1dENvbm5lY3RvcjtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBGbG93Y2hhcnQsIGNhcHRpb246IHN0cmluZywgdGk6VHlwZUluZm8sIGNvbmZpZ3VyYXRpb25EYXRhOktleVZhbHVlVHVwbGVbXXxudWxsKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBjYXB0aW9uLCB0aSwgY29uZmlndXJhdGlvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRBY3R1YWxWYWx1ZSA9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIkFjdHVhbFwiLCAwLCBDb25uZWN0b3JUeXBlLkZMT0FUKTtcclxuICAgICAgICB0aGlzLmlucHV0U2V0cG9pbnQgPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJTZXRwb2ludFwiLCAxLCBDb25uZWN0b3JUeXBlLkZMT0FUKTtcclxuICAgICAgICB0aGlzLmlucHV0S1A9IG5ldyBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcih0aGlzLCBcIktQXCIsIDIsIENvbm5lY3RvclR5cGUuRkxPQVQpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRLST0gbmV3IEZsb3djaGFydElucHV0Q29ubmVjdG9yKHRoaXMsIFwiS0lcIiwgMywgQ29ubmVjdG9yVHlwZS5GTE9BVCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dEtEPSBuZXcgRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IodGhpcywgXCJLRFwiLCA0LCBDb25uZWN0b3JUeXBlLkZMT0FUKTtcclxuICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IodGhpcywgXCJPdXRcIiwgMSxDb25uZWN0b3JUeXBlLklOVEVHRVIpO1xyXG4gICAgICAgIHRoaXMuQXBwZW5kQ29ubmVjdG9ycyhbdGhpcy5pbnB1dEFjdHVhbFZhbHVlLCB0aGlzLmlucHV0U2V0cG9pbnQsIHRoaXMuaW5wdXRLUCwgdGhpcy5pbnB1dEtJLCB0aGlzLmlucHV0S0RdLCBbdGhpcy5vdXRwdXRdKTtcclxuICAgIH1cclxufSIsIlxyXG5leHBvcnQgY2xhc3MgU2VyaWFsaXplQ29udGV4dCB7XHJcbiAgICBwdWJsaWMgd3JpdGVHVUlEKGd1aWQ6IFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJEVi5zZXRVaW50OCh0aGlzLmJ1ZmZlck9mZnNldCArIGksIGd1aWRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCArPSAxNjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29uc3VtZUdVSURhbmRDb21wYXJlKGNvbXBhcmU6VWludDhBcnJheSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCB2YWw9dHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgaWYoY29tcGFyZVtpXSE9dGhpcy5idWZmZXJEVi5nZXRVaW50OCh0aGlzLmJ1ZmZlck9mZnNldCArIGkpKXtcclxuICAgICAgICAgICAgICAgIHZhbD1mYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ICs9IDE2O1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGJ1ZmZlckRWOiBEYXRhVmlldztcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYnVmZmVyOiBBcnJheUJ1ZmZlciwgcHJpdmF0ZSBidWZmZXJPZmZzZXQ6IG51bWJlciA9IDApIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlckRWID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGZ1bmhhc2goc3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyKTpudW1iZXJ7XHJcbiAgICAgICAgZW5kPU1hdGgubWluKGVuZCwgdGhpcy5idWZmZXJEVi5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBmb3IodmFyIGkgPSBzdGFydCwgaCA9IDB4ZGVhZGJlZWY7IGkgPCBlbmQ7IGkrKylcclxuICAgICAgICAgICAgaCA9IE1hdGguaW11bChoIF4gdGhpcy5idWZmZXJEVi5nZXRVaW50OChpKSwgMjY1NDQzNTc2MSk7XHJcbiAgICAgICAgcmV0dXJuIChoIF4gaCA+Pj4gMTYpID4+PiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVyd3JpdGVVMzIodGhlTnVtYmVyOiBudW1iZXIsIG9mZnNldDpudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZihvZmZzZXQ+dGhpcy5idWZmZXJPZmZzZXQtNCkgdGhyb3cgbmV3IEVycm9yKFwib2Zmc2V0PnRoaXMuYnVmZmVyT2Zmc2V0LTRcIik7XHJcbiAgICAgICAgdGhpcy5idWZmZXJEVi5zZXRVaW50MzIob2Zmc2V0LCB0aGVOdW1iZXIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHdyaXRlUzMyKHRoZU51bWJlcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5idWZmZXJEVi5zZXRJbnQzMih0aGlzLmJ1ZmZlck9mZnNldCwgdGhlTnVtYmVyLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCArPSA0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB3cml0ZVUzMih0aGVOdW1iZXI6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyRFYuc2V0VWludDMyKHRoaXMuYnVmZmVyT2Zmc2V0LCB0aGVOdW1iZXIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ICs9IDQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHdyaXRlRjMyKHRoZU51bWJlcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5idWZmZXJEVi5zZXRGbG9hdDMyKHRoaXMuYnVmZmVyT2Zmc2V0LCB0aGVOdW1iZXIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ICs9IDQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlYWRGMzIoKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgdmFsID0gdGhpcy5idWZmZXJEVi5nZXRGbG9hdDMyKHRoaXMuYnVmZmVyT2Zmc2V0LCB0cnVlKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCArPSA0O1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlYWRVMzIoKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgdmFsID0gdGhpcy5idWZmZXJEVi5nZXRVaW50MzIodGhpcy5idWZmZXJPZmZzZXQsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVhZFMzMigpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCB2YWwgPSB0aGlzLmJ1ZmZlckRWLmdldEludDMyKHRoaXMuYnVmZmVyT2Zmc2V0LCB0cnVlKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCArPSA0O1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFJlc3VsdCgpOiBBcnJheUJ1ZmZlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMuYnVmZmVyT2Zmc2V0KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBIYXNoQW5kQnVmQW5kTWFwcywgU29ydGVkT3BlcmF0b3JzQW5kTWFwcyB9IGZyb20gXCIuL0Zsb3djaGFydENvbXBpbGVyXCI7XHJcbmltcG9ydCB7IEZsb3djaGFydElucHV0Q29ubmVjdG9yLCBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IgfSBmcm9tIFwiLi9GbG93Y2hhcnRDb25uZWN0b3JcIjtcclxuaW1wb3J0IHsgRmxvd2NoYXJ0T3BlcmF0b3IgfSBmcm9tIFwiLi9GbG93Y2hhcnRPcGVyYXRvclwiO1xyXG5pbXBvcnQgeyBTaW11bGF0aW9uQ29udGV4dCB9IGZyb20gXCIuL1NpbXVsYXRpb25Db250ZXh0XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2ltdWxhdGlvbk1hbmFnZXIgaW1wbGVtZW50cyBTaW11bGF0aW9uQ29udGV4dHtcclxuICAgIHByaXZhdGUgYm9vbGVhbnMhOiBib29sZWFuW107XHJcbiAgICBwcml2YXRlIGludGVnZXJzITpudW1iZXJbXTtcclxuICAgIHByaXZhdGUgZmxvYXRzITpudW1iZXJbXTtcclxuICAgIHByaXZhdGUgY29sb3JzITpzdHJpbmdbXTtcclxuICAgIHByaXZhdGUgbWlsbGlzU2luY2UxOTcwITpudW1iZXI7XHJcbiAgICBwcml2YXRlIHJ1bm5pbmc6Ym9vbGVhbj1mYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNvcnRlZE9wZXJhdG9yc0FuZE1hcHM6IFNvcnRlZE9wZXJhdG9yc0FuZE1hcHMpe1xyXG4gICAgICAgIHRoaXMucmVzZXREYXRhc3RydWN0dXJlcygpITtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0RGF0YXN0cnVjdHVyZXMoKXtcclxuICAgICAgICB0aGlzLmJvb2xlYW5zID1uZXcgQXJyYXkodGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnR5cGVJbmRleDJtYXhPZmZzZXQuZ2V0KDApKTtcclxuICAgICAgICB0aGlzLmludGVnZXJzICA9IG5ldyBBcnJheSh0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4Mm1heE9mZnNldC5nZXQoMSkpO1xyXG4gICAgICAgIHRoaXMuZmxvYXRzICA9IG5ldyBBcnJheSh0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4Mm1heE9mZnNldC5nZXQoMikpO1xyXG4gICAgICAgIHRoaXMuY29sb3JzICA9IG5ldyBBcnJheSh0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4Mm1heE9mZnNldC5nZXQoMykpO1xyXG4gICAgICAgIHRoaXMubWlsbGlzU2luY2UxOTcwPURhdGUubm93KCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIFNldEJvb2xlYW4ob3V0Q29ubjogRmxvd2NoYXJ0T3V0cHV0Q29ubmVjdG9yLCB2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGxldCBpID0gdGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQuZ2V0KDApIS5nZXQob3V0Q29ubi5HbG9iYWxDb25uZWN0b3JJbmRleCkhO1xyXG4gICAgICAgIHRoaXMuYm9vbGVhbnNbaV09dmFsdWU7XHJcbiAgICB9XHJcbiAgICBTZXRJbnRlZ2VyKG91dENvbm46IEZsb3djaGFydE91dHB1dENvbm5lY3RvciwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBpID0gdGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQuZ2V0KDEpIS5nZXQob3V0Q29ubi5HbG9iYWxDb25uZWN0b3JJbmRleCkhO1xyXG4gICAgICAgIHRoaXMuaW50ZWdlcnNbaV09dmFsdWU7XHJcbiAgICB9XHJcbiAgICBTZXRGbG9hdChvdXRDb25uOiBGbG93Y2hhcnRPdXRwdXRDb25uZWN0b3IsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaSA9IHRoaXMuc29ydGVkT3BlcmF0b3JzQW5kTWFwcy50eXBlSW5kZXgyZ2xvYmFsQ29ubmVjdG9ySW5kZXgyYWRyZXNzT2Zmc2V0LmdldCgyKSEuZ2V0KG91dENvbm4uR2xvYmFsQ29ubmVjdG9ySW5kZXgpITtcclxuICAgICAgICB0aGlzLmZsb2F0c1tpXT12YWx1ZTtcclxuICAgIH1cclxuICAgIFNldENvbG9yKG91dENvbm46IEZsb3djaGFydE91dHB1dENvbm5lY3RvciwgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBpID0gdGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQuZ2V0KDMpIS5nZXQob3V0Q29ubi5HbG9iYWxDb25uZWN0b3JJbmRleCkhO1xyXG4gICAgICAgIHRoaXMuY29sb3JzW2ldPXZhbHVlO1xyXG4gICAgfVxyXG4gICAgR2V0Qm9vbGVhbihpbkNvbm46IEZsb3djaGFydElucHV0Q29ubmVjdG9yKTogYm9vbGVhbiB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldC5nZXQoMCkhLmdldChpbkNvbm4uR2V0R2xvYmFsQ29ubmVjdG9ySW5kZXhPZlNpZ25hbFNvdXJjZSgpKSE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9vbGVhbnNbaV07XHJcbiAgICB9XHJcbiAgICBHZXRJbnRlZ2VyKGluQ29ubjogRmxvd2NoYXJ0SW5wdXRDb25uZWN0b3IpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBpID0gdGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnR5cGVJbmRleDJnbG9iYWxDb25uZWN0b3JJbmRleDJhZHJlc3NPZmZzZXQuZ2V0KDEpIS5nZXQoaW5Db25uLkdldEdsb2JhbENvbm5lY3RvckluZGV4T2ZTaWduYWxTb3VyY2UoKSkhO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXJzW2ldO1xyXG4gICAgfVxyXG4gICAgR2V0RmxvYXQoaW5Db25uOiBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcik6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldC5nZXQoMikhLmdldChpbkNvbm4uR2V0R2xvYmFsQ29ubmVjdG9ySW5kZXhPZlNpZ25hbFNvdXJjZSgpKSE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXRzW2ldO1xyXG4gICAgfVxyXG4gICAgR2V0Q29sb3IoaW5Db25uOiBGbG93Y2hhcnRJbnB1dENvbm5lY3Rvcik6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4Mmdsb2JhbENvbm5lY3RvckluZGV4MmFkcmVzc09mZnNldC5nZXQoMykhLmdldChpbkNvbm4uR2V0R2xvYmFsQ29ubmVjdG9ySW5kZXhPZlNpZ25hbFNvdXJjZSgpKSE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBTdGFydCh3YXJtc3RhcnQ6Ym9vbGVhbj1mYWxzZSl7XHJcbiAgICAgICAgaWYoIXdhcm1zdGFydCkgdGhpcy5yZXNldERhdGFzdHJ1Y3R1cmVzKCk7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nPXRydWU7XHJcbiAgICAgICAgZm9yKGxldCBvIG9mIHRoaXMuc29ydGVkT3BlcmF0b3JzQW5kTWFwcy5zb3J0ZWRPcGVyYXRvcnMpe1xyXG4gICAgICAgICAgICBvLk9uU2ltdWxhdGlvblN0YXJ0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT50aGlzLlN0ZXAoKSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBTdG9wKCl7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nPWZhbHNlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBTdGVwKCk6dm9pZHtcclxuICAgICAgICB0aGlzLm1pbGxpc1NpbmNlMTk3MD0gRGF0ZS5ub3coKTtcclxuICAgICAgICBmb3IobGV0IG8gb2YgdGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnNvcnRlZE9wZXJhdG9ycyl7XHJcbiAgICAgICAgICAgIG8uT25TaW11bGF0aW9uU3RlcCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb2xvcml6ZSBib29sZWFucyBsaW5rc1xyXG4gICAgICAgIGZvcihsZXQga3Ygb2YgdGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnR5cGVJbmRleDJhZHJlc3NPZmZzZXQyTGlzdE9mTGlua3MuZ2V0KDApIS5lbnRyaWVzKCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgYWRyZXNzT2Zmc2V0PWt2WzBdO1xyXG4gICAgICAgICAgICBpZihhZHJlc3NPZmZzZXQ8MikgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYm9vbGVhbnNbYWRyZXNzT2Zmc2V0XVxyXG4gICAgICAgICAgICBsZXQgbGlua3NUb0NoYW5nZT1rdlsxXTtcclxuICAgICAgICAgICAgbGlua3NUb0NoYW5nZS5mb3JFYWNoKChlKT0+e1xyXG4gICAgICAgICAgICAgICAgZS5TZXRDb2xvcih2YWx1ZT9cInJlZFwiOlwiZ3JleVwiKTtcclxuICAgICAgICAgICAgICAgIGUuU2V0Q2FwdGlvbihcIlwiK3ZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbG9yaXplIGludGVnZXJzIGxpbmtzXHJcbiAgICAgICAgZm9yKGxldCBrdiBvZiB0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4MmFkcmVzc09mZnNldDJMaXN0T2ZMaW5rcy5nZXQoMSkhLmVudHJpZXMoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBhZHJlc3NPZmZzZXQ9a3ZbMF07XHJcbiAgICAgICAgICAgIGlmKGFkcmVzc09mZnNldDwyKSBjb250aW51ZTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5pbnRlZ2Vyc1thZHJlc3NPZmZzZXRdXHJcbiAgICAgICAgICAgIGxldCBsaW5rc1RvQ2hhbmdlPWt2WzFdO1xyXG4gICAgICAgICAgICBsaW5rc1RvQ2hhbmdlLmZvckVhY2goKGUpPT57XHJcbiAgICAgICAgICAgICAgICBlLlNldENhcHRpb24oXCJcIit2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbG9yaXplIGZsb2F0cyBsaW5rc1xyXG4gICAgICAgIGZvcihsZXQga3Ygb2YgdGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnR5cGVJbmRleDJhZHJlc3NPZmZzZXQyTGlzdE9mTGlua3MuZ2V0KDIpIS5lbnRyaWVzKCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgYWRyZXNzT2Zmc2V0PWt2WzBdO1xyXG4gICAgICAgICAgICBpZihhZHJlc3NPZmZzZXQ8MikgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZmxvYXRzW2FkcmVzc09mZnNldF1cclxuICAgICAgICAgICAgbGV0IGxpbmtzVG9DaGFuZ2U9a3ZbMV07XHJcbiAgICAgICAgICAgIGxpbmtzVG9DaGFuZ2UuZm9yRWFjaCgoZSk9PntcclxuICAgICAgICAgICAgICAgIGUuU2V0Q2FwdGlvbihcIlwiK3ZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29sb3JpemUgY29sb3JzIGxpbmtzXHJcbiAgICAgICAgZm9yKGxldCBrdiBvZiB0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4MmFkcmVzc09mZnNldDJMaXN0T2ZMaW5rcy5nZXQoMykhLmVudHJpZXMoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBhZHJlc3NPZmZzZXQ9a3ZbMF07XHJcbiAgICAgICAgICAgIGlmKGFkcmVzc09mZnNldDwyKSBjb250aW51ZTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5jb2xvcnNbYWRyZXNzT2Zmc2V0XVxyXG4gICAgICAgICAgICBsZXQgbGlua3NUb0NoYW5nZT1rdlsxXTtcclxuICAgICAgICAgICAgbGlua3NUb0NoYW5nZS5mb3JFYWNoKChlKT0+e1xyXG4gICAgICAgICAgICAgICAgZS5TZXRDYXB0aW9uKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGUuU2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5ydW5uaW5nKXtcclxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpcy5TdGVwKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBmb3IobGV0IG8gb2YgdGhpcy5zb3J0ZWRPcGVyYXRvcnNBbmRNYXBzLnNvcnRlZE9wZXJhdG9ycyl7XHJcbiAgICAgICAgICAgICAgICBvLk9uU2ltdWxhdGlvblN0b3AodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKGxldCB0eXBlcyBvZiB0aGlzLnNvcnRlZE9wZXJhdG9yc0FuZE1hcHMudHlwZUluZGV4MmFkcmVzc09mZnNldDJMaXN0T2ZMaW5rcy52YWx1ZXMoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBrdiBvZiB0eXBlcy5lbnRyaWVzKCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhZHJlc3NPZmZzZXQ9a3ZbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYWRyZXNzT2Zmc2V0PDIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYm9vbGVhbnNbYWRyZXNzT2Zmc2V0XVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5rc1RvQ2hhbmdlPWt2WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzVG9DaGFuZ2UuZm9yRWFjaCgoZSk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5TZXRDb2xvcihcImJsdWVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuU2V0Q2FwdGlvbihcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBHZXRNaWxsaXMoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNTaW5jZTE5NzA7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHsgU3RyaW5nTnVtYmVyVHVwbGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKXsgcmV0dXJuIFtcclxuXHRuZXcgU3RyaW5nTnVtYmVyVHVwbGUoXCJObyBTb25nXCIsIDApLFxyXG5cdG5ldyBTdHJpbmdOdW1iZXJUdXBsZShcInBvc2l0aXZlXCIsIDEpLFxyXG5cdG5ldyBTdHJpbmdOdW1iZXJUdXBsZShcIm5lZ2F0aXZlXCIsIDIpLFxyXG5cdG5ldyBTdHJpbmdOdW1iZXJUdXBsZShcIkJhcmJpZV9naXJsXCIsIDMpLFxyXG5cdG5ldyBTdHJpbmdOdW1iZXJUdXBsZShcIkhhdW50ZWRIb3VzZVwiLCA0KSxcclxuXHRuZXcgU3RyaW5nTnVtYmVyVHVwbGUoXCJheGVsZlwiLCA1KSxcclxuXHRuZXcgU3RyaW5nTnVtYmVyVHVwbGUoXCJCb25kXzAwN1wiLCA2KSxcclxuXTtcclxufTtcclxuIiwiLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3BvbG9naWNhbF9zb3J0aW5nXHJcblxyXG5cclxuZW51bSBNYXJrZXJTdGF0ZVxyXG57XHJcbiAgICBOT05FLFxyXG4gICAgVEVNUE9SQVJZLFxyXG4gICAgUEVSTUFORU5ULFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgIE5vZGVXcmFwcGVyPE4+IHtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcGF5bG9hZDpOKSB7XHJcbiAgICAgICAgdGhpcy5NYXJrPU1hcmtlclN0YXRlLk5PTkU7XHJcbiAgICAgICAgdGhpcy5EZXBlbmRlbmROb2Rlcz1bXTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBNYXJrOk1hcmtlclN0YXRlXHJcbiAgICBwdWJsaWMgRGVwZW5kZW5kTm9kZXM6Tm9kZVdyYXBwZXI8Tj5bXTtcclxuICAgIGdldCBQYXlsb2FkKCkge3JldHVybiB0aGlzLnBheWxvYWQ7fVxyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIFRvcG9sb2dpY2FsU29ydERGUzxOPntcclxuICAgIHByaXZhdGUgTDpBcnJheTxOb2RlV3JhcHBlcjxOPj47XHJcbiAgICBjb25zdHJ1Y3RvcigpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5MPW5ldyBBcnJheTxOb2RlV3JhcHBlcjxOPj4oKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc29ydChoZWFkTm9kZTpBcnJheTxOb2RlV3JhcHBlcjxOPj4pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5MPW5ldyBBcnJheTxOb2RlV3JhcHBlcjxOPj4oKTtcclxuICAgICAgICBoZWFkTm9kZS5mb3JFYWNoKChuKT0+dGhpcy52aXNpdChuKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuTDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZpc2l0KG46Tm9kZVdyYXBwZXI8Tj4pe1xyXG4gICAgICAgIGlmKG4uTWFyaz09TWFya2VyU3RhdGUuUEVSTUFORU5UKSByZXR1cm47XHJcbiAgICAgICAgaWYobi5NYXJrPT1NYXJrZXJTdGF0ZS5URU1QT1JBUlkpIHRocm93IG5ldyBFcnJvcihcIm5vdCBhIERBR1wiKTtcclxuICAgICAgICBuLk1hcms9TWFya2VyU3RhdGUuVEVNUE9SQVJZO1xyXG4gICAgICAgIGZvciAoY29uc3QgZCBvZiBuLkRlcGVuZGVuZE5vZGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaXQoZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4uTWFyaz1NYXJrZXJTdGF0ZS5QRVJNQU5FTlQ7XHJcbiAgICAgICAgdGhpcy5MLnB1c2gobik7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgY2xhc3MgVXRpbHNcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBFdmVudENvb3JkaW5hdGVzSW5TVkcoZXZ0Ok1vdXNlRXZlbnQsIGVsZW1lbnQ6RWxlbWVudCwgcG9zaXRpb25SYXRpbzpudW1iZXI9MSk6TG9jYXRpb24yRCB7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHJldHVybiB7eDogKGV2dC5jbGllbnRYIC0gcmVjdC5sZWZ0KS9wb3NpdGlvblJhdGlvLCB5OihldnQuY2xpZW50WSAtIHJlY3QudG9wKS9wb3NpdGlvblJhdGlvfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uMkQge1xyXG4gICAgeDogbnVtYmVyO1xyXG4gICAgeTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEtleVZhbHVlVHVwbGUge1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICB2YWx1ZTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU3RyaW5nTnVtYmVyVHVwbGV7XHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHM6c3RyaW5nLCBwdWJsaWMgbjpudW1iZXIpe31cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyAkXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU1ZHTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFhMSU5LTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSFRNTE5TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBTdmcocGFyZW50OiBFbGVtZW50LCB0eXBlOnN0cmluZywgIGF0dHJpYnV0ZXM6c3RyaW5nW10sIGNsYXNzZXM/OiBzdHJpbmdbXSk6U1ZHRWxlbWVudCB7XHJcbiAgICAgICAgcmV0dXJuICBwYXJlbnQuYXBwZW5kQ2hpbGQoPFNWR0VsZW1lbnQ+JC5FbGVtKCQuU1ZHTlMsIHR5cGUsIGF0dHJpYnV0ZXMsIGNsYXNzZXMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLzxzdmcgY2xhc3M9XCJpY29uIGljb24td2FzdGViYXNrZXRcIj48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi13YXN0ZWJhc2tldFwiPjwvdXNlPjwvc3ZnPlxyXG4gICAgcHVibGljIHN0YXRpYyBTdmdJY29uKHBhcmVudDogRWxlbWVudCwgaWNvbm5hbWU6c3RyaW5nKTpTVkdTVkdFbGVtZW50XHJcbiAgICB7XHJcbiAgICAgICAgbGV0IHN2ZyA9IDxTVkdTVkdFbGVtZW50PiQuU3ZnKHBhcmVudCwgXCJzdmdcIiwgW10sIFtcImljb25cIiwgXCJpY29uLVwiK2ljb25uYW1lXSk7XHJcbiAgICAgICAgbGV0IHVzZSA9JC5Tdmcoc3ZnLCBcInVzZVwiLCBbXSwgW10pO1xyXG4gICAgICAgIHVzZS5zZXRBdHRyaWJ1dGVOUyh0aGlzLlhMSU5LTlMsIFwiaHJlZlwiLCBcIiNpY29uLVwiK2ljb25uYW1lKTtcclxuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcclxuICAgICAgICByZXR1cm4gc3ZnO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgQ29sb3JOdW1Db2xvcjJDb2xvckRvbVN0cmluZyhudW06bnVtYmVyKTpzdHJpbmcge1xyXG4gICAgICAgIGxldCBzdHIgPSBudW0udG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgNikgc3RyID0gXCIwXCIgKyBudW07XHJcbiAgICAgICAgcmV0dXJuIFwiI1wiK3N0cjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIENvbG9yRG9tU3RyaW5nMkNvbG9yTnVtKGNvbG9yU3RyaW5nOiBzdHJpbmcpOm51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbG9yU3RyaW5nLnN1YnN0cmluZygxKSwgMTYpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgSHRtbChwYXJlbnQ6IEVsZW1lbnQsIHR5cGU6c3RyaW5nLCAgYXR0cmlidXRlczpzdHJpbmdbXSwgY2xhc3Nlcz86IHN0cmluZ1tdLCB0ZXh0Q29udGVudD86c3RyaW5nKTpIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5hcHBlbmRDaGlsZCg8SFRNTEVsZW1lbnQ+JC5FbGVtKCQuSFRNTE5TLCB0eXBlLCBhdHRyaWJ1dGVzLCBjbGFzc2VzLCB0ZXh0Q29udGVudCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgSHRtbEFzRmlyc3RDaGlsZChwYXJlbnQ6IEVsZW1lbnQsIHR5cGU6c3RyaW5nLCAgYXR0cmlidXRlczpzdHJpbmdbXSwgY2xhc3Nlcz86IHN0cmluZ1tdLCB0ZXh0Q29udGVudD86c3RyaW5nKTpIVE1MRWxlbWVudCB7XHJcbiAgICAgICAgaWYocGFyZW50LmZpcnN0Q2hpbGQpXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuaW5zZXJ0QmVmb3JlKDxIVE1MRWxlbWVudD4kLkVsZW0oJC5IVE1MTlMsIHR5cGUsIGF0dHJpYnV0ZXMsIGNsYXNzZXMsIHRleHRDb250ZW50KSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5hcHBlbmRDaGlsZCg8SFRNTEVsZW1lbnQ+JC5FbGVtKCQuSFRNTE5TLCB0eXBlLCBhdHRyaWJ1dGVzLCBjbGFzc2VzLCB0ZXh0Q29udGVudCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIEVsZW0obnM6c3RyaW5nLCB0eXBlOnN0cmluZywgYXR0cmlidXRlczpzdHJpbmdbXSwgY2xhc3Nlcz86IHN0cmluZ1tdLCB0ZXh0Q29udGVudD86c3RyaW5nKTpFbGVtZW50XHJcbiAgICB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHR5cGUpO1xyXG4gICAgICAgIGlmKGNsYXNzZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsYXp6IG9mIGNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGF6eik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGk6bnVtYmVyO1xyXG4gICAgICAgIGZvcihpPTA7aTxhdHRyaWJ1dGVzLmxlbmd0aDtpKz0yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlc1tpXSwgYXR0cmlidXRlc1tpKzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGV4dENvbnRlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50PXRleHRDb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIElucHV0TnVtYmVyKHRhYmxlOkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50LCBtaW46bnVtYmVyLCBtYXg6bnVtYmVyLCBrZXk6c3RyaW5nLCBjZmc6S2V5VmFsdWVUdXBsZVtdfG51bGwpOkhUTUxJbnB1dEVsZW1lbnRcclxuICAgIHtcclxuICAgICAgICBsZXQgdmFsdWU6bnVtYmVyPTA7XHJcbiAgICAgICAgaWYoY2ZnIT1udWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGNmZykge1xyXG4gICAgICAgICAgICAgICAgaWYoZS5rZXk9PWtleSAmJiAhaXNOYU4oZS52YWx1ZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRyPSQuSHRtbCh0YWJsZSwgXCJ0clwiLCBbXSxbXCJkZXZlbG9wLXByb3BlcnR5Z3JpZC10clwiXSk7XHJcbiAgICAgICAgJC5IdG1sKHRyLCBcInRkXCIsIFtdLFtcImRldmVsb3AtcHJvcGVydHlncmlkLXRkXCJdLCBrZXkpO1xyXG4gICAgICAgIGxldCBpbnB1dENvbnRhaW5lciA9ICQuSHRtbCh0ciwgXCJ0ZFwiLCBbXSxbXCJkZXZlbG9wLXByb3BlcnR5Z3JpZC10ZFwiXSk7XHJcbiAgICAgICAgcmV0dXJuIDxIVE1MSW5wdXRFbGVtZW50PiQuSHRtbChpbnB1dENvbnRhaW5lciwgXCJpbnB1dFwiLCBbXCJ0eXBlXCIsIFwibnVtYmVyXCIsIFwibWluXCIsIFwiXCIrTWF0aC5yb3VuZChtaW4pLCBcIm1heFwiLCBcIlwiK01hdGgucm91bmQobWF4KSwgXCJ2YWx1ZVwiLCBcIlwiK01hdGgucm91bmQodmFsdWUpLF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgSW5wdXRTZWxlY3QodGFibGU6SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQsIGRpc3BsYXlWYWx1ZUFuZEtleXZhbHVlczpTdHJpbmdOdW1iZXJUdXBsZVtdLCBrZXk6c3RyaW5nLCBjZmc6S2V5VmFsdWVUdXBsZVtdfG51bGwpOkhUTUxTZWxlY3RFbGVtZW50XHJcbiAgICB7XHJcbiAgICAgICAgbGV0IHZhbHVlOm51bWJlcj0wO1xyXG4gICAgICAgIGlmKGNmZyE9bnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBjZmcpIHtcclxuICAgICAgICAgICAgICAgIGlmKGUua2V5PT1rZXkgJiYgIWlzTmFOKGUudmFsdWUpKXtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT1lLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0cj0kLkh0bWwodGFibGUsIFwidHJcIiwgW10sW1wiZGV2ZWxvcC1wcm9wZXJ0eWdyaWQtdHJcIl0pO1xyXG4gICAgICAgICQuSHRtbCh0ciwgXCJ0ZFwiLCBbXSxbXCJkZXZlbG9wLXByb3BlcnR5Z3JpZC10ZFwiXSwga2V5KTtcclxuICAgICAgICBsZXQgaW5wdXRDb250YWluZXIgPSAkLkh0bWwodHIsIFwidGRcIiwgW10sW1wiZGV2ZWxvcC1wcm9wZXJ0eWdyaWQtdGRcIl0pO1xyXG4gICAgICAgIGxldCBzZWxlY3QgPSA8SFRNTFNlbGVjdEVsZW1lbnQ+JC5IdG1sKGlucHV0Q29udGFpbmVyLCBcInNlbGVjdFwiLCBbXSwgW10pO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8ZGlzcGxheVZhbHVlQW5kS2V5dmFsdWVzLmxlbmd0aDtpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgb3B0aW9uID0gJC5IdG1sKHNlbGVjdCwgXCJvcHRpb25cIiwgW1widmFsdWVcIiwgXCJcIitkaXNwbGF5VmFsdWVBbmRLZXl2YWx1ZXNbaV0ubl0sIFtdLCBkaXNwbGF5VmFsdWVBbmRLZXl2YWx1ZXNbaV0ucyk7XHJcbiAgICAgICAgICAgIGlmKGk9PXZhbHVlKXtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCBcIlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0O1xyXG4gICAgfVxyXG5cclxuICAgXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBJbnB1dENvbG9yKHRhYmxlOkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50LCBrZXk6c3RyaW5nLCBjZmc6S2V5VmFsdWVUdXBsZVtdfG51bGwpOkhUTUxJbnB1dEVsZW1lbnRcclxuICAgIHtcclxuICAgICAgICBsZXQgdmFsdWU6c3RyaW5nPVwiI2ZmMDAwMFwiO1xyXG4gICAgICAgIGlmKGNmZyE9bnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBjZmcpIHtcclxuICAgICAgICAgICAgICAgIGlmKGUua2V5PT1rZXkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRyPSQuSHRtbCh0YWJsZSwgXCJ0clwiLCBbXSxbXCJkZXZlbG9wLXByb3BlcnR5Z3JpZC10clwiXSk7XHJcbiAgICAgICAgJC5IdG1sKHRyLCBcInRkXCIsIFtdLFtcImRldmVsb3AtcHJvcGVydHlncmlkLXRkXCJdLCBrZXkpO1xyXG4gICAgICAgIGxldCBpbnB1dENvbnRhaW5lciA9ICQuSHRtbCh0ciwgXCJ0ZFwiLCBbXSxbXCJkZXZlbG9wLXByb3BlcnR5Z3JpZC10ZFwiXSk7XHJcbiAgICAgICAgcmV0dXJuIDxIVE1MSW5wdXRFbGVtZW50PiQuSHRtbChpbnB1dENvbnRhaW5lciwgXCJpbnB1dFwiLCBbXCJ0eXBlXCIsIFwiY29sb3JcIiwgIFwidmFsdWVcIiwgdmFsdWVdKTtcclxuICAgIH1cclxufSJdfQ=="}